<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Without a strong will, nothing can be achieved</title>
    <url>/comprove/</url>
    <content><![CDATA[<h2 id="Without-a-strong-will-nothing-can-be-achieved"><a href="#Without-a-strong-will-nothing-can-be-achieved" class="headerlink" title="Without a strong will, nothing can be achieved"></a>Without a strong will, nothing can be achieved</h2><h2 id="没有坚强意志，必将一事无成"><a href="#没有坚强意志，必将一事无成" class="headerlink" title="没有坚强意志，必将一事无成"></a>没有坚强意志，必将一事无成</h2><p><strong>Life is never plain sailing.To succeed, a strong will is indispensable.Life is like a marathon, many people can not reach the end.This is not due to physical exhaustion, but because the will is not strong enough.</strong></p>
<p>   人生从来都不是一帆风顺的。想要获得成功，坚强的意志不可或缺。人生如同马拉松，许多人却无法到达终点。这不是由于体力不支，而是因为意志不够坚强。</p>
<a id="more"></a>

<p><strong>Take quitting smoking for example. Some people think it’s a piece of cake.In the morning they were ambitious to quit, but in the evening they felt they were being seduced by the smell of cigarettes.Their throats were sore, their mouths dry, and their hands were shaking.After a painful struggle, they say to themselves, “one is enough, one is enough, and tomorrow I will stop smoking once and for all.”In this way they surrendered to the weak will.Eventually, they quit “a hundred times” and never succeeded.</strong><br>   拿戒烟来说，有的人认为小事一桩。早上还雄心勃勃地要戒烟，可到了晚上，就感到香烟的气味正引诱着他们。他们喉咙发酸，口干舌燥，就连手也颤抖不已。经过痛苦的思想斗争，他们会对自己说：“一根足矣，就一根，明天我就彻底戒烟。”就这样，他们向软弱的意志缴械投降。最终，他们戒烟“一百次”，却从无一次成功。</p>
<p><strong>There is a widespread humorous saying that “Quitting smoking is theeasiest thing in the world. I’ve done it for hundreds of times.” 1. Funny as itis, the saying ironically reflects the fact that strong will is the mostessential quality for anyone who wants to achieve something, and it plays a vitalrole in our success.</strong><br>有一个普遍的笑话说：戒烟是世界上最容易的事儿，我已经做了几百次。有趣的是，这反映了一个事实，坚强的意志是人们完成一件事情的基本品质，他在我们的成功中扮演着重要的角色。</p>
<p><strong>Just like giving up smoking, you can’t do anything without a strong will.For a successful life, a strong will means that you know where you’re going and stick to the path you’ve chosen.There is no doubt that success belongs to those who overcome their own weak will and persist to the last minute.</strong><br>   正如戒烟一样，没有坚强意志，必将一事无成。对于成功人生，坚强的意志就意味着你自己知道你的目的地，并且在自己选择的道路上坚持下去。毫无疑问，成功属于那些克服自身软弱意志而又坚持到最后一刻的人。</p>
<p><strong>Our life involves all kinds of obstacles and setbacks which mayexhaust us. Therefore, we must have a strong will to meet the challenge. What’smore, there are many temptations waiting for us when we are striving forsuccess. For example, when we are doing our utmost to quit playing computergames, our friends just play with great satisfaction. Then how can we resistthe temptation? Obviously, only with a strong will can we conquer ourselvesand realize our goals.</strong><br>我们的生活展示出了那些耗尽我们精力的障碍与挫折。因此，我们必须拥有坚强的意志去迎接挑战。最重要的是，当我们追求成功的时候，那里会有很多诱惑等着我们。例如，当我们正在努力的戒除电脑游戏的时候，我们的朋友却玩的很高兴。那么我们应该如何抵抗这些诱惑。显然，只有坚强的意志才能让我们战胜自己，实现到自己的目标。</p>
<p><strong>The weak can only struggle, and the brave can overcome;A fool can only lament, but a wise man can go a thousand ways.</strong><br>  弱者只有千难万难，而勇者则能披荆斩棘；愚者只有声声哀叹，智者却有千路万路。</p>
<p><strong>When you smile to yourself, there is no trouble in the world can pester you;When you are honest with yourself, no one in the world can deceive you.Live in the applause of others, the most easily lost themselves;In the care of others, the most easily weakened themselves.People who dare to face difficulties, so life is strong;Those who dare to challenge adversity thrive.Thank the person who gave you advice, he made you mature;Be thankful to the one who made you strong.</strong><br>  当你对自己微笑时，世上没烦事能纠缠你；当你对自己诚意时，世上没人能欺骗你。活在别人的掌声中，最易迷失自己；处在别人的关爱中，最易弱化自己。敢于面对困境的人，生命因此坚强；敢于挑战逆境的人，生命因此茁壮。要感谢给你提意见的人，他使你成熟；要感谢给你造困境的人，他使你坚强。</p>
<p><strong>Celebrities become famous because they keep climbing when their companions are having fun or resting.A man is mortal because he sleeps while others are busy climbing.No sweat, no tears of success;No hard work, no rich fruit;No hard training, no flash of gold.To transform the world, we must transform ourselves;To succeed in business, you must toil yourself;You have to work hard to reach the top successfully.</strong><br>  名人之所以能够成为名人，是因为他们在同伴嬉乐或休息时不停地攀登；凡人之所以成为凡人，是因为别人忙于攀登时他却安然入睡。没有辛勤的汗水，就没有成功的泪水；没有艰辛的付出，就没有丰硕的果实；没有刻苦的训练，就没有闪光的金牌。要改造世界，得先改造自己；要成就事业，得先劳苦自身；要胜利登顶，得先奋力攀登。</p>
<p><strong>The road of life has both the road, and there is mud;There are both beauty and trap, only the firm faith and courage to reach the end of the victory.The crossroads of life is a difficult choice, careful choice to ensure the right direction, confused choice is easy to go astray, give up the choice will be lost.</strong><br>  人生道路上既有坦道，又有泥泞；既有美景，又有陷阱，只有坚定信念又勇往直前的人才能到达胜利的终点。人生的十字路口是一道艰难的选择题，谨慎选择才能确保正确方向，糊涂选择就易步入歧途，放弃选择就会迷失方向。</p>
<p><strong>The pioneer has his own way, the conservative follows the old ways, the explorer climbs to the top, and the persistent goes forward courageously.Look into the distance and you will pick up the pace.Watch the scenery, and you will walk lightly;Only when you walk in company can you sing and laugh;You can climb to the top only if you have to work hard.</strong><br>   开拓者独辟蹊径，保守者因循守旧，探索者勇攀高峰，执着者勇往直前。瞩目远方，你才会加快步伐；观赏风景，你才会步履轻盈；结伴同行，你才能欢歌笑语；风雨兼程，你才能成功登顶。</p>
<p><strong>In life, sometimes the best way is not necessarily the road, but the path;In reality, sometimes the easiest way is not necessarily a straight one, but a zigzag one.</strong><br>   在人生中，有时最好走的路不一定是大路，而是小路；在现实中，有时最便捷的路不一定是直路，而是曲折路。</p>
<p><strong>Life is struggle, only the courage to climb to create brilliant;Life is innovation, only with The Times to keep up with The Times;Life is to pay, only hard sweat to achieve the ideal;Life is to enjoy, only taste life can feel the joy of life.</strong><br>   生活就是奋斗，只有勇于攀登才能创造辉煌；生活就是创新，只有与时俱进才能跟上时代；生活就是付出，只有吃苦流汗才能实现理想；生活就是享受，只有品尝人生才能感知生活的快乐。</p>
<p><strong>Approach the wilderness, to be satisfied with the beauty of spring;Into the river, to feel the gentle summer water;Pick the fruits, to taste the taste of autumn;Through the cold winter, to feel the warmth of spring!</strong><br>   走近原野，才能饱赏春天的美色；融入江河，才能感知夏水的温柔；采摘硕果，才能品尝秋天的味道；走过寒冬，才能感知春天的温暖！  </p>
<p><strong>Step forward, no matter how long the road is not under words;Stagnant, however short the road is difficult to reach.Travel is not only about speed, but also about whether you can continue;Moving forward is not only about speed, but also about staying in the right direction.</strong><br>   迈开脚步，再长的路也不在话下；停滞不前，再短的路也难以到达。行路不仅仅在于快慢，还在于是否能够持续；前进不仅仅在于速度，更在于能否保持正确方向。</p>
<p><strong>All in all, success only belongs to those who can suffer long yearsof toil and make constant efforts, just as the old popular saying goes, “Whenthere is a will, there is a way.”</strong><br>总之，成功只属于那些能够忍受多年辛苦工作，不断努力的人，就像一句古话说的：有志者事竟成。</p>
<p>(1) Although it is funny, the sayingironically reflects … 虽然很有趣，它反映了……</p>
<p>(2) Clearly, it appears to be funny, thesaying ironically reflects … 显然，他很有趣，反映了……</p>
<p>(1) No doubt, only when we have a strongwill can we conquer ourselves and realize our goals. 毫无疑问，只有我们拥有坚强的意志我们才能克服自己，实现自己的目标。</p>
<p>(3) Clearly, only with strong will can webe the master of ourselves and make our dreams come true. 显然，只有坚强的意志才能让我们成为自己的主人，让我们的梦想成真。</p>
<h2 id="Finally-do-not-experience-the-wind-and-rain-how-can-the-top-of-the-computer-mountain-to-see-the-rainbow-No-matter-how-I-believe-tomorrow-will-be-better"><a href="#Finally-do-not-experience-the-wind-and-rain-how-can-the-top-of-the-computer-mountain-to-see-the-rainbow-No-matter-how-I-believe-tomorrow-will-be-better" class="headerlink" title="Finally, do not experience the wind and rain, how can the top of the computer mountain to see the rainbow!No matter how, I believe tomorrow will be better!!"></a>Finally, do not experience the wind and rain, how can the top of the computer mountain to see the rainbow!No matter how, I believe tomorrow will be better!!</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>励志</category>
      </categories>
      <tags>
        <tag>English</tag>
        <tag>鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title>Easy to mix knowledge points of C language</title>
    <url>/knowledge_C_language/</url>
    <content><![CDATA[<blockquote>
<p> 成都信息工程大学807程序设计基础易错知识点汇总</p>
</blockquote>
<a id="more"></a>

<h1 id="🌸易混知识点"><a href="#🌸易混知识点" class="headerlink" title="🌸易混知识点"></a>🌸易混知识点</h1><ol>
<li><p>关于new delete 与malloc free 的联系与区别描述？》</p>
<ul>
<li>用malloc函数需要指定内存分配的字节数并且不能初始化对象，new 会自动调用对象的构造函数</li>
<li>delete 会调用对象的destructor，而free 不会调用对象的destructor</li>
<li>都是在堆上取得内存。</li>
</ul>
</li>
<li><pre><code class="c++"><span class="keyword">char</span> *p1 = <span class="string">"123"</span>, *p2 = <span class="string">"ABC"</span>, str［<span class="number">50</span>］= <span class="string">"xyz"</span>;
<span class="built_in">strcpy</span>(str + <span class="number">2</span>, <span class="built_in">strcat</span>(p1, p2));
<span class="built_in">cout</span> &lt;&lt; str;
&lt;!--￼<span class="number">0</span>--&gt;
 <span class="keyword">char</span> str[<span class="number">20</span>]=<span class="string">"0123456789"</span>; <span class="keyword">int</span> a=<span class="built_in">strlen</span>(str); <span class="comment">//a=10; &gt;&gt;&gt; strlen 计算字符串的长度，以结束符 0x00 为字符串结束。 int b=sizeof(str); //而b=20; &gt;&gt;&gt; sizeof 计算的则是分配的数组 str[20] 所占的内存空间的大小，不受里面存储的内容改变。 上面是对静态数组处理的结果。</span>
 &lt;!--￼<span class="number">1</span>--&gt;</code></pre>
</li>
<li><p><font color="red">return 后面括号的值不一定是函数的值</font>，譬如函数返回值与return 类型不一致需要类型转换，返回值为 int ，retun 3.2 ，那么肯定会进行转换的</p>
</li>
<li><p>实型字面值常量有两种表示方式：小数形式和指数形式</p>
<pre><code>小数形式：由最前面的额正负号，数字0-9和小数点组成，不允许有其他符号；

指数形式；包括指数和尾数两个不可缺少的部分，用符号E(e)分割；E(e)左边是尾数，为十进制整数或小数形式的实数，右边为指数，必须为十进制整数，表示乘以10的多少次方</code></pre></li>
<li><p>BSS（Block Started by Symbol）通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。特点是:可读写的，在程序执行之前BSS段会自动清0。所以，未初始的全局变量在程序执行之前已经成0了。</p>
</li>
<li><p>A.单链表的每个节点都具有唯一的前驱节点和唯一的后继节点，所以当两个单链表存在相交的节点时，这两个链表则同时拥有这个节点，以及这个节点的所有后继节点，当这个公共节点是尾节点时，他们则只含有公共一个节点——-尾节点。</p>
<p>B.快慢指针是判断单链表是否有环的一种方法：两个指针，每次移动的步长为2叫做快指针，每次移动步长为1的指针叫做慢指针。快慢指针同时从头结点出发，当快指针率先到达NULL的时候，则说明此单链表中不存在环，当快指针追上慢指针的时候，说明此单链表中存在环。</p>
<p>C.<font color="red">有环的单向链表和无环的单向链表不能相交</font>，因为当相交的时候，无环的单向链表也会被迫存在一个环，只不过这个环的”起点“可能不是原来单向链表的头结点。</p>
<p>4.两个单向链表之间相交可以存在环。</p>
</li>
<li><p>存在这样的线性表：表中各结点都没有直接前趋和直接后继。–空表</p>
</li>
<li><p>%%d=%%和d</p>
<pre><code>%%在屏幕上显示为%

d还是d

所以是和k没有关系了~</code></pre></li>
<li><p>队列实现方式有链表存储和顺序表存储两种：链表存储可设计为带有尾指针的单链表，即可高效实现入队出队，无需循环链表；顺序表存储为解决存储空间浪费而设计为循环队列。 因此循环队列仅有顺序表存储结构，与循环链表毫无关系。</p>
</li>
<li><p>一个非空的数据结构如果满足以下两个条件：有且只有一个根结点；每一个结点最多有一个前件，也最多有一个后件，则称为线性结构，在数据结构中习惯称为线性表。双向链表结点具有两个指针域，属于线性结构， A 选项错误。循环链表所有结点的指针域都为非空，属于线性结构， B 选项错误。循环链表是链表，循环队列属于队列，队列只能在队尾入队，在排头退队，链表可以在任何位置插入、删除， C 选项错误。双向链表结点具有多个指针域， D 选项正确</p>
</li>
<li><p><font color="red">%X.Ys</font>的格式化输出，X是总长度，<font color="blue">Y是从字符串中从左边取Y位</font>，剩下的位数补空格</p>
</li>
<li><p>对于数据结构课程而言，简单地说，线性结构是n个数据元素的有序（次序）集合。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1．集合中必存在唯一的一个"第一个元素"；</span><br><span class="line"></span><br><span class="line">2．集合中必存在唯一的一个"最后的元素"；</span><br><span class="line"></span><br><span class="line">3．除最后元素之外，其它数据元素均有唯一的"后继"；</span><br><span class="line"></span><br><span class="line">4．除第一元素之外，其它数据元素均有唯一的"前驱"。</span><br><span class="line"></span><br><span class="line">数据结构中线性结构指的是数据元素之间存在着“一对一”的线性关系的数据结构。</span><br><span class="line"></span><br><span class="line">非线性结构：数学用语，其逻辑特征是一个结点元素可能有多个直接前趋和多个直接后继。</span><br><span class="line"></span><br><span class="line">A选项：在链表中，如果每个结点有两个指针域，则该链表一定是非线性结构，错，类似于传统的双链表，一个指向前一个结点，一个指向后一个结点，这种双链表还是一个线性结构。</span><br><span class="line"></span><br><span class="line">B选项：在链表中，如果有两个结点的同一个指针域的值相等，则该链表一定是非线性结构。对，如果有两个结点的同一个指针域的值，那么被指向的这个点，有两个前驱，违背了唯一的特点，所以必须是非线性结构。</span><br><span class="line"></span><br><span class="line">C选项：在链表中，如果每个结点有两个指针域，则该链表一定是线性结构，错。例如变种的双链表，一个指向后继结点，一个指向链表中的任意结点。如果指向同一结点的话，就类似B选项，所以这个选项是错的。</span><br><span class="line"></span><br><span class="line">D选项：在链表中，如果有两个结点的同一个指针域的值相等，则该链表一定是线性结构，错。一个普通的链表中，不同的结点值可以相等，但是这种链表是线性结果。所以这个选项是错的</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>广义表的长度： 若广义表不空，则广义表所包含的元素的个数，叫广义表的长度，数第一层括号内的逗号数目。</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">**广义表的深度： 广义表中括号的最大层数叫广义表的深度。**</span><br><span class="line"></span><br><span class="line">长度：最外层包含元素的个数，即去掉最外层括号后含有的元素个数。</span><br><span class="line"></span><br><span class="line">深度：表中含有括号数最多的括号层数加一。</span><br><span class="line"></span><br><span class="line">head :返回列表的第一个元素，（不带括号）</span><br><span class="line"></span><br><span class="line">tail：返回列表删除第一个元素后剩余的列表（带括号）</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>线性链表中的各元素在存储空间中的位置不一定是连续的，且各元素的存储顺序也是任意的</p>
</li>
<li><p><strong>顺序表中逻辑相邻物理位置必定相邻。单链表中逻辑相邻物理位置不一定相邻。</strong></p>
</li>
<li><p>结构体变量不管其包含有多少个成员，都应当看成是一个整体。在程序运行</p>
<p>   期间，只要在变量的生存期内，所有成员一直驻留在内存中，不可能出现有的成员驻留内 存，有的成员不驻留内存的情况</p>
</li>
<li><p>C 语言中用 <font color="orange">“%%” 打印输出字符 “%”</font>, 所以 %%d, 输出为 %d 两个普通字符 , 而不是格式控制符 “%d” 的含义</p>
</li>
<li><p>ava中只有byte, boolean是一个字节, char是两个字节, 所以对于java来说127不会发生溢出, 输出328</p>
<ul>
<li>但是对于c/c++语言来说, char是一个字节, 会发生溢出, 对127加一发生溢出, <code>0111 1111 --&gt; 1000 0000, 1000 0000</code>为补码-128, 所以结果为<code>200-128=72</code></li>
</ul>
</li>
<li><p>广义表是一个递归的定义，它的元素可以是 (1)单个元素 (2)子表</p>
<pre><code>一对确定的（表头，表尾）可以唯一确定一个广义表：

  1. 表头：广义表的第一个元素(广义) ，可能是一个元素(狭义)，也可能是一个子表(但它作为第一个元素(广义))

  2. 表尾：除表头外其余元素组成的子表，一定是一个表！

举一些特殊的例子：

表A = (e) ，则表头为e，表尾为() 

表B = ( ) ，即空表，长度=0
表C = (( ))，长度=1，表头为( )，表尾为( )   </code></pre></li>
<li><p>拆分二维数组</p>
<pre><code>int a[4][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };

拆分成：

int b[3] = {1, 2, 3 };

int c[3] = {4, 5, 6 };

int d[3] = {7, 8, 9 };

int e[3] = {10, 11, 12 };

\2. 为何拆分？

以“b[3] = {1, 2, 3 }”为例：b是数组第一个元素的地址，这里b相当于整型指针！上述b，c，d，e都是整型指针。

那么就有：a[4] = { b, c, d, e };

这是一个一维数组，其中的**元素都是整型指针**。a是什么？是数组a中第一个元素b的地址！

根据上述这种理解，发现可以很方便的解出这道题。

分析：AC选项先看“int ( * prt)[3]=a”,相当于：int b[3];int *prt = &amp;b;

即定义了一个指向“数组第一个元素的地址”的指针prt；而从1,2分析来看，a表示的正是b的地址。所以，这里等价于：prt = a。

我们看AC选项，先把ptr都换成a。

A：* (( * prt+1)[2])

*a 即a[0]，也就是b；

( b+1) 表示 元素2的地址，也就是a[0][1]的地址；

(b+1)[2] → *( (b+1) + 2 ) = *(b+3) = b[3]，越界了！其实就是c[0]，VS上验证过，输出也是4.

而答案提供的相当于*(b[3])，连数组元素都算不上！

*注：**下标和指针转化公式：***(a+n) = a[n]*

C：( * prt+1)+2( * a+1)+2 等价于(b+1) + 2 = b+3，是4的地址，也就是c[0]的地址；同样错误。不过可以验证*(( * prt+1)+2)，输出为4.

5. B选项分析：* ( * (p+5))

int *p = a[0]，相当于int *p = b，遇到p直接用b替换就行了！* (p+5)等价于b[5]，也就是c[2]，元素6，前面还多个*，所以这个错的也很明显。

6. D选项

**下标和指针转化公式：*****(a+n) = a[n]**，这个正反都可以使用，而且很好用。</code></pre></li>
<li><p>%% 可以输出 %</p>
</li>
<li><p>用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。</p>
</li>
<li><p>不同数据类型之间的差别在于数据的表示范围及精度上，一般情况下，数据的表示范围越大、精度越高，其类型也越“高级”。</p>
<ul>
<li><p>赋值运算中<font color="blue">如果左值精度比右值精度低，将会出现截断</font>，会导致精度丢失。</p>
</li>
<li><p>当函数调用时，所传实参与形参类型不一致时，也会把<font color="red">实参自动转换为形参类型</font>后再赋值（<font color="red">类型以形参为准</font>）</p>
</li>
</ul>
</li>
<li><p>C++</p>
<ol>
<li><p>char、short、int、long、bool 基本类型都可以用于switch语句。</p>
</li>
<li><p>float、double都不能用于switch语句。</p>
<ol start="3">
<li>enum类型，即枚举类型可以用于switch语句。</li>
<li>所有类型的对象都不能用于switch语句。</li>
<li>字符串也不能用于switch语句</li>
</ol>
</li>
</ol>
</li>
<li><p>C语言中的文件的存储方式有（可以<font color="green">顺序存取，也可随机存取</font>）</p>
</li>
<li><p>C语言是一种<font color="cyan">结构化</font>程序设计语言</p>
</li>
<li><p>空指针是一<strong>个特殊的指针值。</strong></p>
<ul>
<li>空指针是指可以确保没有指向任何一个对象的指针。通常使用宏定义NULL来表示空指针常量值。<font color="blue">NULL就代表系统的0地址单元</font></li>
<li><font color="blue">空指针确保它和任何非空指针进行比较都不会相等</font>，因此经常作为函数发生异常时的返回值使用。     </li>
</ul>
</li>
<li><p>在printf中的%作为转义符，两个%才相当于1个%</p>
</li>
<li><p>free掉一个指针后，指针的值是不会自动置为NULL的，当然其指向的内存已经被释放，可以重新分配给其他进行使用，此时该指针被称为<strong>野指针</strong>。</p>
<ul>
<li>对野指针进行操作，可能会破坏内存结构，因为并不知道当前指针指向的内容是什么，所以一般在free操作结束后，由程序猿将指针置为NULL。</li>
</ul>
</li>
<li><p>C语言的指针的数据类型声明的是<font color="red">指针实际指向内容的数据类型</font></p>
</li>
<li><p><font color="red">c = c^32</font> 大小写互换</p>
</li>
<li><p>当顺利执行了文件关闭操作时，<code>fclose</code>函数的<strong>返回值</strong>是：如果<font color="red">正常</font>关闭了文件，则函数返回值为<font color="red">0</font>；否则，返回值为非0</p>
</li>
<li><p>以下函数用法正确的个数是：</p>
<pre><code><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="built_in">array</span>[MAX_CHAR+<span class="number">1</span>],i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;= MAX_CHAR;i++){</span><br><span class="line">        <span class="built_in">array</span>[i] = i;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">char</span>*<span class="title">test2</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">char</span> p[] = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">char</span> *p = test2();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    str++;</span><br><span class="line">    *str = <span class="string">'0'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

&gt; 重点不在于CHAR_MAX的取值是多少，而是在于i的取值范围是多少。
&gt;
&gt; 一般char的取值范围是-128到127，而u char 则是0~255，所以i的取值范围是0~255.
&gt;
&gt; 所以当CHAR_MAX常量大于255时，执行i++后，i不能表示256以上的数字，所以导致无限循环。
&gt;
&gt; 第二个问题：
&gt;
&gt; 重点在于函数中p的身份，他是一个指针，还是数组名；
&gt;
&gt; 如果是指针p，则p指向存放字符串常量的地址，返回p则是返回字符串常量地址值，调用函数结束字符串常量不会消失（是常量）。所以返回常量的地址不会出错。
&gt;
&gt; 如果是数组p，则函数会将字符串常量的字符逐个复制到p数组里面，返回p则是返回数组p，但是调用函数结束后p被销毁，里面的元素不存在了。
&gt;
&gt; 例子中p是数组名，所以会出错，p所指的地址是随机值。
&gt;
&gt; 若是把char p[]="hello";改成char *p="hello";就可以了。
&gt;
&gt; 第三个问题：
&gt;
&gt; 重点在于str++;这实际的语句就是str=str+1;而str是数组名，数组名是常量，所以不能给常量赋值。（可以执行str+1，但是不能str=.）</code></pre></li>
<li><p>feesk中seek_end 的<strong>文件末尾指针</strong>在<font color="red">末尾最后一个字符后面</font>，而非最后一个字符</p>
</li>
<li><p>使用”w”写文件也可以使用fwrite </p>
</li>
<li><p>对于32位系统，定义 <code>int **a[3][4],</code> 则变量a占有的内存空间为</p>
<ul>
<li>此处定义的是指向指针的指针数组，对于32位系统，指针占内存空间4字节，因此总空间为3×4×4＝48。</li>
</ul>
</li>
</ol>
<p>​           用右左法则来看，首先往变量a的右边看，是【3】，再往左看，是<em>，所以它首先是一个指针数组，数组里存放3个指针，然后再往右看是【4】，再往左看，是int *，说明前面3个指针每个指针都指向一个数组，每个数组里存放4个int *类型的指针，所以3</em>4有12个二级指针，每个指针在32位系统占4个字节，所以48个字节<br>​<br>​           可以从简单到难进行理解，<code>int *a[3]</code>是一个指针数组数组中的每个元素就是一个指针，a的大小是<code>3*4 = 12；int *a[3][4]</code>是一个二维的指针数组，数组中的每一个元素是一个指针，a的大小是<code>3*4*4 = 48</code>；<code>int **a[3]</code>也是一个指针数组，只不过该数组的元素是一个二级指针，但是二级指针的本质还是指针，所以a的大小是<code>3*4 = 12</code>；<code>int **a[3][4]</code>是一个二维数组，数组中的每一个元素是一个二级指针，所以a的大小是<code>3*4*4</code> = 48，就这么简单，不需要去分析什么从左到右从右到左看，反而容易搞混;<br>​           因为[]的优先级是大于<em>号的优先级的，所以先从变量名a向右看是<code>a[3][4]</code>是一个二维数组，然后再将该二维数组看作一个整体向左看，int *</em>是一个二级指针，说明该二维数组是一个数据类型为二级指针的指针数组，这种理解方法就跟普通的指针数组理解方式一样，比如：int *a[3]<br>​           我们理解是先向右看是a[3]拥有三个元素的数组，再向左看，int *说明数组的元素类型是整形的指针类型，所以是一个指针数组<br>​          ```</p>
<ol start="92">
<li><p>%3o表示以八进制数形式输出，占3个空格的位置，右对齐，左边多余的位置补</p>
<p>  空格，但实际数据的宽度为4大于规定的宽度，所以此时按实际宽度输出，故第一个y的  输出为│4630│。%8o与%3o的差别就在于输出占8个空格的位置，所以左边要补4个空格， 故第二个y的输出也为│□□□□4630│.<font color="blue">%#8o与%8o的差别只是输出时必须输出八进制前导0</font>，所以第三个y的输出为│□□□04630│.<font color="blue">%08o</font>与%8o的差别只是输出时<font color="blue">左边多余的位置补0</font>，  所以第四个y的输出为│00004630│</p>
</li>
<li><p>2014对应的二进制为：0000 0000 000 0000 0000 0111 1101 1110</p>
<ul>
<li>而<code>x|（x+1）</code>的作用是对一个数中<font color="blue">二进制0的个数进行统计</font></li>
</ul>
</li>
<li><p>1、【编译】是把c源程序翻译成汇编代码：<code>.s</code>； </p>
<p>2、【汇编】是把汇编代码翻译成二进制目标代码：<code>.obj</code></p>
<p>3、【链接】是把多个二进制目标代码文件链接成一个可执行程序；因为一个工程某个文件调用了其他c文件的函数或变量 一个程序需要上面三个步骤才能由源程序变成可执行程序。</p>
</li>
<li><pre><code class="c">      <span class="keyword">union</span> s{
          <span class="keyword">int</span> i;
          <span class="keyword">char</span> c;
          <span class="keyword">float</span> a;
      }temp;
      temp.i = <span class="number">266</span>;
      <span class="built_in">printf</span>(<span class="string">"%d"</span>, temp.c);

      <span class="comment">//输出是10</span>
      因为<span class="number">266</span>&gt;<span class="number">256.</span>也因为temp一共占有四个字节，i和ch共用内存空间，但是ch 只占据最低的一个字节，即最低的<span class="number">8</span>位，所以输出c的值也是只能输出这一字节内存中的二进制数表示的数，如果赋值的i是<span class="number">100</span>,将会正常输出<span class="number">100</span>

&lt;!--￼<span class="number">5</span>--&gt;</code></pre>
</li>
<li><pre><code class="c">      <span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> fromwhere)</span></span>; 

      函数fseek将文件位置指针重定位到fromwhere（SEEK_SET文件头<span class="number">0</span>,SEEK_CUR文件当前位置<span class="number">1</span>,SEEK_END文件末尾<span class="number">2</span>）开始偏移offset个字节的位置；返回成功<span class="number">0</span>，失败<span class="number">-1</span>；

      <span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;

      返回文件位置指针当前位置相对于文件首的偏移字节数；
&lt;!--￼<span class="number">6</span>--&gt;
</code></pre>
</li>
</ol>
<p>对指针变量赋0值和不赋值是不同的。 指针变量未赋值时，值是随机的，是垃圾值，不能使用的，否则将造成意外错误。而指针变量赋0值后，则可以使用，只是它不指向具体的变量而已。</p>
<ol start="102">
<li><p>面试问题</p>
<p>无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。然而面试的时候经常碰见诸如<font color="orange">获取倒数第k个元素</font>，<font color="green">获取中间位置的元素</font>，<font color="cyan">判断链表是否存在环</font>，<font color="blue">判断环的长度</font>等和长度与位置有关的问题。这些问题都可以通过灵活运用双指针来解决。</p>
<blockquote>
<p> Tips：双指针并不是固定的公式，而是一种思维方式~</p>
</blockquote>
<p>  先来看”<font color="orange">倒数第k个元素的问题</font>“。设有两个指针 p 和 q，初始时均指向头结点。首先，先让 p 沿着 next 移动 k 次。此时，p 指向第 k+1个结点，q 指向头节点，两个指针的距离为 k 。然后，同时移动 p 和 q，直到 p 指向空，此时 q 即指向倒数第 k 个结点。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        ListNode *p = head, *q = head; <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">while</span>(k--) {   <span class="comment">//将 p指针移动 k 次</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>) {<span class="comment">//同时移动，直到 p == nullptr</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>  <font color="green">获取中间元素的问题</font>。设有两个指针 fast 和 slow，初始时指向头节点。每次移动时，fast向后走两次，slow向后走一次，直到 fast 无法向后走两次。这使得在每轮移动之后。fast 和 slow 的距离就会增加一。设链表有 n 个元素，那么最多移动 n/2 轮。当 n 为奇数时，slow 恰好指向中间结点，当 n 为 偶数时，slow 恰好指向中间两个结点的靠前一个(可以考虑下如何使其指向后一个结点呢？)。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">下述代码实现了 n 为偶数时慢指针指向靠后结点。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode *p = head, *q = head;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">nullptr</span> &amp;&amp; q-&gt;next != <span class="literal">nullptr</span>) {</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    } </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p> <font color="cyan"> 是否存在环的问题</font>。如果将尾结点的 next 指针指向其他任意一个结点，那么链表就存在了一个环。</p>
<p>  上一部分中，总结快慢指针的特性 —— 每轮移动之后两者的距离会加一。下面会继续用该特性解决环的问题。<br>  当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了追及问题。想象一下在操场跑步的场景，只要一直跑下去，快的总会追上慢的。当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。</p>
<p>  据上述表述得出，如果一个链表存在环，那么快慢指针必然会相遇。实现代码如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>{</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>) {</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast != <span class="literal">nullptr</span>) {</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>  最后一个问题，如果存在环，如何判断环的长度呢？方法是，<font color="blue">快慢指针相遇后继续移动，直到第二次相遇。两次相遇间的移动次数即为环的长度</font>。</p>
</li>
<li><p>由于链表中从高位到低位存放了数字的二进制表示，因此我们可以使用二进制转十进制的方法，在遍历一遍链表的同时得到数字的十进制值。</p>
<p>   以示例 1 中给出的二进制链表为例：</p>
<p>   <img src="C:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20221101205758024.png" alt="image-20221101205758024"></p>
<p>​     表示 n 是二进制整数。<br>   <img src="C:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20221101205804892.png" alt="image-20221101205804892"></p>
<p>   链表的第 1 个节点的值是 1，这个 1 是二进制的最高位，在十进制分解中，1 作为系数对应的 2^2^<br>的指数是 2，这是因为链表的长度为 3。我们是不是有必要一定要先知道链表的长度，才可以确定指数 2 呢？答案是不必要的。</p>
<ul>
<li><p>每读取链表的一个节点值，可以认为读到的节点值是当前二进制数的最低位；</p>
</li>
<li><p>当读到下一个节点值的时候，需要将已经读到的结果乘以 2，再将新读到的节点值当作当前二进制数的最低位；</p>
</li>
<li><p>如此进行下去，直到读到了链表的末尾。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDecimalValue</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) {</span><br><span class="line">            ans = ans * <span class="number">2</span> + cur-&gt;val;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     <span class="number">5</span>÷<span class="number">2</span>=<span class="number">2</span>余<span class="number">1</span> </span><br><span class="line">     <span class="number">2</span>÷<span class="number">2</span>=<span class="number">1</span>余<span class="number">0</span> </span><br><span class="line">     <span class="number">1</span>÷<span class="number">2</span>=<span class="number">0</span>余<span class="number">1</span>  </span><br><span class="line">      ===&gt; 得出二进制 <span class="number">101</span> .</span><br><span class="line">     反推回去 商 x 除数 + 余数 </span><br><span class="line">     =&gt; <span class="number">0</span> x <span class="number">2</span> + <span class="number">1</span> = <span class="number">1</span> </span><br><span class="line">     -&gt; <span class="number">1</span> x <span class="number">2</span> + <span class="number">0</span> = <span class="number">2</span></span><br><span class="line">     -&gt; <span class="number">2</span> x <span class="number">2</span> +<span class="number">1</span> = <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><p>C语言语法规定，字母e或E之前必须要有数字，且e或E后面的指数必须为整数。如e3、5e3.6、<font color="red">.e、e等都是非法</font>的指数形式。</p>
</li>
<li><p><img src="C:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20221103211215842.png" alt="image-20221103211215842"></p>
</li>
<li><p>在方法体中定义的局部变量在该方法被执行时创建：错</p>
<ul>
<li>不是局部变量再该方法被执行/调用时创建，而是<font color="red">应该为在该变量被声明并赋值时创建，可以理解为当代码执行到该 变量被赋值的代码是才被创建</font>。</li>
</ul>
</li>
<li><p>C语言的源程序加工包括三步：<strong>预处理、编译和链接。</strong></p>
<p>  其中源程序加工的编译阶段又可细分为：预处理，编译，汇编三个阶段。</p>
<p>  即C语言由源代码生成可执行程序的过程为：<strong>C源程序→编译预处理→编译→汇编程序→链接程序→可执行文件</strong>。</p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">①预处理：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、头文件的包含，<span class="meta">#<span class="meta-keyword">include</span>预处理指令。</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、define定义符号的替换</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  预处理指令</span></span><br><span class="line"></span><br><span class="line">注释删除</span><br><span class="line"></span><br><span class="line">②编译：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、把C语言代码翻译成汇编代码。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、语法分析</span><br><span class="line">     </span><br><span class="line"><span class="number">3</span>、词法分析</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、语义分析</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、符号汇总</span><br><span class="line"></span><br><span class="line">③汇编</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、把汇编指令翻译成二进制指令</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、形成符号表</span><br><span class="line"></span><br><span class="line">④链接</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、合并段表</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、符号表的合并和符号表的重定位</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>函数fscanf不能从标准输入流读取数据</strong>   –错</p>
</li>
<li><p><strong>程序员必须明确地用函数fopen打开标准输入流、标准输出流和标准错误流</strong>   –错</p>
</li>
<li><p><strong>程序必须明确地调用函数fclose关闭文件</strong> – 错</p>
</li>
<li><pre><code class="c"> <span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])
 {
     <span class="keyword">char</span> *p1 = <span class="string">"h</span>
<span class="string">        ello"</span>;
     <span class="keyword">char</span> *p2 = <span class="string">"world"</span>;
     <span class="keyword">char</span> *p3 = <span class="string">"a piece of cake"</span>;
     <span class="keyword">char</span> *str[] = { p1, p2, p3 };
     <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(*str[<span class="number">0</span>]) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="keyword">typeid</span>(str[<span class="number">0</span>]).name() &lt;&lt; <span class="string">" "</span> &lt;&lt; *(str[<span class="number">0</span>] + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//typeid是类型</span>
     <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(*&amp;str[<span class="number">0</span>]) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="keyword">typeid</span>(&amp;str[<span class="number">0</span>]).name() &lt;&lt; <span class="string">" "</span> &lt;&lt; *(&amp;str[<span class="number">0</span>] + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;
     <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(*str) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="keyword">typeid</span>(str).name() &lt;&lt; <span class="string">" "</span> &lt;&lt; *(str + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;
     <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(*&amp;str) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="keyword">typeid</span>(&amp;str).name() &lt;&lt; <span class="string">" "</span> &lt;&lt; *(&amp;str + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;
     <span class="keyword">return</span> <span class="number">0</span>;
 }
 运行结果：
 <span class="number">1</span> <span class="keyword">char</span> * e
 <span class="number">4</span> <span class="keyword">char</span> * * world
 <span class="number">4</span> <span class="keyword">char</span> * [<span class="number">3</span>] world
 <span class="number">12</span> <span class="keyword">char</span> * (*)[<span class="number">3</span>] <span class="number">00F</span>7F734
 能看懂这个你就知道了，这个地方+<span class="number">1</span>的时候都是说步长，步长就是说+<span class="number">1</span>前面的这个对象 所指向的 数据类型的长度，比如 &amp;str[<span class="number">0</span>]类型是<span class="keyword">char</span> * * 所指向的是<span class="keyword">char</span> * 长度是指针的长度（不同机器不同）
&lt;!--￼<span class="number">12</span>--&gt;

如果要输出剩余字符串，可用

</code></pre>
</li>
</ol>
<pre><code><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, ``<span class="string">"%s\n"</span>``, s);</span><br></pre></td></tr></tbody></table></figure></code></pre><ol start="127">
<li><p>● itoa()：将整型值转换为<a href="https://so.csdn.net/so/search?q=字符串&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">字符串</a>。<br>● ltoa()：将长整型值转换为字符串。<br>● ultoa()：将无符号长整型值转换为字符串。<br>● gcvt()：将浮点型数转换为字符串，取四舍五入。<br>● ecvt()：将双精度浮点型值转换为字符串，转换结果中不包含十进制小数点。<br>● fcvt()：指定位数为转换精度，其余同ecvt()。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">itoa()函数有<span class="number">3</span>个参数：第一个参数是要转换的数字，第二个参数是要写入转换结果的目标字符串，第三个参数是转移数字时所用 的基数。在上例中，转换基数为<span class="number">10</span>。<span class="number">10</span>：十进制；<span class="number">2</span>：二进制...</span><br><span class="line"></span><br><span class="line">itoa并不是一个标准的C函数，它是Windows特有的，如果要写跨平台的程序，请用<span class="built_in">sprintf</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">25</span>];</span><br><span class="line">itoa(num, str, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The number 'num' is %d and the string 'str' is %s. \n"</span> ,</span><br><span class="line">num, str);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span> <span class="params">(<span class="keyword">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i,n,sign;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;<span class="built_in">isspace</span>(s[i]);i++)<span class="comment">//跳过空白符;</span></span><br><span class="line">sign=(s[i]==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">if(s[i]=='+'||s[i]==' -')//跳过符号</span><br><span class="line">  i++;</span><br><span class="line"><span class="keyword">for</span>(n=<span class="number">0</span>;<span class="built_in">isdigit</span>(s[i]);i++)</span><br><span class="line">       n=<span class="number">10</span>*n+(s[i]-<span class="string">'0'</span>);<span class="comment">//将数字字符转换成整形数字</span></span><br><span class="line"><span class="keyword">return</span> sign *n;</span><br></pre></td></tr></tbody></table></figure>

<p>● atof()：将字符串转换为双精度浮点型值。<br>● atoi()：将字符串转换为整型值。<br>● atol()：将字符串转换为长整型值。<br>● strtod()：将字符串转换为双精度浮点型值，并报告不能被转换的所有剩余数字。<br>● strtol()：将字符串转换为长整值，并报告不能被转换的所有剩余数字。<br>● strtoul()：将字符串转换为无符号长整型值，并报告不能被转换的所有剩余数字。</p>
</li>
<li><p>int f1(float);<br>int f2(char);<br>void f3(float);<br>int (*pf)(float);</p>
<p>函数指针变量：</p>
<p>函数指针变量的声明方法为：</p>
<p><strong>返回值类型 ( * 指针变量名) ([形参列表]);</strong><br>根据定义，</p>
<p><code>int(*pf)(float);
int (*p)(float)=&amp;f1;</code><br>pf,p都是函数指针变量。</p>
<p>函数地址 ：</p>
<p>在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。</p>
<p>函数地址的获取，可以是函数名，也可以在函数名前加取地址符&amp; 。</p>
<p>C错误是因为函数形参类型不匹配。</p>
<p>函数指针所指向的函数，返回值类型，形参列表必须完全匹配，对函数指针赋值可以采用以下方式<font color="red">pf＝&amp;p1或者pf＝p1 </font></p>
</li>
<li><p>按位运算是对字节或字中的实际位进行检测、设置或移位, 它<strong>只适用于字符型和整数型变量以及它们的变体, 对其它数据类型不适用</strong>。无论是float  还是double,在内存中的存储分为三部分：<strong>符号位，指数位，尾数位；</strong>位运算符对它们没有意义</p>
</li>
<li><p><font color="red">float类型的变量</font>赋值后为什么<font color="red">必须在值后加”f”/“F”</font><br><code>float x = 3.4F;</code><br>这里将“3.4”赋值给float类型的变量x，如果不加F，系统会默认把赋值的数字当作double类型处理 1，然后在把这个double类型的值赋给float类型，这样就会出现精度丢失。<br><code>float y = 3F;</code><br>这里将“3”赋值给float类型的变量y，如果将整数类型的“3”赋值给float，系统会自动将其转化为double类型1，然后再赋值给float类型，这样虽然会编译成功，但会导致精度缺失。<br>常量存储在常量缓冲区中，有且只有一份，常量缓冲区中的值默认空间大小，如果是整数，默认空间大小为32bit—-int，如果是小数，默认空间大小为64bit—-double。 </p>
</li>
<li><p>%f用于输入float,%lf用于输入double,%le用于科学计数法输入double型变量</p>
</li>
<li><p>形参与实参的之间的传递分类</p>
</li>
<li><p>1、<strong>按值传递（实形无联系）</strong></p>
<p>按值传递就是平常编程中经常用到的，定义一个基本数据类型的变量，在调用某函数时把该变量作为函数的实参传递给函数。这种传递方式采用的是单向值传递，实形无联系，形参改变不影响实参。</p>
<p>2、<strong>按地址传递（通过操作形参可能会改变实参）</strong></p>
<p>按地址传递主要出现在函数参数是指针变量、数组等的时候。</p>
<p>注意：</p>
<p>实质上用指针做函数参数的情况下，在调用函数时，将实参变量的传递给形参变量，采取的依然是单向值传递。如果<font color="blue">在被调函数中只是单纯改变了形参指针变量的值</font>，在函数调用结束后这些形参被销毁，是<font color="blue">不会影响调用函数时传入实参指针变量值</font>。</p>
<p><font color="red">只有当你在被调函数中通过操作形参指针变量，去改变了指针指向变量的值时，才可以改变实参指针变量所指向变量的值</font>。也只有这种情况下形参改变才可能影响实参。</p>
</li>
<li><p>假设函数原型和变量说明如下： </p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">void f3(int(*p)[4]);``int a[4]={1，2，3，4}，``int b[3][4]={{1，2，3，4}，{5，6，7，8}，{9，10，11，12}};</span><br></pre></td></tr></tbody></table></figure>

<p>  下面调用非法的是</p>
<ul>
<li><pre><code>f3(&amp;a);
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
f3(b[1]);
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
f3(&amp;b[1]);
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
f3(b);

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">       &gt; 选**B**。根据题目结合选项来看考察的是对函数的传参调用，其中参数涉及到**数组指针** 。 </span><br><span class="line">       &gt;</span><br><span class="line">       &gt; void f3(**int(\*p)[4]**);  其参数是**数组指针** ，指向数组p的指针。</span><br><span class="line">       &gt;</span><br><span class="line">       &gt;</span><br><span class="line">       &gt; - ​    选项A：f3(**&amp;a**); 参数为一个地址，符合指针定义。   </span><br><span class="line">       &gt; - ​    选项B：f3(**b[1]**); 参数为一个数组的具体元素，不符合指针定义。**所以B是非法的调用。**   </span><br><span class="line">       &gt; - ​    选项C：f3(**&amp;b[1]**); 参数为一个数组元素的地址，符合指针定义。   </span><br><span class="line">       &gt; - ​    选项D：f3(**b**); 参数为数组名，表示该数组的首地址，符合指针定义。</span><br><span class="line">       &gt;</span><br><span class="line">       &gt; &lt;font color='red'&gt;`b[1]`和`&amp;b[1]`虽然值相等，但是含义不一样，`&amp;b[1]`是行指针，类型是`int (*)[4]`，和`a`的类型相同；而`b[1]`是个`int *`，和`&amp;b[1][0]`等价。&lt;/font&gt;</span><br><span class="line">       &gt;</span><br><span class="line">       &gt; - b[1]作为第二行数组的数组名，如果单独出现，则表示首元素的地址，即元素b[1][0]的地址，类型是int*；如果加取地址&amp;，变成&amp;b[1]，那么就是整个第二行数组的地址，和函数f(3)要求的形参保持一致，即该指针指向一个整型数组，数组共4个整型元素。并不是所谓的指针的&lt;font color='red'&gt;指针。&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">135. C语言中，&lt;font color='red'&gt;未经赋值&lt;/font&gt;的&lt;font color='red'&gt;全局变量&lt;/font&gt;默认初始化为&lt;font color='red'&gt;0&lt;/font&gt;，**auto类型、register类型不确定**</span><br><span class="line"></span><br><span class="line">136. 所有的&lt;font color='red'&gt;静态局部变量&lt;/font&gt;，即定义在函数内部的`static int name`形式的，默认初始化为&lt;font color='red'&gt;0&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">137. 外部变量可以供其所在的程序文件中的任何函数使用   --- 错误</span><br><span class="line"></span><br><span class="line">     - 全局变量也称为外部变量，它是在函数外部定义的变量，其作用域是从定义该变量的位置开始至源文件结束。全局变量不受作用域的影响（也就是说，全局变量的生命期一直到程序的结束）。 </span><br><span class="line">       -    如果在一个文件中使用extern关键字来声明另一个文件中存在的全局变量，那么这个文件可以使用这个数据。    </span><br><span class="line">       -    在全局变量前加一个static，使该变量只在这个源文件中可用，称之为全局静态变量。</span><br><span class="line"></span><br><span class="line">138. 指针就是地址，因此一个变量的指针就是该变量的地址。请问这句话的说法是正确的吗？   &lt;font color='red'&gt;错误&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">     - &lt;font color='blue'&gt;一个变量的指针指向的内容才是这个变量的地址&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">139. - 若已包含标准库头文件及相关命名空间，用户也可以重新定义标准库函数，但是该函数将失去原有含义  -- &lt;font color='red'&gt;错误&lt;/font&gt;</span><br><span class="line">     - 若已包含标准库头文件及相关命名空间，则系统不允许用户重新定义标准库函数      --&lt;font color='red'&gt;正确&lt;/font&gt;</span><br><span class="line">     - 用户调用标准库函数前，不必使用预编译命令将该函数所在文件包括到用户源文件中     &lt;font color='blue'&gt;错误&lt;/font&gt;</span><br><span class="line">     - 用户调用标准库函数前，必须重新定义    --&lt;font color='blue'&gt;错误&lt;/font&gt;</span><br><span class="line">       - A选项，函数不能重新定义，只能重载，除非换作用域（那也不能叫重新定义）； B选项，&lt;font color='red'&gt;函数可以被重载而不能重新定义&lt;/font&gt;，重载后函数具有不同的形参，原有定义并不失效； C选项，正确； D选项，调用库函数果断需要#include（预处理包含）头文件啊……否则找不到函数定义</span><br><span class="line"></span><br><span class="line">140. 在 while 循环中以 EOF（&lt;font color='red'&gt;-1&lt;/font&gt;） 作为文件结束标志，这种以 EOF 作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的 ASCII 代码值的形式存放。我们知道， ASCII 代码值的范围是 0~255 ，不可能出现 -1 ，因此可以用 EOF 作为文件结束标志</span><br><span class="line"></span><br><span class="line">141. A 选项正确，`int a[10]={0, 0, 0, 0, 0}`; 前 5 个元素为 0，后面 5 个元素编译器补为 0</span><br><span class="line">     B 选项正确，&lt;font color='red'&gt;int a[10]={ }&lt;/font&gt;; 编译器&lt;font color='green'&gt;自动将所有元素置零&lt;/font&gt;</span><br><span class="line">     C 选项正确，`int a[] = {0}`; 编译器自动计算元素个数</span><br><span class="line">     D 选项错误，`int a[10] = {10*a}`;a 是整型数组，10*a 操作非法</span><br><span class="line"></span><br><span class="line">142. 排序方法    平均情况    最好情况    最坏情况    辅助空间    稳定性 </span><br><span class="line"></span><br><span class="line">       冒泡排序     O(n^2)      O(n)       O(n^2)        O(1)        稳定 </span><br><span class="line"></span><br><span class="line">       选择排序     O(n^2)     O(n^2)      O(n^2)        O(1)        不稳定 </span><br><span class="line"></span><br><span class="line">       插入排序     O(n^2)      O(n)       O(n^2)        O(1)        稳定 </span><br><span class="line"></span><br><span class="line">       希尔排序O(n*log(n))~O(n^2) O(n^1.3)    O(n^2)        O(1)       不稳定 </span><br><span class="line"></span><br><span class="line">       堆排序     O(n*log(n))   O(n*log(n))   O(n*log(n))      O(1)       不稳定 </span><br><span class="line"></span><br><span class="line">       归并排序    O(n*log(n))   O(n*log(n))   O(n*log(n))    O(n)          稳定 </span><br><span class="line"></span><br><span class="line">       快速排序    O(n*log(n))   O(n*log(n))    O(n^2)         O(1)       不稳定 </span><br><span class="line"></span><br><span class="line">       冒泡排序经过优化以后，最好时间复杂度可以达到O(n)。设置一个标志位，如果有一趟比较中没有发生任何交换，可提前结束，因此在正序情况下，时间复杂度为O(n)。选择排序在最坏和最好情况下，都必须在剩余的序列中选择最小（大）的数，与已排好序的序列后一个位置元素做交换，依次最好和最坏时间复杂度均为O(n^2)。^</span><br><span class="line"></span><br><span class="line">     插入排序是在把已排好序的序列的后一个元素插入到前面已排好序(需要选择合适的位置)的序列中，在正序情况下时间复杂度为O(n)。堆是完全二叉树，因此树的深度一定是log(n)+1，最好和最坏时间复杂度均为O(n*log(n))。归并排序是将大数组分为两个小数组，依次递归，相当于二叉树，深度为log(n)+1，因此最好和最坏时间复杂度都是O(n*log(n))。快速排序在正序或逆序情况下，每次划分只得到比上一次划分少一个记录的子序列，用递归树画出来，是一棵斜树，此时需要n-1次递归，且第i次划分要经过n-i次关键字比较才能找到第i个记录，因此时间复杂度是\sum_{i=1}^{n-1}(n-i)=n(n-1)/2，即O(n^2)。</span><br><span class="line"></span><br><span class="line">143. 算法的5个基本特征：确定性、有穷性、输入、输出、&lt;font color='red'&gt;可行性&lt;/font&gt;。</span><br><span class="line"></span><br><span class="line">144. 顺序查找的平均时间是多少？——&lt;font color='red'&gt;N/2&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">     - 严格意义上确实 应该是(n+1)/2，因为目标数据可以在任意位置，分别查找1，2，3，4，.......，n次，一共为n*(n+1)/2，所以除以n，平均时间为(n+1)/2</span><br><span class="line"></span><br><span class="line">145. `void hello(int a,int b=7,char* pszC="*");`</span><br><span class="line"></span><br><span class="line">     - hello(5)</span><br><span class="line"></span><br><span class="line">     - hello(5,8)</span><br><span class="line"></span><br><span class="line">     - `hello(6,"#")`</span><br><span class="line"></span><br><span class="line">     - hello(0,0,"#")</span><br><span class="line"></span><br><span class="line">     - &lt;font color='red'&gt;参数从右向左匹配&lt;/font&gt;，C项 a没有匹配到，`&amp;quot`;相当于半个引号，`&amp;quot ;#"=“#”`如上面D选项</span><br><span class="line"></span><br><span class="line">       从左到右我们就说参数是  a   b   c     A，函数从右往左匹配。b,c有现有的就不给了，5给a  </span><br><span class="line"></span><br><span class="line">       B,  8给b,5给a</span><br><span class="line"></span><br><span class="line">        C,  那一坨给了c，6给了b,  没东西给a 。不能跳着给。6给a，b用先有的是不对的。</span><br><span class="line"></span><br><span class="line">        D，挨个给就行了。</span><br><span class="line"></span><br><span class="line">146. 声明一个指向含有10个元素的数组的指针，其中每个元素是一个函数指针，该函数的返回值是int，参数是int*，正确的是（）                                        </span><br><span class="line"></span><br><span class="line">     -</span><br></pre></td></tr></tbody></table></figure>
(int *p[10])(int*)
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
int [10]*p(int *)
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
int (*(*p)[10])(int *)
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
int ((int *)[10])*p
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">     - 先看未定义标识符p，p的左边是*，*p表示一个指针，跳出括号，由于[]的结合性大于*，所以*p指向一个大小为10的数组，即`(*p)[10]`。左边又有一个*号，修释数组的元素，*`(*p)[10]`表示`*p`指向一个大小为10的数组，且每个数组的元素为一个指针。跳出括号，根据右边`（int  *）`可以判断（*`(*p)[10]）`是一个函数指针，该函数的参数是`int*`,返回值是int。所以选C。</span><br><span class="line"></span><br><span class="line">147. C语言中的一个变量可以被定义为两个或多个不同的类型。请问这句话的说法是正确的吗？</span><br><span class="line"></span><br><span class="line">     - 如果不在一个函数体中，可以的；但是如果在一个函数体中，会出现调用混淆，不允许。</span><br><span class="line"></span><br><span class="line">       而且这是两个变量，只是变量名相同而已，被存在不同的内存单元中。</span><br><span class="line"></span><br><span class="line">     - 如果在同一个函数内，那肯定不行，重复的定义，如果一个是&lt;font color='red'&gt;全局&lt;/font&gt;一个是&lt;font color='red'&gt;局部&lt;/font&gt;那就可以，还有在两个不同的函数内，也是可以的</span><br><span class="line"></span><br><span class="line">148. 双循环链表中，任意一结点的后继指针均指向其逻辑后继。</span><br><span class="line"></span><br><span class="line">     - 逻辑后继:&lt;font color='green'&gt;指在存储时按照需要给定的逻辑顺序在其后的数据块&lt;/font&gt;。循环链表中**尾节点的逻辑后继**应该为&lt;font color='red'&gt;null&lt;/font&gt;而其**后继指针指向了头节点。**</span><br><span class="line"></span><br><span class="line">149. 递归先序遍历一个节点为n，深度为d的二叉树，需要栈空间的大小为_</span><br><span class="line"></span><br><span class="line">     - **因为二叉树并不一定是平衡的，也就是深度d！=logn，有可能d &gt; &gt; logn(远大于)，所以栈大小应该是O（d）**</span><br><span class="line"></span><br><span class="line">150. 缓存策略中基于 LRU 的淘汰策略，在缓存满时，会把最近进入缓存的数据先淘汰，以保持高的命中率</span><br><span class="line"></span><br><span class="line">     - 刚好说反了，LRU的过程如下（其实很好理解，访问的频率越高越不该丢弃）： </span><br><span class="line"></span><br><span class="line">       ​      1. 新数据插入到链表头部； </span><br><span class="line"></span><br><span class="line">       ​      2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部； </span><br><span class="line"></span><br><span class="line">             3. 当链表满的时候，将链表尾部的数据丢弃。</span><br><span class="line"></span><br><span class="line">151. 顺序表删除需要移动元素，而链表删除不需要移动元素</span><br><span class="line"></span><br><span class="line">152. &lt;font color='red'&gt;有环的单向链表跟无环的单向链表不可能相交&lt;/font&gt; -正确</span><br><span class="line"></span><br><span class="line">     - 有环的单向链表和无环的单向链表不能相交，因为当相交的时候，无环的单向链表也会被迫存在一个环，只不过这个环的”起点“可能不是原来单向链表的头结点</span><br><span class="line"></span><br><span class="line">153. 如果两个单向链表&lt;font color='red'&gt;相交&lt;/font&gt;，那这两个链表都一定不存在环 -错误</span><br><span class="line"></span><br><span class="line">     - 单向链表相交&lt;font color='red'&gt;可以存在环&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">     ![img](https://uploadfiles.nowcoder.com/images/20180717/4256577_1531815312082_BA893B14C7935C1B5F8296D83D999DDA)</span><br><span class="line"></span><br><span class="line">     - 意思就是&lt;font color='red'&gt;链表相交，要么都有环，要么都无环&lt;/font&gt;，不可能出现其他情况，出现其他情况就不是线性结构就不符合链表的定义</span><br><span class="line"></span><br><span class="line">154. 执行"int x=1;int y=~x;"语句后,y的值为？ ——-2</span><br><span class="line"></span><br><span class="line">     - 假设int占2个字节，那么1的二进制表示是 0000 0001 ，~表示按位取反，则 0000 0001变为 1111 1110，在计算机中整数用补码形式表示，正数的补码是它本身，负数的补码是原数值除符号位按位取反再加一，由补码求原数值也是按位取反再加一，那么 1111 1110 除符号位按位取反再加一变成 1000 0010，即 -2。</span><br><span class="line"></span><br><span class="line">155. 若函数的定义出现在主函数之前且仅被主函数使用，则可以不必再说明</span><br><span class="line"></span><br><span class="line">     - 正确（如果不是仅被主函数调用，就是错的）</span><br><span class="line"></span><br><span class="line">156. 若一个函数（非主函数）没有return语句，返回类型是void</span><br><span class="line"></span><br><span class="line">     - 错误（构造函数和析构函数都没有返回类型，也没有return语句）</span><br><span class="line"></span><br><span class="line">157. &lt;font color='red'&gt;++、--不算做赋值运算&lt;/font&gt;，只能说是一个表达式</span><br><span class="line"></span><br><span class="line">158. 有char a[10]=”abc”;，则strlen(a)的值为3，&lt;font color='red'&gt;strlen&lt;/font&gt;函数返回字符串的&lt;font color='blue'&gt;长度&lt;/font&gt;，不包括末尾的’\0，sizeof(a)才是10</span><br><span class="line"></span><br><span class="line">159. \#include命令的功能是（）</span><br><span class="line"></span><br><span class="line">     - 在&lt;font color='red'&gt;命令处&lt;/font&gt;插入一个文本文件（注意&lt;font color='red'&gt;不是&lt;/font&gt;在&lt;font color='blue'&gt;文件首部&lt;/font&gt;插入一个头文件）</span><br><span class="line"></span><br><span class="line">160. 当顺利执行了文件关闭操作时，&lt;font color='blue'&gt;fclose函数的返回值&lt;/font&gt;是（）</span><br><span class="line"></span><br><span class="line">     - 如果&lt;font color='red'&gt;正常关&lt;/font&gt;例了文件，则函数返回值为&lt;font color='red'&gt;0&lt;/font&gt;；否则，返回值为&lt;font color='red'&gt;非0&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">161. 定义类型并不会分配空间，只有在&lt;font color='blue'&gt;定义变量&lt;/font&gt;时才会分配内存空间</span><br><span class="line"></span><br><span class="line">162. `int  a[10];`</span><br><span class="line"></span><br><span class="line">     - 问下面不可以表示a[1]地址的是（）</span><br><span class="line"></span><br><span class="line">       - &amp;a[0] + 1</span><br><span class="line">       - &lt;font color='blue'&gt;a + sizeof(int)&nbsp;&nbsp;&lt;/font&gt;</span><br><span class="line">       - (int*)&amp;a + 1</span><br><span class="line">       - `(int*)((char*)&amp;a + sizeof(int))`</span><br><span class="line"></span><br><span class="line">     - a为数组的时候 </span><br><span class="line">       &lt;font color='red'&gt;&amp;a + 1&lt;/font&gt; 移动sizeof(数组)字节 </span><br><span class="line"></span><br><span class="line">        &lt;font color='red'&gt; a + 1 &lt;/font&gt;或者 &lt;font color='red'&gt;&amp;a[0] + 1&lt;/font&gt; 移动sizeof(int) ,即移动到&lt;font color='red'&gt;下一个数组元素 &lt;/font&gt;</span><br><span class="line"></span><br><span class="line">       B是指向a[4]</span><br><span class="line"></span><br><span class="line">       C将a变成了指针 int *类型，指针+1 都是移动sizeof(int) ，移动到下一个元素的 </span><br><span class="line"></span><br><span class="line">        D指针绕来绕去的，变成char* 后 +4 ，移动 4* (sizeof(char))，移动四个字节，然后又重新强转成了int*,依然指向下一个元素</span><br><span class="line"></span><br><span class="line">163. 已知ii，j都是整型变量，下列表达式中，与下标引用`X[ii][j]`不等效的是（）</span><br><span class="line"></span><br><span class="line">     - *（X[ii]+j）</span><br><span class="line"></span><br><span class="line">     - &lt;font color='red'&gt;*(X+ii)[j]&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">     - &lt;font color='red'&gt;*(X+ii+j)&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">     - *(*(X+ii)+j)</span><br><span class="line"></span><br><span class="line">       - &lt;font color='red'&gt;a[m]相当于*（a+m)&lt;/font&gt;就是说 [] 符号如果要去掉的话，相加，括号，再取地址。。。反过来也一样</span><br><span class="line"></span><br><span class="line">       - B应该也是错误的，由于&lt;font color='red'&gt;[]的优先级高于*&lt;/font&gt;,因此，相当于对地址`（X+ii）[j]`取值，如果B改为`（*（X+ii））[j]`就对了</span><br><span class="line">       - `a[i][j] =*(a[i]+j) = *(*(a+i)+j) =(*(a+i))[j]`</span><br><span class="line"></span><br><span class="line">164. print函数声明为void print(int a,char b='b',int c=1); 下面函数调用正确的是（）</span><br><span class="line"></span><br><span class="line">     - print('a');</span><br><span class="line"></span><br><span class="line">       print(5,8);</span><br><span class="line"></span><br><span class="line">       print(5,'#');</span><br><span class="line"></span><br><span class="line">       print(5,'#',2);</span><br><span class="line"></span><br><span class="line">     - C++在调用函数时，当实参和形参的数据类型不一致时，会发生数据类型转换！将低精度转换为高精度时，由编译器隐式完成；将高精度转换为低精度时，必须用强制类型转换运算符：static_cast&lt;&gt;()来转换才不会造成数据丢失。精度由低到高: char-&gt;int-&gt;double-&gt;long double。CD肯定对， A的话字符转为整数即为97, B 选项在将整数类型 8 复制给 char 时，会发生截断赋值。把整数的前3*8位去掉  直接后8位赋值给char </span><br><span class="line"></span><br><span class="line">165. fprintf函数只能以&lt;font color='red'&gt;字符串&lt;/font&gt;的形式写入到文件中</span><br><span class="line"></span><br><span class="line">166.</span><br></pre></td></tr></tbody></table></figure>
int` `s[4][5],(*ps)[5];
ps = s;
</code></pre></li>
</ul>
<p>ps是一指向二维数组s的指针，ps+1表示指向数组s第2行首地址的指针；<br><em>(ps+3)表示数组s第4行的首地址；</em>(ps+1)+3表示数组s第2行第4列元素的地址，</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">167. 浮点类型在内存中分布为：&lt;font color='blue'&gt;符号位+指数位（-127~128）+尾数部分 (有效数字 1&lt;= M &lt;2)&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">168. ```c</span><br><span class="line">     #include "stdio.h"</span><br><span class="line">     #include "string.h"</span><br><span class="line">     void fun(char *s){ </span><br><span class="line">         char t[7];</span><br><span class="line">         s=t;</span><br><span class="line">         strcpy(s, "example");</span><br><span class="line">     }</span><br><span class="line">     </span><br><span class="line">     int  main(){ </span><br><span class="line">         char *s;    </span><br><span class="line">         fun(s);    </span><br><span class="line">         printf("%s",s);</span><br><span class="line">         return 0;</span><br><span class="line">     }</span><br></pre></td></tr></tbody></table></figure>

<p>对于栈中内存如果没有初始化，则会出现“烫烫烫烫烫烫”。对于堆中内存如果没有初始化，则会出现“屯屯屯屯屯”</p>
<ul>
<li><p>需要解释的就是编译错误和运行错误，编译错误可以理解成编译器能检查出来的错误，运行错误理解成逻辑错误，需要用户自己纠错</p>
</li>
<li><p>1.main函数里的s没有初始化就在fun函数里使用s，编译器会报警告，运行时会报错（局部变量未初始化）。答案选D。 </p>
<p>2.就算s初始化了，在fun函数里，局部变量t的大小为7，而strcpy函数会复制example末尾的\0 </p>
<p>所以example+’\0’一共8个字节空间，会溢出，程序会崩溃。 </p>
<p>3.就算局部变量t的大小足够大，在fun函数运行结束后，局部变量t的内存空间会被释放掉，此时s成为野指针；返回main函数后，也不会输出example。</p>
</li>
</ul>
</li>
<li><p>定义二维数组时，若第一维不确定第二维确定，则数组必须初始化;初始化后数组中元素个数除以第二维大小<font color="red">，若能整除，则商即第一维大小，若不能整除，则商加上1得到第一维大小</font>;若第一二维全部确定，可以不初始化，默认元素全部为0;不允许第二维不定</p>
<ul>
<li>二维数组的真实含义是，它的第一维就是一组数据的起始地址，第二维就是某组数据中的某个值，a[][3]表达的意思就是二维数组a的每一维都是由3个元素组成的一维数组</li>
</ul>
</li>
<li><p>下面程序段的运行结果是 ( ) 。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *s = <span class="string">"abcde"</span>;</span><br><span class="line">s += <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, s);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>指针s保存的是字符串的首地址，s+=2后，指向了字符‘c’，格式化输出s就是字符‘c’的地址（十进制形式的地址，%p是十六进制的地址）</li>
</ul>
</li>
<li><p>下面代码的执行结果是（）</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> *p[] = {<span class="string">"TENCENT"</span>, <span class="string">"CAMPUS"</span>, <span class="string">"RECRUITING"</span>};</span><br><span class="line">    <span class="keyword">char</span> **pp[] = {p + <span class="number">2</span>, p + <span class="number">1</span>, p};</span><br><span class="line">    <span class="keyword">char</span> ***ppp = pp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s "</span>, **++ppp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, *++*++ppp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p><img src="https://uploadfiles.nowcoder.com/images/20180303/4129176_1520062230660_F3CCDD27D2000E3F9255A7E3E2C48800" alt="img"></p>
</li>
<li><p>从题干当中，我们可以画出这样的一个图，这样就比较直观的看出了p,pp,ppp都指向哪里了，关键是最后两个printf语句。<br>（1）printf(“%s”,**++ppp);即，ppp当前所指向的位置，再往下移一个位置，即pp的位置2，而pp的位置2指向的是p的位置2，p的位置2指向的是CAMPUS，所以先输出CAMPUS  </p>
<p>  （2）<code>printf(“%s”,*++*++ppp);</code>这个语句等价于 <code>printf(“%s”,*++（*++ppp)）;</code>所以我们首先看,++ppp，第一个printf语句中ppp已经指向了pp的位置2，所以再往下移一个，指向了pp的位置3，而（*++ppp）则代表pp位置3所指向的内容，即p的位置1（pp的位置3指向的是p的位置1），在此基础上前面再加上一个++，则代表指针p在位置1的基础上再往下移动，即指针p的位置2，而p的位置2所指向的内容是CAMPUS，所以第二行输出的也是CAMPUS。<br>所以正确答案是：CAMPUS CAMPUS</p>
</li>
</ul>
</li>
<li><p>scanf()函数是格式化输入函数，它从标准输入设备(键盘）读取输入的信息</p>
<ul>
<li>输入== 读取、打印到屏幕==写</li>
</ul>
</li>
<li><p>关于C语言中的float，下面哪种说法正确的是 （）</p>
<ul>
<li><font color="blue">x的二次方大于等于0,对于float变量x总成立</font><br>float 变量加法满足交换律<br>条件0.9f == 0.9 的值为真<br>条件9 == 0.9*10 的值为真</li>
<li>C/C++中浮点数由符号位、阶码和尾数构成，其二进制表示并不直接对应浮点数的大小，因此<strong>浮点数类型不能进行位运算</strong>，否则编译器报错；所以<strong>如果A选项正确，其指的应该是x的二次幂；而不是x与2进行逐位异或</strong>……</li>
<li>B不一定正确。<strong>虽然**</strong>浮点数标准<strong>**IEEE 754</strong>满足加法和乘法的交换律，不满足加法结合律，<strong>但是**</strong>C++标准不保证<strong>**IEEE 754标准的实现</strong>，于是C++编译器也不保证浮点数a+b的结果等于b+a</li>
<li>C、D错误。浮点数存在误差，直接比较大小往往不是预期的结果；通常引入一个比要求精度还要小几个数量级的实数epsilon来帮助比较大小。在我的机器上，精度取1e-8，0.9f == 0.9为假（0.9f是单精度浮点，精度比0.9低）：</li>
</ul>
</li>
<li><p>extern、register、static、auto分别是定义外部变量、寄存器变量、静态变量、自动变量<br> 其中，自动变量(<font color="red">auto</font>)和寄存器变量(<font color="red">register</font>)属于动态存储，<font color="red">调用时临时分配单元</font>；而静态变量(static)和外部变量(extern)属于静态存储，在整个程时都存在.</p>
<ul>
<li>故，以下只有在使用时才为该类型变量分配内存的存储类型的是（）<ul>
<li>auto和register</li>
</ul>
</li>
</ul>
</li>
<li><p>函数原型：指明函数的名字，返回的类型，有几个参数，这几个参数是什么类型，<strong>不需要函数体</strong>，也<strong><font color="red">不需要形式参数的名字</font></strong>，其中用分号作为原型的结束符。</p>
<p>例如：void fun( int );</p>
</li>
<li><p>C语言程序能够在不同的操作系统下运行，这说明C语言具有很好的</p>
<ul>
<li>移植性<ul>
<li>所谓移植性就是在某操作系统下编写的程序能够在其他操作系统下编译运行，而程序几乎不需要进行任何修改。所以选择B。</li>
</ul>
</li>
</ul>
</li>
<li><p>对于下面的代码，说法正确的是____</p>
<p>char* s1 = “Hello world”;<br>char s2[] = “Hello world”;<br>s1[2] = ‘E’;     // 1<br>s2[2] = ‘E’;     // 2<br>*(s1 + 2) = ‘E’;  // 3<br>*(s2 + 2) = ‘E’;  // 4</p>
<ul>
<li>“Hello World”在常量区，但s1存储在栈，并且可以做++运算，但*p不可更改，相当于const char *p</li>
<li><strong>指针指向字符串时，字符串是常量，存储在常量区，而指针存储在栈区，不能对其操作修改。</strong></li>
<li>而对于s2,”Hello world”存储在数组里，在栈区，是可以修改的</li>
</ul>
</li>
<li><p>strlen和str.length()都是求字符串的长度，但strlen( )的参数必须是char*，而 str.length( )是string类对象str调用的成员函数。</p>
</li>
<li><p>%3d：<font color="red">输出</font>时表示输出位数少于三位数时前面补0，<font color="red">多于三位数时按实际位数输出</font>。<font color="red">输入</font>时表示<font color="red">只输入三位数</font>，少于三位数以空格补齐。</p>
</li>
<li><p>二路归并排序的时间复杂度为（）。</p>
<ul>
<li>假设数据区域为[1:n]，归的过程，第一次将区间分为[1:n/2]和[n/2+1，n]，第二次将两个区间分为四个，总共会进行log2(n)次，总共分为了log2(n）层，每次分区间的时间复杂度为1，则总共归的过程时间复杂度为log2(n)，而并的过程会的归的过程分的区间进行排序，是两个有序数组合并的过程，每一层合并的时间复杂度为n，有log2(n)层，所以并的总共复杂度为nlog2(n)，而归并的复杂度为nlog2(n)+log2(n)，用大O表示法就是<font color="red">nlogn</font></li>
</ul>
</li>
<li><p>用邻接矩阵存储有n个结点(0,1,…,n)和e条边的有向图<img src="https://www.nowcoder.com/equation?tex=0%20%5Cle%20e%20%5Cle%20n(n%20-%201)" alt="img">)。在邻接矩阵中删除结点<img src="https://www.nowcoder.com/equation?tex=i(0%20%5Cle%20i%20%5Cle%20n)" alt="img">的时间复杂度是（）</p>
<ul>
<li><p>删除节点B时，在邻接矩阵中需要把指向B的边全部删除，B指向的边也全部删除。 </p>
<p>而邻接矩阵表示法由一个顶点表（一维数组），一个边集（邻接矩阵，二维数组）组成。由顶点表查找i，复杂度为O(1)，然后查找二维数组i行i列，置i行i列均为0（即删除i节点），复杂度为2*O（n）。 </p>
<p>结果为O(n)，选择 B。</p>
</li>
</ul>
</li>
<li><p><strong>回溯法</strong><br> 1）（求解目标）回溯法的求解目标是找出解空间中满足约束条件的一个解或所有解。<br> 2）（搜索方式：深度优先）回溯*<em>\</em>搜索整个解空间，当不满条件时，丢弃，继续搜索下一个儿子结点，如果所有儿子结点都不满足，向上回溯到它的父节点。</p>
<p>   <strong>分支限界法</strong><br> 1）（求解目标）分支限界法的目标一般是在满足约束条件的解中找出在某种意义下的最优解，也有找出满足约束条件的一个解。<br> 2）（搜索方式：广度优先）分支限界法以广度优先或以最小损耗优先的方式搜索解空间。</p>
<ul>
<li><p>回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。 </p>
<p>回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。</p>
</li>
</ul>
</li>
<li><p>共用体变量可以作结构体的成员<font color="blue">,结构体变量也可以作共用体的成员</font>。</p>
<ul>
<li>正确</li>
</ul>
</li>
<li><p><font color="blue">文件指针和位置指针都是随着文件的读写操作在不断改变</font></p>
<ul>
<li>错，文件指针位置不变</li>
</ul>
</li>
<li><p>任何表达式语句都是表达式加分号结尾</p>
<ul>
<li>正确</li>
</ul>
</li>
<li><p>数组名不能与其他变量名相同</p>
<ul>
<li>正确</li>
</ul>
</li>
<li><p>函数形参的<a href="https://so.csdn.net/so/search?q=存储单元&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">存储单元</a>是<font color="red">动态分配</font>的</p>
<ul>
<li>错误，函数的变量一般是栈区，只要退出函数，系统就会自动回收栈区，而动态分配分配时分配堆区，堆区只能手动回收（free函数）</li>
</ul>
</li>
<li><p>C语言 随机操作<font color="red">只</font>适用于文本文件</p>
<ul>
<li><font color="red">错误</font>，随机操作文本指的是用seek函数重新定位文件指针进行读写操作，访问数组中的元素也是随机的，知道下标就可以，所以说随机操作不只是针对于文件来讲。</li>
</ul>
</li>
<li><p>全局变量放在static静态区，不是在栈区；stack由编译器自动分配和释放,存放函数的参数值，局部变量</p>
</li>
<li><p><a href="http://www.cnblogs.com/perfy/archive/2012/09/06/2672946.html" target="_blank" rel="noopener">heap&amp;stack 区别</a></p>
<p>​    1.heap是堆，stack是栈。   </p>
<p>​        2.stack的空间由操作系统（不是编译器）自动静态分配和释放（进站和出栈可控）；heap的空间是手动申请和释放的，heap常用new关键字来动态分配（—“内存泄露”——                            Memory Leak                     ）。   </p>
<p>​    3.stack空间有限（经常有栈溢出，而不是堆溢出），heap的空间是很大的自由区。   </p>
<p>  在Java中， </p>
<p>  若只是声明一个对象，则先在栈内存中为其分配地址空间， </p>
<p>  若再new一下，实例化它，则在堆内存中为其分配地址。 </p>
<p>   4.举例：  </p>
<p>   数据类型 变量名；这样定义的东西在栈区。  </p>
<p>   如：Object a =null; 只在栈内存中分配空间  </p>
<p>   new 数据类型();或者malloc(长度);    这样定义的东西就在堆区  </p>
<p>   如：Object b =new Object();    则在堆内存中分配空间</p>
</li>
<li><p>若fp已正确定义并指向某个文件，当未遇到该文件结束标志时函数feof(fp)的值为0.</p>
<ul>
<li>此时并未到文件尾部，否则返回非0，因为<font color="red">有数据时返回0</font></li>
</ul>
</li>
<li><p>文件指针用于指向文件，文件<font color="red">只有被打开后</font>才有对应的文件指针。</p>
</li>
<li><p>如果函数定义出现在函数调用之前,可以不必加函数原型声明</p>
<ul>
<li>正确</li>
</ul>
</li>
<li><p>输入操作称为写操作,将输入流中的信息存到内存时,使用写函数。</p>
<ul>
<li><font color="red">输入</font>是指计算机将数据读取存入内存的过程，即这个过程是<font color="red">读入</font>过程，即读操作，使用读函数<ul>
<li>类比scanf，计算将用户输入的数据从缓冲区读取出来存入内存；printf，计算机将内存中的数据写到输出设备上即屏幕</li>
</ul>
</li>
</ul>
</li>
<li><p>函数返回值的类型是由在<font color="red">定义函数</font>时所指定的函数类型</p>
</li>
<li><p>指向数组的指针变量称为数组指针变量。</p>
<ul>
<li><p>一个数组是由<font color="red">连续</font>的一块内存单元组成的。</p>
</li>
<li><p><font color="red">数组名</font>就是这块连续内存单元的<font color="red">首地址</font>。</p>
</li>
<li><p>一个数组<font color="blue">也是由各个数组元素（下标变量）组成</font>的。</p>
</li>
<li><p>每个数组元素按其类型不同占用几个连续的内存单元。</p>
</li>
<li><p>一个指针变量<font color="blue">既可以指向一个数组，也可以指向一个数组元素。</font></p>
<p>一般形式：<br>类型说明符 *指针变量名。</p>
<p>有了指针可以用两种方法访问数组元素:<br>第一种方法为下标法。<br>第二种方法为指针法。</p>
</li>
</ul>
</li>
<li><p>指针变量可以存放指针(地址)、数值和字符</p>
<ul>
<li><font color="red">只能存储地址</font></li>
</ul>
</li>
<li><p>内存中每个存储单元都有一个唯一的地址</p>
<ul>
<li>正确</li>
</ul>
</li>
<li><pre><code class="c"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>
<span class="function"></span>{
    <span class="keyword">char</span> arr[<span class="number">2</span>][<span class="number">4</span>];
    <span class="built_in">strcpy</span> (arr[<span class="number">0</span>],<span class="string">"you"</span>);
    <span class="built_in">strcpy</span> (arr[<span class="number">1</span>],<span class="string">"me"</span>);
    arr[<span class="number">0</span>][<span class="number">3</span>]=<span class="string">'&amp;'</span>;
    <span class="built_in">printf</span>(<span class="string">"%s \n"</span>,arr);
    <span class="keyword">return</span> <span class="number">0</span>;
}
&lt;!--￼<span class="number">27</span>--&gt;

- ```C
  ioctl
  &lt;!--￼<span class="number">28</span>--&gt;

- ```C
  <span class="built_in">write</span>
  &lt;!--￼<span class="number">29</span>--&gt;</code></pre>
</li>
<li><p>malloc函数进行动态、静态内存分配是在什么阶段?</p>
<ul>
<li><p>程序占用三种类型的内存：静态内存、栈内存、堆内存；<br><strong>静态内存：</strong><br>用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量<br> <strong>栈内存：</strong> </p>
<p>  用来保存定义在函数内的非static对象。  </p>
<p> 分配在静态内存或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。  </p>
<p> <strong>堆内存：</strong>  </p>
<p>  在程序<strong>运行时</strong>分配。动态对象的生存周期由<strong>程序（用户）</strong>来控制。</p>
</li>
<li><p>装载阶段、执行阶段</p>
</li>
</ul>
</li>
<li><p>“-6.2e”的意思：</p>
<p><strong>6</strong> 表示输出的位宽，如果结果小于6位，则不足的部分以空格补充，如果超于6位则没影响； </p>
<p>  <strong>.2</strong> 保留两位小数 </p>
<p>  e 以指数形式输出，即10的n次幂，e+02即表示10^2 </p>
<p>  - 负号，表示左对齐还是右对齐，2.19e+02 占9位（代码执行测试得到，通过不断修改6的结果，直到改到10，才出现了%6.2e输出时，左侧添加空格占位）。所以 - 表示左对齐，结尾右侧补空格，而+情况是右对齐，即左侧开头补空格 </p>
<p>  所以对于218.82631输出结果应为2.19*10^2，转换成计算机的代码输出格式即2.19e+02</p>
</li>
<li><p>共用体：</p>
<ul>
<li>共用体变量的地址和它的各成员的地址都是同 一地址。</li>
<li><font color="red">不能对共用体变量名赋值。</font></li>
<li>不能企图引用变量 名来得到一个值。</li>
<li>不能<font color="red">在定义共用体变量时对它初始化。</font></li>
<li><font color="red">不能</font>用共用体变量名作为<font color="red">函数参数</font>。 </li>
<li><font color="green">不能用函数返回共用体变量</font></li>
<li>可以定义共用体数组，<font color="green">共用体成员可以是数组</font></li>
<li><font color="blue">共用体类型定义和结构体类型定义可以互相嵌套</font></li>
<li>任何时间<font color="blue">起作用的是最后一个成员</font>（且只能任意时间只有一个成员起作用）</li>
</ul>
</li>
<li><p>C 语言分隔符：逗号(变量和表达式之间)、分号(for语句内)、空白符(字符串之间)、冒号（case:)</p>
</li>
<li><p>变量的类型分为两种：储存和数据</p>
<ul>
<li><p>所有的数据都有两种类型，一种是数据类型，一种是存储类型。<br><strong>数据类型</strong>：如int，float等<br><strong>存储类型</strong>：四种存储类型的变量，自动变量（auto）、<a href="https://so.csdn.net/so/search?q=静态变量&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">静态变量</a>（static）、外部变量（extern）、以及寄存器变量（register）。</p>
</li>
<li><table>
<thead>
<tr>
<th>存储类别</th>
<th>存储期</th>
<th>作用域</th>
<th>声明方式</th>
</tr>
</thead>
<tbody><tr>
<td>auto</td>
<td>自动</td>
<td>块</td>
<td>块内</td>
</tr>
<tr>
<td>register</td>
<td>自动</td>
<td>块</td>
<td>块内,使用关键字register</td>
</tr>
<tr>
<td>static(局部)</td>
<td>静态</td>
<td>块</td>
<td>块内,使用关键字static</td>
</tr>
<tr>
<td>static(全局)</td>
<td>静态</td>
<td>文件内部</td>
<td>所有函数外,使用关键字static</td>
</tr>
<tr>
<td>extern</td>
<td>静态</td>
<td>文件外部</td>
<td>所有函数外</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>return后面括号里的表达式的值即是此函数的值。请问这句话的说法是正确的吗？</p>
<ul>
<li>错误</li>
<li>return 后面括号的值不一定是函数的值，譬如函数返回值与return 类型不一致需要类型转换，返回值为 int ，retun 3.2 ，那么肯定会进行转换的</li>
</ul>
</li>
<li><p><code>!(x + y) + z-1 &amp;&amp; y + z/2;</code></p>
<ul>
<li>表达式的值是</li>
<li><code>!(x + y) + z-1 &amp;&amp; y + z/2即为(( !(x + y) )+ z-1) &amp;&amp; (y + z/2)=(!7+5-1)&amp;&amp;(4+2)=(0+5-1)&amp;&amp;6=4&amp;&amp;6=1</code></li>
</ul>
</li>
<li><p>用C语言编写的代码程序（）</p>
<ul>
<li><pre><code>可立即执行
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
是一个源程序
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
经过编译即可执行
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
经过编译解释才能执行
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">     - 1、【&lt;font color='red'&gt;编译&lt;/font&gt;】是把c源程序翻译成汇编代码：*.s； 2、【&lt;font color='red'&gt;汇编&lt;/font&gt;】是把汇编代码翻译成二进制目标代码：*.obj； 3、【&lt;font color='red'&gt;链接&lt;/font&gt;】是把多个二进制目标代码文件链接成一个可执行程序；因为一个工程某个文件调用了其他c文件的函数或变量 一个程序需要上面三个步骤才能由源程序变成可执行程序。</span><br><span class="line"></span><br><span class="line">     - C语言写的代码程序&lt;font color='red'&gt;肯定是源程序&lt;/font&gt; 它&lt;font color='blue'&gt;不能立即执行，必须经过编译成可执行代码&lt;/font&gt;</span><br><span class="line">       如果这个源程序中不含有main函数，编译后的代码也是不可执行的 C语言不是解释执行的</span><br><span class="line"></span><br><span class="line">209. 在32位机上，下面C程序的输出结果是</span><br><span class="line"></span><br><span class="line">     ```C</span><br><span class="line">     struct MyStruct</span><br><span class="line">     {</span><br><span class="line">         int i;</span><br><span class="line">         char c;</span><br><span class="line">         struct InnerStruct</span><br><span class="line">         {</span><br><span class="line">             int i;</span><br><span class="line">             long l;</span><br><span class="line">             double d;</span><br><span class="line">             char c;</span><br><span class="line">         } innerStruct;</span><br><span class="line">     };</span><br><span class="line">     union MyUnion</span><br><span class="line">     {</span><br><span class="line">         int i;</span><br><span class="line">         char c;</span><br><span class="line">     };</span><br><span class="line">     int main()</span><br><span class="line">     {</span><br><span class="line">        printf("%d, %d", sizeof(MyStruct), sizeof(MyUnion));</span><br><span class="line">     }</span><br></pre></td></tr></tbody></table></figure></code></pre></li>
<li><p>做选择题就要有做选择题的方法，除了掌握基本的知识。 </p>
<p>对于struct来说，大小虽然要慢慢累加，但是最后必然为struct里最长类型的整数倍，即double为8字节，则肯定是8的整数倍，排除A,B（不用慢慢累加计算） </p>
<p>对于Union来说，就简单了，大小为最长类型的整数倍，即int为4字节，则为4，选C</p>
</li>
<li><p>结构体长度并不一定是double的长度8的整数倍，而是min(字节对齐长度,8)的倍数</p>
<p>如果默认编译器4字节对齐，这题就是28，如果是8字节，就是32 </p>
<p>设对齐字节数为n(n = 4或8，区别于32位或者64位操作系统),每个成员内存长度为Li, Max(Li)为最大的成员内存长度,字节对齐规则是: </p>
<p>\1.    结构体对象的起始地址能够被Max(Li)所整除; </p>
<p>\2.    结构体中每个成员相对于起始地址的偏移量,即对齐值应是min(n,Li)的倍数.若不满足对齐值的要求,编译器会在成员之间填充若干个字节; </p>
<p>\3.    结构体的总长度值应是min(n,Max(Li))的倍数,若不满足总长度值的要求,编译器在为最后一个成员分配空间后,会在其后填充若干个字节.</p>
</li>
</ul>
</li>
<li><p><strong>两指针变量相减所得之差是两个指针所指数组元素之间相差的元素个数</strong></p>
</li>
<li><p>fseek函数<font color="red">一般</font>用于二进制文件。注意也可用于文本文件</p>
</li>
<li><p>一个变量的数据类型被强制转换后,它将保持被强制转换后的数据类型</p>
<ul>
<li>错误</li>
</ul>
</li>
<li><p>使用printf函数打印一个double类型的数据，要求：输出为10进制，输出左对齐30个字符，4位精度。以下哪个选项是正确的？</p>
<ul>
<li><pre><code>%-30.4e
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
%4.30e
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
%-30.4f
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
%-4.30f
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">     - -： 左对齐</span><br><span class="line"></span><br><span class="line">       30： 最小字段宽度</span><br><span class="line"></span><br><span class="line">       .4： 精确度保留小数4位</span><br><span class="line"></span><br><span class="line">       f： double精度浮点数</span><br><span class="line"></span><br><span class="line">       e： 科学计数法</span><br><span class="line"></span><br><span class="line">     - printf中，&lt;font color='red'&gt;%f通杀单精度和双精度&lt;/font&gt;</span><br><span class="line">       在&lt;font color='red'&gt;scanf&lt;/font&gt;中，%f和%lf才&lt;font color='red'&gt;有区别&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">214. 下面关于C语言中sizeof(int)说法正确的是（）</span><br><span class="line"></span><br><span class="line">     - &lt;font color='red'&gt;编译时&lt;/font&gt;</span><br><span class="line">     - 运行时</span><br><span class="line"></span><br><span class="line">215. C语言中的一个变量可以被定义为两个或多个不同的类型。请问这句话的说法是正确的吗</span><br><span class="line"></span><br><span class="line">     - 如果同一个变量，分别作为全局变量和局部变量，根据局部优先原则，是可以定义为不同类型的。</span><br><span class="line"></span><br><span class="line">216. ```C</span><br><span class="line">     struct student {</span><br><span class="line">         int num, age;</span><br><span class="line">     };</span><br><span class="line">     struct student stu[3] = {{6001, 20}, {6003, 21}, {6005, 19}};</span><br><span class="line">     struct student *p = stu;</span><br></pre></td></tr></tbody></table></figure>
</code></pre></li>
</ul>
<p>则下面的C语言表达式中,值为6003的是（） 。</p>
<ul>
<li><p>对于A选项：++(p-&gt;num)。表示取数组第一个元素的值(6001)，然后+1； </p>
<p>对于B选项：(p++)-&gt;num。后缀自增运算符(++)与成员选择运算符(-&gt;)处于同一优先级，从左到右结合，但是指针偏移的操作直到表达式结束才会进行， </p>
<p>这个表达式相当于(p)-&gt;num;p=p+1; </p>
<p>对于C选项：<code>(*p++).num。</code>后缀自增运算符(++)优先级高于取值运算符(<em>)，但是++直到表达式结束才会进行，这个表达式相当于`(</em>p).num;p=p+1;` </p>
<p>对于D选项：<code>(*++P).num。</code>前缀自增运算符(++)优先级和取值运算符(<em>)一样，先执行p=p+1操作，相当于`(</em>(p+1)).num`;</p>
</li>
</ul>
</li>
<li><p>下列函数正确的是</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="built_in">array</span>[MAX_CHAR+<span class="number">1</span>],i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;= MAX_CHAR;i++){</span><br><span class="line">        <span class="built_in">array</span>[i] = i;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">char</span>*<span class="title">test2</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">char</span> p[] = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">char</span> *p = test2();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    str++;</span><br><span class="line">    *str = <span class="string">'0'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



</li>
</ol>
<pre><code>- 重点不在于CHAR_MAX的取值是多少，而是在于i的取值范围是多少。 一般char的取值范围是-128到127，而u char 则是0~255，所以i的取值范围是0~255. 所以当CHAR_MAX常量大于255时，执行i++后，i不能表示256以上的数字，所以导致无限循环。 第二个问题： 重点在于函数中p的身份，他是一个指针，还是数组名；  如果是指针p，则p指向存放字符串常量的地址，返回p则是返回字符串常量地址值，调用函数结束字符串常量不会消失（是常量）。所以返回常量的地址不会出错。 如果是数组p，则函数会将字符串常量的字符逐个复制到p数组里面，返回p则是返回数组p，但是调用函数结束后p被销毁，里面的元素不存在了。 例子中p是数组名，所以会出错，p所指的地址是随机值。 若是把char p[]="hello";改成char *p="hello";就可以了。第三个问题：  重点在于str++;这实际的语句就是str=str+1;而str是数组名，数组名是常量，所以不能给常量赋值。（可以执行str+1，但是不能str=.）</code></pre><ol start="218">
<li><p>输出正确的是：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> *a = <span class="string">"Trend"</span>;</span><br><span class="line">    <span class="keyword">char</span> **b = &amp;a;</span><br><span class="line">    *b = <span class="string">"commercial"</span>;</span><br><span class="line">    <span class="keyword">char</span> *c = ++a;</span><br><span class="line">    a = <span class="string">"talents."</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\n"</span>,*++c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>一开始a指向Trend，b指向指针a，后面commercial的内容赋给了指针b，然后就改变了指针a的内容，a就指向了commercial，指针c指向a所指的第二个字符，也就是o，虽然后面a又指向了talents，但是c已经指向了commercial，所以++c，c就指向了m，*++c就输出m字符</li>
</ul>
</li>
<li><p><font color="red">在C中使用malloc时不需要强制类型转换，因为在C中从void*到其他类型的指针是自动隐式转换的；</font> </p>
<p>  在C++中使用malloc时必须要强制类型转换，否则会报错，但在c++中一般用new而不用malloc；</p>
</li>
<li><p>int a[10]={ }; 编译器自动将所有元素置零</p>
</li>
<li><p>对于以下结构定义，(*p)-&gt;str++中的++加在（）</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> {</span> <span class="keyword">int</span> len; <span class="keyword">char</span> *str; } *p;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>p是指针，可以写p-&gt;str,但是<code>（*p）</code>只能写<code>(*p).str;</code></li>
</ul>
</li>
<li><p>结构体和共用体变量都不能进行比较操作，因为类型不一样，无法比较，除非强制转换或重载比较运算符</p>
</li>
<li><p>如果想在一个地方定义结构体，而在其他地方定义实际的结构体变量那么就必须使用标记名；如果定义结构体的同时就创建该结构体变量，则可以省略结构体的标记名，此时该结构体是一次性的、</p>
</li>
<li><p>typedef不是用来定义新的数据类型，而是创建易于记忆的类型名，给类型取别名</p>
</li>
<li><p>结构总是以传值的方式传递给函数</p>
</li>
<li><p>不管b_val为多少，while(b_val)等价于while(b_val！=0)，while(!b_val)等价于while(b_val==0)</p>
</li>
<li><p>在行尾放一个 \ ，编译器会忽略行尾的换行符，起到续行的作用。</p>
</li>
<li><p>include <code>&lt;file&gt;</code> //在标准库及默认搜索目录中寻找将要 include 的文件</p>
<p>include “file” //先在当前目录中搜索文件，然后再到默认搜索目录中搜寻。</p>
<ul>
<li>因此标准库头文件应该用&lt;&gt;更快</li>
</ul>
</li>
<li><p>%要求两边都是整数，如果你非要一个整数%另外一个非整数的可以用强制类型转换把它转换成整形</p>
<p>即使分母为0，编译器也不会编译出错，输出结果为inf,表示无穷大</p>
</li>
<li><p>所谓声明，就是告诉编译器变量的类型，编译器并不为其分配内存，此变量已经定义过，故声明可以多次进行。例如，声明外部变量 a。 </p>
<p>  extern int a; </p>
<p>   （1）定义创建了变量，并为其分配内存；声明没有分配内存。  </p>
<p>   （2）一个变量在一定的区域内只能被定义一次，却可以被多次声明。</p>
</li>
<li><p>若有以下的定义:<code>int t[3][2];</code></p>
<p>t[2] 能正确表示 t 数组某元素的地址 。表述是否正确？</p>
<ul>
<li>正确</li>
</ul>
</li>
<li><p>程序行、语句、函数都是由字符构成的，字符是C语言的最小单位，最小执行单元是函数。</p>
</li>
<li><p>以下定义错误的是：                                        </p>
<ul>
<li><pre><code>struct A{A  _a;};
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
struct A{A* _a;};
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
struct A{A&amp; _a;};
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
struct B;
struct A{B&amp; _b;};
struct B{A&amp; _a;};
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">答案：A </span><br><span class="line"></span><br><span class="line">  解释：struct成员类型不可以是它自己。</span><br></pre></td></tr></tbody></table></figure>
因为会递归定义。
理论上这样导致结构体的大小不能被计算（无限大小）。所以不能在结构体里的成员类型是结构体本身。
但是成员可以定义为该结构体的指针。就像你上面这段代码。因为指针的大小是已知的（随编译器和操作系统而定）。
所以可以定义为该结构体的指针，但不是该结构体。
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">234. 表头可以是原子或子表，表尾一定是子表</span><br><span class="line"></span><br><span class="line">235. 数组静态分配内存，链表动态分配内存；</span><br><span class="line">      数组在内存中连续，链表不连续；（对于数组，对象是放在堆内存中的，对象的引用是放在栈内存中的）</span><br><span class="line">      数组元素在栈区，链表元素在堆区；</span><br><span class="line">      数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；</span><br><span class="line">      数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。</span><br><span class="line"></span><br><span class="line">236. 一般情况下,算法中基本操作重复执行的次数是问题规模n的某个函数,用T(n)表示,若有某个辅助函数f(n),使得当n趋近于无穷大时,T（n)/f(n)的极限值为不等于零的常数,则称f(n)是T(n)的同数量级函数.记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度,简称时间复杂度.数学语言表达就是：存在足够大的正整数M，使得T（n）≤M×f（n）。</span><br><span class="line"></span><br><span class="line">237. 一个C源程序不是必须包含一个main()函数，而是必须包含一个**程序的入口函数**，**程序的入口函数不一定是main()函数**</span><br><span class="line"></span><br><span class="line">238. **1.default顾名思义是缺省情况，所有case条件不符合时才会执行；**</span><br><span class="line"></span><br><span class="line">     2.case语句若不加break，则当一条满足条件的case语句执行后，其下面的case语句都会执行。</span><br><span class="line"></span><br><span class="line">239. 必须在声明中对常量初始化，否则该常量值不确定且无法修改</span><br><span class="line"></span><br><span class="line">240. 注意本题的索引下标是从1开始 所以循环队列中最多有n个元素</span><br><span class="line">      在循环队列中,头指针指向队列当中的第一个元素,而尾指针指向最后一个元素的下一位</span><br><span class="line"></span><br><span class="line">     ​    假设循环队列的队尾指针是rear，队头是front，其中QueueSize为循环队列的最大长度。  </span><br><span class="line"></span><br><span class="line">        (1)    入队时队尾指针前进1：(rear+1)%QueueSize  </span><br><span class="line"></span><br><span class="line">        (2)    出队时队头指针前进1：(front+1)%QueueSize  </span><br><span class="line"></span><br><span class="line">        (3)    队列长度：(rear-front+QueueSize)%QueueSize  </span><br><span class="line"></span><br><span class="line">     ​    现有一循环队列，其队头指针为front，队尾指针为rear；循环队列长度为N。其队内有效长度为？(假设队头不存放数据)  </span><br><span class="line"></span><br><span class="line">     ​    答案：(rear-front+N)%N  </span><br><span class="line"></span><br><span class="line">        (4) 队空和队满的条件  </span><br><span class="line"></span><br><span class="line">     ​    为了区分队空还是堆满的情况，有多种处理方式：  </span><br><span class="line"></span><br><span class="line">        方式1：    牺牲一个单元来区分队空和队满，入队时少用一个队列单元，即约定以"队头指针在队尾指针的下一位置作为队满的标志"。  </span><br><span class="line"></span><br><span class="line">     ​    队满条件为：(rear+1)%QueueSize==front  </span><br><span class="line"></span><br><span class="line">     ​    队空条件为：front==rear  </span><br><span class="line"></span><br><span class="line">     ​    队列长度为：(rear-front++QueueSize)%QueueSize  </span><br><span class="line"></span><br><span class="line">        方式2：    增设表示队列元素个数的数据成员size，此时，队空和队满时都有front==rear。  </span><br><span class="line"></span><br><span class="line">     ​    队满条件为：size==QueueSize  </span><br><span class="line"></span><br><span class="line">     ​    队空条件为：size==0  </span><br><span class="line"></span><br><span class="line">        方式3：    增设tag数据成员以区分队满还是队空  </span><br><span class="line"></span><br><span class="line">     ​    tag表示0的情况下，若因删除导致front==rear，则队空；  </span><br><span class="line"></span><br><span class="line">     ​    tag等于1的情况，若因插入导致front==rear则队满</span><br><span class="line"></span><br><span class="line">241. 一个结构体指针变量虽然可以用来访问结构体变量或结构体数组元素的成员，但是，**结构体指针变量不能指向一个成员**。也就是说不允许取一个成员的地址来赋予它。</span><br><span class="line"></span><br><span class="line">     ```c</span><br><span class="line">     错误：</span><br><span class="line">     pdate = &amp;Date[1].year;		//错误的</span><br></pre></td></tr></tbody></table></figure></code></pre></li>
</ul>
</li>
<li><h2 id="链表练习"><a href="#链表练习" class="headerlink" title="链表练习"></a>链表练习</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>{</span></span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">char</span> sex[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">int</span> score[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">float</span> ave;</span><br><span class="line">}student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stuNode</span>{</span></span><br><span class="line">	student stu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stuNode</span> *<span class="title">next</span>;</span></span><br><span class="line">}stuNode, *stuList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入一个学生信息</span></span><br><span class="line"><span class="function">student <span class="title">inputAStu</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//输入n 个学生信息， 返回学生数组 </span></span><br><span class="line"><span class="function">student* <span class="title">inputStu</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//输出学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStu</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//为学生数据进行按照平均分大小进行降序排序（分别使用冒泡排序、选择排序、插入排序、快速排序实现）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSortStu</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSortStu</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSortStu</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">patition</span><span class="params">(student *stu, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(student *stu,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"><span class="comment">//创建带有头结点的链表(头插法)</span></span><br><span class="line"><span class="function">stuList <span class="title">creat1</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//创建带有头结点的链表(尾插法)</span></span><br><span class="line"><span class="function">stuList <span class="title">creat1_2</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//创建不带头结点的链表 (相当于尾插法)(可以写头插法，但是没必要，简单来说就是创建带有头结点的链表【同上】，最后返回的是head-&gt;next)</span></span><br><span class="line"><span class="function">stuList <span class="title">creat2</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//统一使用使用不带头结点的遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(stuList head)</span></span>;</span><br><span class="line"><span class="comment">//为链表添加一个学生信息(按平均分有序插入(带头结点))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addStuNode</span><span class="params">(stuList *head, student stu)</span></span>;</span><br><span class="line"><span class="comment">//链表中删除姓名为delname的全部学生信息,删除成功返回1，否则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delStuNode</span><span class="params">(stuList *head, <span class="keyword">char</span> *delname)</span></span>;</span><br><span class="line"><span class="comment">//将链表中的学生信息逆置(带头结点)【头插法实现逆置】</span></span><br><span class="line"><span class="function">stuList <span class="title">reverseStuList</span><span class="params">(stuList head)</span></span>;</span><br><span class="line"><span class="comment">//将两个学生有序的链表合并，并保证合并后链表仍然有序(带头结点)</span></span><br><span class="line"><span class="function">stuList <span class="title">mergeList</span><span class="params">(stuList L1, stuList L2)</span></span>;</span><br><span class="line"><span class="comment">//链表中删除平均分最小的节点</span></span><br><span class="line"><span class="function">stuList <span class="title">delStuMinAve</span><span class="params">(stuList head)</span></span>;</span><br><span class="line"><span class="comment">//找到两个链表的公共学生信息（以姓名为基准）合并成一个新的链表</span></span><br><span class="line"><span class="function">stuList <span class="title">getCommonStu</span><span class="params">(stuList L1, stuList L2)</span></span>;</span><br><span class="line"><span class="comment">//判断两个学生学生链表是否相交</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judgeInterSect</span><span class="params">(stuList L1, stuList L2)</span></span>;</span><br><span class="line"><span class="comment">//判断学生链表是否存在环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judgeLoop</span><span class="params">(stuList head)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"please input students number: "</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	student *stu;</span><br><span class="line">	stu = inputStu(n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"----输出学生数组----\n"</span>);</span><br><span class="line">	printStu(stu, n);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"----输出排序后学生数组----\n"</span>);</span><br><span class="line">	<span class="comment">//bubbleSortStu(stu, n);</span></span><br><span class="line">	<span class="comment">//insertSortStu(stu, n);</span></span><br><span class="line">	<span class="comment">//selectSortStu(stu, n);</span></span><br><span class="line">	quickSort(stu, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	printStu(stu, n);</span><br><span class="line"></span><br><span class="line">	stuList head;</span><br><span class="line">	<span class="comment">//head = creat1(stu, n); //头结点头插法测试</span></span><br><span class="line">	head = creat1_2(stu, n); <span class="comment">//头结点尾插法测试</span></span><br><span class="line"><span class="comment">//	head = creat2(stu, n); //不带头结点尾插法测试</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"----输出学生链表----\n"</span>);</span><br><span class="line">	printList(head-&gt;next);</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	printf("----Input插入学生信息---");</span></span><br><span class="line"><span class="comment">//	student e = inputAStu();</span></span><br><span class="line"><span class="comment">//	addStuNode(&amp;head, e);</span></span><br><span class="line"><span class="comment">//	printf("----输出学生链表----\n");</span></span><br><span class="line"><span class="comment">//	printList(head);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	printf("\n----Input待删除学生姓名---\n");</span></span><br><span class="line"><span class="comment">//	char delname[10];</span></span><br><span class="line"><span class="comment">//	getchar();</span></span><br><span class="line"><span class="comment">//	gets(delname);</span></span><br><span class="line"><span class="comment">//	if(delStuNode(&amp;head, delname)){</span></span><br><span class="line"><span class="comment">//		printf("delete successful!\n");</span></span><br><span class="line"><span class="comment">//	}else{</span></span><br><span class="line"><span class="comment">//		printf("no find this student!\n");</span></span><br><span class="line"><span class="comment">//	}</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//	printf("----逆置学生链表----\n");</span></span><br><span class="line"><span class="comment">//	head = reverseStuList(head);</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	int n2;</span></span><br><span class="line"><span class="comment">//	printf("please input students number: ");</span></span><br><span class="line"><span class="comment">//	scanf("%d", &amp;n2);</span></span><br><span class="line"><span class="comment">//	student *stu2;</span></span><br><span class="line"><span class="comment">//	stu2 = inputStu(n2);</span></span><br><span class="line"><span class="comment">//	printf("----输出学生数组----\n");</span></span><br><span class="line"><span class="comment">//	printStu(stu2, n2);</span></span><br><span class="line"><span class="comment">//	printf("----输出排序后学生数组----\n");</span></span><br><span class="line"><span class="comment">//	quickSort(stu2, 0, n2 - 1);</span></span><br><span class="line"><span class="comment">//	printStu(stu2, n2);</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	stuList head2;</span></span><br><span class="line"><span class="comment">//	head2 = creat1_2(stu2, n2); //头结点尾插法测试</span></span><br><span class="line"><span class="comment">//	printf("----输出学生链表----\n");</span></span><br><span class="line"><span class="comment">//	printList(head2-&gt;next);</span></span><br><span class="line"><span class="comment">//	printf("----合并两个链表---\n");</span></span><br><span class="line"><span class="comment">//	stuList head3 =  mergeList(head, head2);</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	printf("----输出合并后学生链表----\n");</span></span><br><span class="line"><span class="comment">//	printList(head3-&gt;next);</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	printf("----删除平均分最小的节点---\n");</span></span><br><span class="line"><span class="comment">//	head = delStuMinAve(head);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	int n2;</span></span><br><span class="line"><span class="comment">//	printf("please input students number: ");</span></span><br><span class="line"><span class="comment">//	scanf("%d", &amp;n2);</span></span><br><span class="line"><span class="comment">//	student *stu2;</span></span><br><span class="line"><span class="comment">//	stu2 = inputStu(n2);</span></span><br><span class="line"><span class="comment">//	printf("----输出学生数组----\n");</span></span><br><span class="line"><span class="comment">//	printStu(stu2, n2);</span></span><br><span class="line"><span class="comment">//	printf("----输出排序后学生数组----\n");</span></span><br><span class="line"><span class="comment">//	quickSort(stu2, 0, n2 - 1);</span></span><br><span class="line"><span class="comment">//	printStu(stu2, n2);</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	stuList head2;</span></span><br><span class="line"><span class="comment">//	head2 = creat1_2(stu2, n2); //头结点尾插法测试</span></span><br><span class="line"><span class="comment">//	printf("----输出学生链表----\n");</span></span><br><span class="line"><span class="comment">//	printList(head2-&gt;next);</span></span><br><span class="line"><span class="comment">//	printf("----找到公共学生信息链表---\n");</span></span><br><span class="line"><span class="comment">//	stuList head3 =  getCommonStu(head, head2);</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"----输出删除的后学生链表----\n"</span>);</span><br><span class="line">	printList(head-&gt;next);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入一个学生信息</span></span><br><span class="line"><span class="function">student <span class="title">inputAStu</span><span class="params">()</span></span>{</span><br><span class="line">	student stu;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"该学生(依次输入学号、姓名、性别、三门课成绩 ）："</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%s%s"</span>, &amp;stu.num, stu.name, stu.sex);</span><br><span class="line">	<span class="keyword">int</span> j, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++){</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;stu.score[j]);</span><br><span class="line">		sum += stu.score[j];</span><br><span class="line">	}</span><br><span class="line">	stu.ave = (<span class="keyword">float</span>)sum / <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">return</span> stu;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输入n 个学生信息， 返回学生数组 </span></span><br><span class="line"><span class="function">student* <span class="title">inputStu</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	student *stu = (student *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(student) * n);</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Input n students:\n"</span>); </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"No.%d (依次输入学号、姓名、性别、三门课成绩 ）："</span>, ++count);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%s%s"</span>, &amp;stu[i].num, stu[i].name, stu[i].sex);</span><br><span class="line">		<span class="keyword">int</span> j, sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++){</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;stu[i].score[j]);</span><br><span class="line">			sum += stu[i].score[j];</span><br><span class="line">		}</span><br><span class="line">		stu[i].ave = (<span class="keyword">float</span>)sum / <span class="number">3</span>;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> stu; </span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStu</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"第%d个学生：%d  %s  %s  %d  %d  %d  %.2f\n"</span>,i + <span class="number">1</span>, stu[i].num, stu[i].name, stu[i].sex, stu[i].score[<span class="number">0</span>], stu[i].score[<span class="number">1</span>], stu[i].score[<span class="number">2</span>], stu[i].ave);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//为学生数据进行按照平均分大小进行降序排序（分别使用冒泡排序、选择排序、插入排序、快速排序实现）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSortStu</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	student temp;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++){</span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(j = n - <span class="number">1</span>; j &gt; i; j--){</span><br><span class="line">			<span class="keyword">if</span>(stu[j - <span class="number">1</span>].ave-stu[j].ave &lt; <span class="number">1e-6</span>){</span><br><span class="line">				temp = stu[j];</span><br><span class="line">				stu[j] = stu[j - <span class="number">1</span>];</span><br><span class="line">				stu[j - <span class="number">1</span>] = temp;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(flag == <span class="number">0</span>){<span class="comment">//此汤未发生交换则提前结束排序没因为已经有序</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSortStu</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	student temp;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++){</span><br><span class="line">		<span class="keyword">if</span>(stu[i - <span class="number">1</span>].ave-stu[i].ave &lt; <span class="number">1e-6</span>){</span><br><span class="line">			temp = stu[i];</span><br><span class="line">			<span class="keyword">for</span>(j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; stu[j].ave-temp.ave &lt; <span class="number">1e-6</span>; j--){</span><br><span class="line">				stu[j + <span class="number">1</span>] = stu[j];</span><br><span class="line">			}</span><br><span class="line">			stu[j + <span class="number">1</span>] = temp;	</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSortStu</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	student temp; </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++){</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">max</span> = i;</span><br><span class="line">		<span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; n; j++){</span><br><span class="line">			<span class="keyword">if</span>(stu[<span class="built_in">max</span>].ave-stu[j].ave &lt; <span class="number">1e-6</span>){</span><br><span class="line">				<span class="built_in">max</span> = j;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">max</span> != i){</span><br><span class="line">			temp = stu[i];</span><br><span class="line">			stu[i] = stu[<span class="built_in">max</span>];</span><br><span class="line">			stu[<span class="built_in">max</span>] = temp;</span><br><span class="line">		}</span><br><span class="line">	}	</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">patition</span><span class="params">(student *stu, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">	student pivot = stu[left];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(left &lt; right){</span><br><span class="line">		<span class="keyword">while</span>(left &lt; right &amp;&amp; stu[right].ave-pivot.ave &lt;= <span class="number">1e-6</span>) right--;</span><br><span class="line">		stu[left] = stu[right];</span><br><span class="line">		<span class="keyword">while</span>(left &lt; right &amp;&amp; stu[left].ave-pivot.ave &gt;= <span class="number">1e-6</span>) left++;</span><br><span class="line">		stu[right] = stu[left];</span><br><span class="line">	}</span><br><span class="line">	stu[left] = pivot;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(student *stu,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(left &lt; right){</span><br><span class="line">		<span class="keyword">int</span> pation = patition(stu, left, right);</span><br><span class="line">		quickSort(stu, left, pation - <span class="number">1</span>);</span><br><span class="line">		quickSort(stu, pation + <span class="number">1</span>, right);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//创建带有头结点的链表(头插法)</span></span><br><span class="line"><span class="function">stuList <span class="title">creat1</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	stuList head = (stuNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode));</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	stuList p;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">		p = (stuNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode));</span><br><span class="line">		p-&gt;stu = stu[i];</span><br><span class="line">		p-&gt;next = head-&gt;next;</span><br><span class="line">		head-&gt;next = p;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//创建带有头结点的链表(尾插法)</span></span><br><span class="line"><span class="function">stuList <span class="title">creat1_2</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	stuList head = (stuNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode));</span><br><span class="line">	stuList p, r = head;<span class="comment">//定义r为尾指针</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">		p = (stuNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode));</span><br><span class="line">		p-&gt;stu = stu[i];</span><br><span class="line">		r-&gt;next = p;</span><br><span class="line">		r = p;</span><br><span class="line">	}</span><br><span class="line">	r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建不带头结点的链表 (相当于尾插法)(可以写头插法，但是没必要，简单来说就是创建带有头结点的链表【同上】，最后返回的是head-&gt;next)</span></span><br><span class="line"><span class="function">stuList <span class="title">creat2</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	stuList head = (stuNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode));</span><br><span class="line">	stuList p, q;</span><br><span class="line">	head = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">		p = (stuNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode));</span><br><span class="line">		p-&gt;stu = stu[i];</span><br><span class="line">		<span class="keyword">if</span>(head == <span class="literal">NULL</span>){</span><br><span class="line">			head = p;</span><br><span class="line">			q = head;</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			q-&gt;next = p;</span><br><span class="line">			q = p;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一使用使用不带头结点的遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(stuList head)</span></span>{</span><br><span class="line">	stuList p = head;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>){</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"第%d个节点："</span>, ++i);</span><br><span class="line">		student stu = p-&gt;stu;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d  %s   %s  %d  %d  %d  %.2f\n"</span>, stu.num, stu.name, stu.sex, stu.score[<span class="number">0</span>], stu.score[<span class="number">1</span>], stu.score[<span class="number">2</span>], stu.ave);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//为链表添加一个学生信息(按平均分有序插入(带头结点))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addStuNode</span><span class="params">(stuList *head, student stu)</span></span>{</span><br><span class="line">	stuList p = *head, s = (stuList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode));</span><br><span class="line">	s-&gt;stu = stu;</span><br><span class="line">	s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>){</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;next-&gt;stu.ave - stu.ave &lt;= <span class="number">1e-6</span>){</span><br><span class="line">			s-&gt;next = p-&gt;next;</span><br><span class="line">			p-&gt;next = s;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(flag == <span class="number">0</span>){<span class="comment">//如果当前学生的成绩最小，即需要插入到链表末尾</span></span><br><span class="line">		p-&gt;next = s;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//链表中删除姓名为delname的全部学生信息,删除成功返回1，否则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delStuNode</span><span class="params">(stuList *head, <span class="keyword">char</span> *delname)</span></span>{</span><br><span class="line">	stuList p = *head, q;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>){</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strcmp</span>(p-&gt;next-&gt;stu.name, delname) == <span class="number">0</span>){</span><br><span class="line">			q = p-&gt;next;</span><br><span class="line">			p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">			q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">free</span>(q); </span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//将链表中的学生信息逆置(带头结点)【头插法实现逆置】</span></span><br><span class="line"><span class="function">stuList <span class="title">reverseStuList</span><span class="params">(stuList head)</span></span>{</span><br><span class="line">	stuList p = head-&gt;next, q;</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>){</span><br><span class="line">		q = p-&gt;next; <span class="comment">//q节点暂存p的后继</span></span><br><span class="line">		p-&gt;next = head-&gt;next; <span class="comment">//头插遍历</span></span><br><span class="line">		head-&gt;next = p;</span><br><span class="line">		p = q;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//将两个学生有序的链表合并，并保证合并后链表仍然有序(带头结点)</span></span><br><span class="line"><span class="function">stuList <span class="title">mergeList</span><span class="params">(stuList L1, stuList L2)</span></span>{</span><br><span class="line">	stuList head = (stuList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode)), p1 = L1-&gt;next, p2 = L2-&gt;next, r = head;</span><br><span class="line">	stuNode *s;</span><br><span class="line">	<span class="keyword">while</span>(p1 != <span class="literal">NULL</span> &amp;&amp; p2 != <span class="literal">NULL</span>){</span><br><span class="line">		s = (stuNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode));</span><br><span class="line">		<span class="keyword">if</span>(p1-&gt;stu.ave - p2-&gt;stu.ave &lt; <span class="number">1e-6</span>){<span class="comment">//归并思想 大的先插（尾插法）</span></span><br><span class="line">			s-&gt;stu = p2-&gt;stu;</span><br><span class="line">			r-&gt;next = s;</span><br><span class="line">			r = s;</span><br><span class="line">			p2 = p2-&gt;next;</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			s-&gt;stu = p1-&gt;stu;</span><br><span class="line">			r-&gt;next = s;</span><br><span class="line">			r = s;</span><br><span class="line">			p1 = p1-&gt;next;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(p1){</span><br><span class="line">		r-&gt;next = p1;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(p2){</span><br><span class="line">		r-&gt;next = p2;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//链表中删除平均分最小的节点</span></span><br><span class="line"><span class="function">stuList <span class="title">delStuMinAve</span><span class="params">(stuList head)</span></span>{</span><br><span class="line">	stuList L = head, p = head-&gt;next;</span><br><span class="line">	<span class="keyword">char</span> delname[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">float</span> <span class="built_in">min</span> = p-&gt;stu.ave;</span><br><span class="line">	<span class="built_in">strcpy</span>(delname, p-&gt;stu.name);</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>){</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;stu.ave - <span class="built_in">min</span> &lt; <span class="number">1e-6</span>){</span><br><span class="line">			<span class="built_in">min</span> = p-&gt;stu.ave;</span><br><span class="line">			<span class="built_in">strcpy</span>(delname, p-&gt;stu.name);</span><br><span class="line">		}</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//直接调用前面写好的接口</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, delname);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(delStuNode(&amp;L, delname)){</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"成功\n"</span>);</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"失败\n"</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//找到两个链表的公共学生信息（以姓名为基准）合并成一个新的链表</span></span><br><span class="line"><span class="function">stuList <span class="title">getCommonStu</span><span class="params">(stuList L1, stuList L2)</span></span>{</span><br><span class="line">	stuList head = (stuList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode)), p1 = L1-&gt;next, p2 = L2-&gt;next, r = head;</span><br><span class="line">	stuNode *s;</span><br><span class="line">	<span class="keyword">while</span>(p1 != <span class="literal">NULL</span>){</span><br><span class="line">		<span class="keyword">while</span>(p2 != <span class="literal">NULL</span>){</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(p1-&gt;stu.name, p2-&gt;stu.name) == <span class="number">0</span>){</span><br><span class="line">				s = (stuNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode));</span><br><span class="line">				s-&gt;stu = p1-&gt;stu;</span><br><span class="line">				r-&gt;next = s;</span><br><span class="line">				r = s;</span><br><span class="line">			}</span><br><span class="line">			p2 = p2-&gt;next;</span><br><span class="line">		}</span><br><span class="line">		p2 = L2-&gt;next;</span><br><span class="line">		p1 = p1-&gt;next;</span><br><span class="line">	}</span><br><span class="line">	r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//判断两个学生学生链表是否相交</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judgeInterSect</span><span class="params">(stuList L1, stuList L2)</span></span>{</span><br><span class="line">	stuList p1 = L1, p2 = L2;</span><br><span class="line">	<span class="keyword">while</span>(p1-&gt;next != <span class="literal">NULL</span>){</span><br><span class="line">		p1 = p1-&gt;next;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span>(p2-&gt;next != <span class="literal">NULL</span>){</span><br><span class="line">		p2 = p2-&gt;next;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//如果两个链表相交，那么他们的最后一个节点一定相同</span></span><br><span class="line">	<span class="keyword">return</span> p1 == p2;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//判断学生链表是否存在环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judgeLoop</span><span class="params">(stuList head)</span></span>{</span><br><span class="line">	stuList p1 = head-&gt;next, p2 = head-&gt;next;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断有环的问题，一般使用快慢指针，快指针一次走两步，慢指针一次走一步，那么最终</span></span><br><span class="line">	<span class="comment">//如果有环，那么快指针和慢指针一定会相遇，如果无环，快指针一定能先走到NULL节点，此时退出</span></span><br><span class="line">	<span class="keyword">while</span>(p2 != <span class="literal">NULL</span>){</span><br><span class="line">		p2 = p2-&gt;next;</span><br><span class="line">		<span class="keyword">if</span>(p2 != <span class="literal">NULL</span>){</span><br><span class="line">			p2 = p2-&gt;next;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(p1 == p2){</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			p1 = p1-&gt;next;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



</li>
</ol>
<ol start="243">
<li><h3 id="栈队列"><a href="#栈队列" class="headerlink" title="栈队列"></a>栈队列</h3><p>1、堆栈与队列的基本概念与操作</p>
<p>1）、堆栈的基本概念与操作</p>
<pre><code>堆栈：只能在表的一端进行操作的线性表，一般的操作就是插入和删除，允许操作的一端称为栈顶，栈顶元素由栈顶指针给出，没有元素时为空栈
后进先出，先进后出
插入（入栈，进栈）
删除（出栈，退栈）
判空
判满
检索当前栈顶元素
特殊性：1、操作时一般线性表的子集；2、插入和删除的位置受到限制</code></pre></li>
</ol>
<pre><code>​    
2)、队列的基本概念与操作

    队列：队列简称队，是一种只能由一端进行插入，另一端进行删除的线性表。进行插入的一端称为队尾，用rear表示，删除的一端称为队头，用front指针表示
    先进先出，后进后出
    插入（进队，入队）
    删除（出队，退队）
    判空
    检索当前队头元素
    创建空队
    特殊性：1、操作时一般线性表的子集；2、插入和删除的位置受到限制


​    
​    
2、堆栈与队列的顺序存储结构与链式存储结构的构造原理

1）、堆栈的顺序存储结构

    一维数组SCACK[0..n-1],定义一个整型变量给出栈顶元素，但是不同于数组，数组时静态结构，堆栈是动态结构

   溢出：上溢：栈满时进行插入操作 top = n-1；下溢：栈空时进行删除操作  top = -1
   定义：

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1000</span></span><br><span class="line"><span class="keyword">int</span> STACK[M];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">-1</span>;  <span class="comment">//初始的时候top为-1，表示栈空</span></span><br></pre></td></tr></tbody></table></figure>

2)、堆栈的链式存储结构

    用线性链表表示，栈顶指针为NULL是为空

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>{</span></span><br><span class="line">     <span class="keyword">int</span> data;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line">}STNode, *STLink;</span><br></pre></td></tr></tbody></table></figure>

3）、队列的顺序存储结构

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">一维数组QUEUE[<span class="number">0.</span>.n<span class="number">-1</span>],两个变量front和rear指出队头和队尾元素的位置。</span><br><span class="line">约定：rear指出实际队尾元素的位置</span><br><span class="line">      front指出队头元素的前一个位置</span><br><span class="line">      初始队列为空front = <span class="number">-1</span> ； rear = <span class="number">-1</span>； </span><br><span class="line">      判断队列为空的条件：front = rear；</span><br><span class="line">      </span><br><span class="line">#define M <span class="number">1000</span></span><br><span class="line"><span class="keyword">int</span> QUEUE[M];</span><br><span class="line"><span class="keyword">int</span> front, rear;</span><br></pre></td></tr></tbody></table></figure>

4）、队列的链式存储结构

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">用线性链表表示，rear指出队尾，front指出队头</span><br><span class="line">空队列 front = <span class="literal">NULL</span>；</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> struct node{ </span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line">}QNode, *QLink;</span><br></pre></td></tr></tbody></table></figure>


3、在不同存储结构上对堆栈和队列进行插入和删除操作的算法设计

1）、顺序存储结构上对堆栈进行操作</code></pre><p>​       </p>
<pre><code><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">初始化</span><br><span class="line">     </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> &amp;top)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">       top = <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">     </span><br><span class="line">  判空</span><br><span class="line">     </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Empty</span><span class="params">(<span class="keyword">int</span> top)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">       <span class="keyword">return</span> top == <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">     </span><br><span class="line">  判满</span><br><span class="line">     </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">FULL</span><span class="params">(<span class="keyword">int</span> top)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">       <span class="keyword">return</span> top == M<span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">     </span><br><span class="line">  插入（进栈）</span><br><span class="line">     </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> Stack[], <span class="keyword">int</span> &amp;top, <span class="keyword">int</span> element)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">       <span class="keyword">if</span>(FULL(top)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">else</span>{</span><br><span class="line">           Stack[++top] = element;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       }</span><br><span class="line">  }</span><br><span class="line">     </span><br><span class="line">  删除（出栈）</span><br><span class="line">  <span class="keyword">int</span> Pop(<span class="keyword">int</span> Stack[], <span class="keyword">int</span> &amp;top, <span class="keyword">int</span> element)</span><br><span class="line">  {</span><br><span class="line">       <span class="keyword">if</span>(Empty(top))</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">else</span>{</span><br><span class="line">           element = Stack[top--];</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

2）、链式存储上对堆栈进行操作

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">初始化</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(STLink &amp;top)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    top = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">判空</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Empty</span><span class="params">(STLink top)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> top == <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">插入（进栈）不用判满</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(STLink &amp;top, <span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    STLink p;</span><br><span class="line">    <span class="keyword">if</span>(!(p = (STLink)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STNode))))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        p-&gt;data = item;</span><br><span class="line">        p-&gt;link = top;</span><br><span class="line">        top = p;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">删除（出栈）</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(STLink &amp;top, <span class="keyword">int</span> &amp;item)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    STLink p;</span><br><span class="line">    <span class="keyword">if</span>(Empty(top))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        p = top;</span><br><span class="line">        item = p-&gt;data;</span><br><span class="line">        top = top-&gt;link;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


​    
3）、在顺序存储结构上对队列进行操作

    初始化

    void Init(int &amp;front, int &amp;rear)
    {
        front = -1;
        rear = -1;
    }

    判空

    int Empty(int front, int rear)
    {
        return rear == front;
    }

    插入 
    int ADDQ(int Queue[], int &amp;rear, int item)
    {
        if(rear == M-1)    //假溢出
            return 0;
        else{
            Queue[++rear] = item;
            return 1;
        }
    }

    删除 
    int DELQ(int Queue[], int &amp;front, int rear, int &amp;item)
    {
        if(Empty(front, rear))
            return 0;
        else{
            item = Queue[--front];
            return 1;
        }
    }

    循环队列：将队列想象成头尾相连的表，使得队头删除的元素的空间能够尽可能被利用

    算法1：删除之后将每个元素前移一位。
            缺点：浪费空间

    算法2：求余

    添加：

    int ADDQ(int Q[], int &amp;rear, int &amp;front, int item)
    {
        if((rear+1)%M == front)
            return 0;
        else{
            Q[++rear%M] = item;
            return 1;
        }
    }

    删除：

    int DELQ(int Q[], int &amp;front, int &amp;rear, int &amp;item)
    {
        if(front == rear)
            return 0;
        else{
            front = (front + 1)%M;
            item = Q[front];
            return 1;
        }
    }

4）、在链式存储结构上对队列进行操作

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">初始化</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(QLink front, QLink rear)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    front = <span class="literal">NULL</span>;</span><br><span class="line">    rear = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">判空</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Empty</span><span class="params">(QLink front)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> fron == <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">插入</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ADDQ</span><span class="params">(QLink &amp;front, QLink &amp;rear, <span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QLink p;</span><br><span class="line">    <span class="keyword">if</span>(!(p = (QLink)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode))))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        p-&gt;data = item;</span><br><span class="line">        p-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(front == <span class="literal">NULL</span>)</span><br><span class="line">            front = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rear-&gt;link = p;</span><br><span class="line">        </span><br><span class="line">        rear = p;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">删除 </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DELQ</span><span class="params">(QLink &amp;front, QLink &amp;rear, <span class="keyword">int</span> &amp;item)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QLink p;</span><br><span class="line">    <span class="keyword">if</span>(Empty(front, rear))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        p = front;</span><br><span class="line">        front = front-&gt;link;</span><br><span class="line">        item = p-&gt;data;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></code></pre><p>​     </p>
<ol start="244">
<li></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>考研</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>C</tag>
        <tag>考研</tag>
        <tag>807</tag>
      </tags>
  </entry>
  <entry>
    <title>servlet基础</title>
    <url>/Servlet_Basics/</url>
    <content><![CDATA[<blockquote>
<p> java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。</p>
</blockquote>
<a id="more"></a>

<h2 id="🌸Servlet-简介"><a href="#🌸Servlet-简介" class="headerlink" title="🌸Servlet 简介"></a>🌸Servlet 简介</h2><h3 id="🍁Servlet-是什么？"><a href="#🍁Servlet-是什么？" class="headerlink" title="🍁Servlet 是什么？"></a>🍁Servlet 是什么？</h3><p>java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</p>
<p>使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。</p>
<p>Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势：</p>
<ul>
<li>性能明显更好。</li>
<li>Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。</li>
<li>Servlet 是独立于平台的，因为它们是用 Java 编写的。</li>
<li>服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。</li>
<li>Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。</li>
</ul>
<h3 id="🍁Servlet-架构"><a href="#🍁Servlet-架构" class="headerlink" title="🍁Servlet 架构"></a>🍁Servlet 架构</h3><p><a href="https://imgchr.com/i/dX9zf1" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/31/dX9zf1.png" alt="dX9zf1.png"></a></p>
<h3 id="🍁Servlet在做什么"><a href="#🍁Servlet在做什么" class="headerlink" title="🍁Servlet在做什么"></a>🍁Servlet在做什么</h3><ul>
<li>读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。</li>
<li>读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。</li>
<li>处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。</li>
<li>发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。</li>
<li>发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。</li>
</ul>
<hr>
<h2 id="🌸Servlet-创建的三种方式"><a href="#🌸Servlet-创建的三种方式" class="headerlink" title="🌸Servlet 创建的三种方式"></a>🌸Servlet 创建的三种方式</h2><h3 id="🍁实现-Servlet-接口"><a href="#🍁实现-Servlet-接口" class="headerlink" title="🍁实现 Servlet 接口"></a>🍁实现 Servlet 接口</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//Servlet的生命周期:从Servlet被创建到Servlet被销毁的过程</span></span><br><span class="line"><span class="comment">//一次创建，到处服务</span></span><br><span class="line"><span class="comment">//一个Servlet只会有一个对象，服务所有的请求</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.实例化（使用构造方法创建对象）</span></span><br><span class="line"><span class="comment"> * 2.初始化  执行init方法</span></span><br><span class="line"><span class="comment"> * 3.服务     执行service方法</span></span><br><span class="line"><span class="comment"> * 4.销毁    执行destroy方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo1</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//public ServletDemo1(){}</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//生命周期方法:当Servlet第一次被创建对象时执行该方法,该方法在整个生命周期中只执行一次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig arg0)</span> <span class="keyword">throws</span> ServletException </span>{</span><br><span class="line">                System.out.println(<span class="string">"=======init========="</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生命周期方法:对客户端响应的方法,该方法会被执行多次，每次请求该servlet都会执行该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest arg0, ServletResponse arg1)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        System.out.println(<span class="string">"hehe"</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生命周期方法:当Servlet被销毁时执行该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"******destroy**********"</span>);</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//当停止tomcat时也就销毁的servlet。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="🍁继承-GenericServlet-类"><a href="#🍁继承-GenericServlet-类" class="headerlink" title="🍁继承 GenericServlet 类"></a>🍁继承 GenericServlet 类</h3><p>这种方法我们极少用</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo2</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest arg0, ServletResponse arg1)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        System.out.println(<span class="string">"heihei"</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="🍁继承-HttpServlet-方法"><a href="#🍁继承-HttpServlet-方法" class="headerlink" title="🍁继承 HttpServlet 方法"></a>🍁继承 HttpServlet 方法</h3><p><code>经常用</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo3</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        System.out.println(<span class="string">"haha"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        System.out.println(<span class="string">"ee"</span>);</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸HttpServlet、GenericServlet-和-Servlet-的关系"><a href="#🌸HttpServlet、GenericServlet-和-Servlet-的关系" class="headerlink" title="🌸HttpServlet、GenericServlet 和 Servlet 的关系"></a>🌸HttpServlet、GenericServlet 和 Servlet 的关系</h2><blockquote>
<p>对于一个 Servlet 类，我们日常最常用的方法是继承自 HttpServlet 类，提供了 Http 相关的方法，HttpServlet 扩展了 GenericServlet 类，而 GenericServlet 类又实现了 Servlet 类和 ServletConfig 类。</p>
</blockquote>
<h3 id="🍁Servlet"><a href="#🍁Servlet" class="headerlink" title="🍁Servlet"></a>🍁Servlet</h3><p>Servlet 类提供了五个方法，其中三个生命周期方法和两个普通方法，关于 Servlet 类的方法，不再赘述</p>
<h3 id="🍁GenericServlet"><a href="#🍁GenericServlet" class="headerlink" title="🍁GenericServlet"></a>🍁GenericServlet</h3><p><code>GenericServlet</code> 是一个抽象类，实现了 Servlet 接口，并且对其中的 <code>init()</code> 和 <code>destroy()</code> 和 <code>service()</code> 提供了默认实现。在 <code>GenericServlet</code> 中，主要完成了以下任务：</p>
<ul>
<li>将 init() 中的 ServletConfig 赋给一个类级变量，可以由 getServletConfig 获得；</li>
<li>为 Servlet 所有方法提供默认实现；</li>
<li>可以直接调用 ServletConfig 中的方法；</li>
</ul>
<p>基本的结构如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span>,<span class="title">ServletConfig</span></span>{</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//GenericServlet通过将ServletConfig赋给类级变量</span></span><br><span class="line">   <span class="keyword">private</span> trServletConfig servletConfig;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException </span>{</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.servletConfig=servletConfig;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*自定义init()的原因是：如果子类要初始化必须覆盖父类的init() 而使它无效 这样</span></span><br><span class="line"><span class="comment">       this.servletConfig=servletConfig不起作用 这样就会导致空指针异常 这样如果子类要初始化，</span></span><br><span class="line"><span class="comment">       可以直接覆盖不带参数的init()方法 */</span></span><br><span class="line">      <span class="keyword">this</span>.init();</span><br><span class="line">   }</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//自定义的init()方法，可以由子类覆盖  </span></span><br><span class="line">   <span class="comment">//init()不是生命周期方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">  </span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//实现service()空方法，并且声明为抽象方法，强制子类必须实现service()方法 </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request,ServletResponse response)</span> </span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> ServletException,java.io.IOException</span>{</span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//实现空的destroy方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>{ }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>如果继承这个类的话，我们必须重写 service() 方法来对处理请求。</strong></p>
<h3 id="🍁HttpServlet"><a href="#🍁HttpServlet" class="headerlink" title="🍁HttpServlet"></a>🍁HttpServlet</h3><p>HttpServlet 也是一个抽象类，它进一步继承并封装了 GenericServlet，使得使用更加简单方便，由于是扩展了 Http 的内容，所以还需要使用 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code>，这两个类分别是 ServletRequest 和 <code>ServletResponse</code> 的子类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span></span>{</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//HttpServlet中的service()</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest httpServletRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">                       HttpServletResponse httpServletResponse)</span></span>{</span><br><span class="line">        <span class="comment">//该方法通过httpServletRequest.getMethod()判断请求类型调用doGet() doPost()</span></span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//必须实现父类的service()方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest,ServletResponse servletResponse)</span></span>{</span><br><span class="line">      HttpServletRequest request;</span><br><span class="line">      HttpServletResponse response;</span><br><span class="line">      <span class="keyword">try</span>{</span><br><span class="line">         request=(HttpServletRequest)servletRequest;</span><br><span class="line">         response=(HttpServletResponse)servletResponse;</span><br><span class="line">      }<span class="keyword">catch</span>(ClassCastException){</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"non-http request or response"</span>);</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">//调用service()方法</span></span><br><span class="line">      <span class="keyword">this</span>.service(request,response);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以看到，HttpServlet 中对原始的 Servlet 中的方法都进行了默认的操作，不需要显式的销毁初始化以及 <code>service()</code>，在 HttpServlet 中，自定义了一个新的 <code>service()</code> 方法，其中通过 getMethod() 方法判断请求的类型，从而调用 <code>doGet()</code> 或者 <code>doPost()</code> 处理 <code>get,post</code> 请求，使用者只需要继承 <code>HttpServlet</code>，然后重写 <code>doPost()</code> 或者 <code>doGet()</code> 方法处理请求即可。</p>
<p><strong>我们一般都使用继承 HttpServlet 的方式来定义一个 servlet。</strong></p>
<hr>
<h2 id="🌸Servlet环境配置（Eclipse）"><a href="#🌸Servlet环境配置（Eclipse）" class="headerlink" title="🌸Servlet环境配置（Eclipse）"></a>🌸Servlet环境配置（Eclipse）</h2><p>使用 Eclipse 来搭建 JSP 开发环境，首先我们分别下载一下软件包</p>
<ul>
<li><strong>Eclipse J2EE：</strong><a href="http://www.eclipse.org/downloads/" target="_blank" rel="noopener">http://www.eclipse.org/downloads/</a></li>
<li><strong>Tomcat：</strong><a href="http://tomcat.apache.org/download-70.cgi" target="_blank" rel="noopener">http://tomcat.apache.org/download-70.cgi</a></li>
</ul>
<h3 id="🍁Tomcat-下载安装"><a href="#🍁Tomcat-下载安装" class="headerlink" title="🍁Tomcat 下载安装"></a>🍁Tomcat 下载安装</h3><p><a href="https://imgchr.com/i/dXrmcQ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/31/dXrmcQ.png" alt="dXrmcQ.png"></a></p>
<p>下载之后，将压缩包解压到盘（你可以自己选择）：</p>
<p><a href="https://imgchr.com/i/dXrEh8" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/31/dXrEh8.png" alt="dXrEh8.png"></a></p>
<p>注意目录名不能有中文和空格。目录介绍如下：</p>
<ul>
<li>bin：二进制执行文件。里面最常用的文件是<strong>startup.bat</strong>，如果是 Linux 或 Mac 系统启动文件为 <strong>startup.sh</strong>。</li>
<li>conf:配置目录。里面最核心的文件是<strong>server.xml</strong>。可以在里面改端口号等。默认端口号是8080，也就是说，此端口号不能被其他应用程序占用。</li>
<li>lib：库文件。tomcat运行时需要的jar包所在的目录</li>
<li>logs：日志</li>
<li>temp：临时产生的文件，即缓存</li>
<li>webapps：web的应用程序。<strong>web应用放置到此目录下浏览器可以直接访问</strong></li>
<li>work：编译以后的class文件。</li>
</ul>
<p>接着我们可以双击 startup.bat 启动 Tomcat，弹出如下界面：</p>
<p><a href="https://imgchr.com/i/dXrAtf" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/31/dXrAtf.png" alt="dXrAtf.png"></a></p>
<p>这个时候，本地的服务器就已经搭建起来了。如果想关闭服务器，可以直接关闭上面的窗口，或者在里面输入Ctrl+C禁止服务。</p>
<p>接着我们在浏览器中输入 <strong><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></strong>，如果弹出如下界面，表示tomcat安装成功并且启动起来了：</p>
<p><a href="https://imgchr.com/i/dXre1g" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/31/dXre1g.png" alt="dXre1g.png"></a></p>
<p>首先在apache-tomcat-9.0.37\webapps\ROOT目录中新建一个jsp文件：</p>
<p><a href="https://imgchr.com/i/dXrZ9S" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/31/dXrZ9S.png" alt="dXrZ9S.png"></a></p>
<p>test.jsp 文件代码如下：</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">out.<span class="keyword">print</span>(<span class="string">"云澈 : https://liudufu.github.io"</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>接着在浏览器中访问地址 <strong><a href="http://localhost:8080/test.jsp" target="_blank" rel="noopener">http://localhost:8080/test.jsp</a></strong>, 输出结果如下：</p>
<p><a href="https://imgchr.com/i/dX6yCV" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/31/dX6yCV.png" alt="dX6yCV.png"></a></p>
<h3 id="🍁Tomcat-和-Eclipse-相关联"><a href="#🍁Tomcat-和-Eclipse-相关联" class="headerlink" title="🍁Tomcat 和 Eclipse 相关联"></a>🍁Tomcat 和 Eclipse 相关联</h3><p>打开Java EE ，选择菜单栏Windows–&gt;preferences（Mac 系统为 Eclipse–&gt;偏好设置），弹出如下界面：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2016/01/232111301681549.png" alt=""></p>
<p>上图中，点击”add”的添加按钮，弹出如下界面：</p>
<p><a href="https://imgchr.com/i/dXcFKg" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/31/dXcFKg.png" alt="dXcFKg.png"></a></p>
<p>点击 “Finish”，完成配置。</p>
<h3 id="🍁创建实例"><a href="#🍁创建实例" class="headerlink" title="🍁创建实例"></a>🍁创建实例</h3><p>选择 “File–&gt;New–&gt;Dynamic Web Project”，创建 TomcatTest 项目：</p>
<p><a href="https://imgchr.com/i/dX2r4I" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/31/dX2r4I.png" alt="dX2r4I.png"></a></p>
<p><a href="https://imgchr.com/i/dX2BEd" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/31/dX2BEd.png" alt="dX2BEd.png"></a></p>
<p>工程文件结构：</p>
<p><a href="https://imgchr.com/i/dX2wHH" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/31/dX2wHH.png" alt="dX2wHH.png"></a></p>
<p>上图中各个目录解析：</p>
<ul>
<li>deployment descriptor：部署的描述。</li>
<li>Web App Libraries：自己加的包可以放在里面。</li>
<li>build：放入编译之后的文件。</li>
<li>WebContent:放进写入的页面。</li>
</ul>
<p>在WebContent文件夹下新建一个test.jsp文件。在下图中可以看到它的默认代码：</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">    pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>接着我们修改下test.jsp文件代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;%@ page language="java" contentType="text/html; charset=UTF-8"</span><br><span class="line">    pageEncoding="UTF-8"%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;</span><br><span class="line">&lt;title&gt;云澈&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    out.println("Hello World!");</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>运行该项目:</p>
<p><a href="https://imgchr.com/i/dX2DUA" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/31/dX2DUA.png" alt="dX2DUA.png"></a></p>
<p>浏览器访问 <code>http://localhost:8080/TomcatTest/test.jsp</code>, 即可输出正常结果：</p>
<p><a href="https://imgchr.com/i/dX2dDe" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/31/dX2dDe.png" alt="dX2dDe.png"></a></p>
<h3 id="🍁Servlet-实例创建"><a href="#🍁Servlet-实例创建" class="headerlink" title="🍁Servlet 实例创建"></a>🍁Servlet 实例创建</h3><p>使用以上环境创建 Servlet 文件，选择 “File–&gt;New–&gt;Servlet”:</p>
<p><a href="https://imgchr.com/i/dX268P" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/31/dX268P.png" alt="dX268P.png"></a></p>
<p>HelloServlet.java 代码如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yunche.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class HelloServlet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/HelloServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloServlet</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        <span class="comment">// 使用 GBK 设置中文正常显示</span></span><br><span class="line">        response.setCharacterEncoding(<span class="string">"GBK"</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">"云澈：https://liudufu.github.io"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        doGet(request, response);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>创建 /TomcatTest/WebContent/WEB-INF/web.xml 文件（如果没有），代码如下所示：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">"2.5"</span>   </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span>   </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>   </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee   </span></span></span><br><span class="line"><span class="tag"><span class="string">    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">     <span class="comment">&lt;!-- 类名 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 所在的包 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.yunche.test.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 访问的网址 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/TomcatTest/HelloServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>接着重启 Tomcat，浏览器访问 <code>http://localhost:8080/TomcatTest/HelloServlet：</code></p>
<p><a href="https://imgchr.com/i/dX2yCt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/31/dX2yCt.png" alt="dX2yCt.png"></a></p>
<hr>
<h2 id="🌸Servlet-生命周期"><a href="#🌸Servlet-生命周期" class="headerlink" title="🌸Servlet 生命周期"></a>🌸Servlet 生命周期</h2><p>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：</p>
<ul>
<li>Servlet 通过调用 <strong>init ()</strong> 方法进行初始化。</li>
<li>Servlet 调用 <strong>service()</strong> 方法来处理客户端的请求。</li>
<li>Servlet 通过调用 <strong>destroy()</strong> 方法终止（结束）。</li>
<li>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</li>
</ul>
<p>现在让我们详细讨论生命周期的方法。</p>
<h3 id="🍁init-方法"><a href="#🍁init-方法" class="headerlink" title="🍁init() 方法"></a>🍁init() 方法</h3><p>init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。因此，它是用于一次性初始化，就像 Applet 的 init 方法一样。</p>
<p>Servlet 创建于用户第一次调用对应于该 Servlet 的 URL 时，但是您也可以指定 Servlet 在服务器第一次启动时被加载。</p>
<p>当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期。</p>
<p>init 方法的定义如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>{</span><br><span class="line">  <span class="comment">// 初始化代码...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁service-方法"><a href="#🍁service-方法" class="headerlink" title="🍁service() 方法"></a>🍁service() 方法</h3><p>service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。</p>
<p>每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。</p>
<p>下面是该方法的特征：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public void service(ServletRequest request, </span><br><span class="line">                    ServletResponse response) </span><br><span class="line">      throws ServletException, IOException{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，您不用对 service() 方法做任何动作，您只需要根据来自客户端的请求类型来重写 doGet() 或 doPost() 即可。</p>
<p>doGet() 和 doPost() 方法是每次服务请求中最常用的方法。下面是这两种方法的特</p>
<h3 id="🍁doGet-方法"><a href="#🍁doGet-方法" class="headerlink" title="🍁doGet() 方法"></a>🍁doGet() 方法</h3><p>GET 请求来自于一个 URL 的正常请求，或者来自于一个未指定 METHOD 的 HTML 表单，它由 doGet() 方法处理。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                  HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">    <span class="comment">// Servlet 代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁doPost-方法"><a href="#🍁doPost-方法" class="headerlink" title="🍁doPost() 方法"></a>🍁doPost() 方法</h3><p>POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                   HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">    <span class="comment">// Servlet 代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁destroy-方法"><a href="#🍁destroy-方法" class="headerlink" title="🍁destroy() 方法"></a>🍁destroy() 方法</h3><p>destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。</p>
<p>在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收。destroy 方法定义如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="comment">// 终止化代码...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁架构图"><a href="#🍁架构图" class="headerlink" title="🍁架构图"></a>🍁架构图</h3><p>下图显示了一个典型的 Servlet 生命周期方案。</p>
<ul>
<li>第一个到达服务器的 HTTP 请求被委派到 Servlet 容器。</li>
<li>Servlet 容器在调用 service() 方法之前加载 Servlet。</li>
<li>然后 Servlet 容器处理由多个线程产生的多个请求，每个线程执行一个单一的 Servlet 实例的 service() 方法。</li>
</ul>
<p><a href="https://imgchr.com/i/dxHFxg" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/01/dxHFxg.png" alt="dxHFxg.png"></a></p>
<hr>
<h2 id="🌸Servlet-实例"><a href="#🌸Servlet-实例" class="headerlink" title="🌸Servlet 实例"></a>🌸Servlet 实例</h2><p>Servlet 是服务 HTTP 请求并实现 <strong>javax.servlet.Servlet</strong> 接口的 Java 类。Web 应用程序开发人员通常编写 Servlet 来扩展 javax.servlet.http.HttpServlet，并实现 Servlet 接口的抽象类专门用来处理 HTTP 请求。</p>
<h3 id="🍁Hello-World-示例代码"><a href="#🍁Hello-World-示例代码" class="headerlink" title="🍁Hello World 示例代码"></a>🍁Hello World 示例代码</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 导入必需的 java 库</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展 HttpServlet 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">      <span class="comment">// 执行必需的初始化</span></span><br><span class="line">      message = <span class="string">"Hello World"</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                    HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">      <span class="comment">// 设置响应内容类型</span></span><br><span class="line">      response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 实际的逻辑是在这里</span></span><br><span class="line">      PrintWriter out = response.getWriter();</span><br><span class="line">      out.println(<span class="string">"&lt;h1&gt;"</span> + message + <span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">      <span class="comment">// 什么也不做</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="🍁Servlet部署"><a href="#🍁Servlet部署" class="headerlink" title="🍁Servlet部署"></a>🍁Servlet部署</h3><p>WEB-INF/ 的 <strong>web.xml</strong> 文件中创建以下条目</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/HelloWorld<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>启动 tomcat 服务器，最后在浏览器的地址栏中输入 <strong><a href="http://localhost:8080/HelloWorld" target="_blank" rel="noopener">http://localhost:8080/HelloWorld</a></strong>。如果一切顺利，您会看到下面的结果：</p>
<p><a href="https://imgchr.com/i/dxO6c8" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/01/dxO6c8.png" alt="dxO6c8.png"></a></p>
<h3 id="🍁后记"><a href="#🍁后记" class="headerlink" title="🍁后记"></a>🍁后记</h3><p>destory 方法被调用后，servlet 被销毁，但是并没有立即被回收，再次请求时，并没有重新初始化。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>{</span><br><span class="line">    message = <span class="string">"Hello World , Nect To Meet You: "</span> + System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"servlet初始化……"</span>);</span><br><span class="line">    <span class="keyword">super</span>.init();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">    response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line">    PrintWriter writer = response.getWriter();</span><br><span class="line">    writer.write(<span class="string">"&lt;h1&gt;"</span> + message + <span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">    destroy();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br><span class="line">    System.out.println(<span class="string">"servlet销毁！"</span>);</span><br><span class="line">    <span class="keyword">super</span>.destroy();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>控制台打印：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">servlet初始化……</span><br><span class="line">servlet销毁！</span><br><span class="line">2017-7-6 19:48:52 org.apache.catalina.core.StandardContext reload</span><br><span class="line">信息: Reloading Context with name [/myServlet] has started</span><br><span class="line">servlet销毁！</span><br><span class="line">2017-7-6 19:48:52 org.apache.catalina.core.StandardContext reload</span><br><span class="line">信息: Reloading Context with name [/myServlet] is completed</span><br><span class="line">servlet初始化……</span><br><span class="line">servlet销毁！</span><br><span class="line">servlet销毁！</span><br><span class="line">servlet销毁！</span><br><span class="line">servlet销毁！</span><br><span class="line">servlet销毁！</span><br><span class="line">servlet销毁！</span><br><span class="line">servlet销毁！</span><br></pre></td></tr></tbody></table></figure>

<p><strong>servlet 浏览器访问路径配置有个小问题：</strong></p>
<p>1、java 类里的注解 —— @WebServlet(“/HelloServlet”) 对应浏览器路径：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://localhost:8080/TomcatTest/HelloServlet</span><br></pre></td></tr></tbody></table></figure>

<p>2、配置文件（web.xml）里对应的浏览器访问路径：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://localhost:8080/TomcatTest/TomcatTest/HelloServlet</span><br></pre></td></tr></tbody></table></figure>

<p>这两种配一个就好了，不然路径重名的话反而会让tomcat启动不了。</p>
<p>例如这样就启动不了：</p>
<p>修改 web.xml :</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;url-pattern&gt;/HelloServlet&lt;/url-pattern&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>修改后，web.xml 和 java 类的注解，对应路径都是：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://localhost:8080/TomcatTest/HelloServlet</span><br></pre></td></tr></tbody></table></figure>

<p><strong>导致</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">命名的 servlet[HelloServlet]和 [com.runoob.test.HelloServlet] 都被映射到 URL 模式 [/ HelloServlet] 这是不允许的。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>解决办法：</strong></p>
<p>将<strong>注解去掉</strong>或者<strong>保留注解进入web.xml将映射删除</strong>既可以。</p>
<hr>
<h2 id="🌸Servlet-表单数据"><a href="#🌸Servlet-表单数据" class="headerlink" title="🌸Servlet 表单数据"></a>🌸Servlet 表单数据</h2><p>很多情况下，需要传递一些信息，从浏览器到 Web 服务器，最终到后台程序。浏览器使用两种方法可将这些信息传递到 Web 服务器，分别为 GET 方法和 POST 方法。</p>
<h3 id="🍁GET-方法"><a href="#🍁GET-方法" class="headerlink" title="🍁GET 方法"></a>🍁GET 方法</h3><p>GET 方法向页面请求发送已编码的用户信息。页面和已编码的信息中间用 ? 字符分隔，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://www.test.com/hello?key1=value1&amp;key2=value2</span><br></pre></td></tr></tbody></table></figure>

<p>GET 方法是默认的从浏览器向 Web 服务器传递信息的方法，它会产生一个很长的字符串，出现在浏览器的地址栏中。如果您要向服务器传递的是密码或其他的敏感信息，请不要使用 GET 方法。GET 方法有大小限制：请求字符串中最多只能有 1024 个字符。</p>
<p>这些信息使用 QUERY_STRING 头传递，并可以通过 QUERY_STRING 环境变量访问，Servlet 使用 <strong>doGet()</strong> 方法处理这种类型的请求。</p>
<h3 id="🍁POST-方法"><a href="#🍁POST-方法" class="headerlink" title="🍁POST 方法"></a>🍁POST 方法</h3><p>另一个向后台程序传递信息的比较可靠的方法是 POST 方法。POST 方法打包信息的方式与 GET 方法基本相同，但是 POST 方法不是把信息作为 URL 中 ? 字符后的文本字符串进行发送，而是把这些信息作为一个单独的消息。消息以标准输出的形式传到后台程序，您可以解析和使用这些标准输出。Servlet 使用 doPost() 方法处理这种类型的请求。</p>
<h3 id="🍁使用-Servlet-读取表单数据"><a href="#🍁使用-Servlet-读取表单数据" class="headerlink" title="🍁使用 Servlet 读取表单数据"></a>🍁使用 Servlet 读取表单数据</h3><p>Servlet 处理表单数据，这些数据会根据不同的情况使用不同的方法自动解析：</p>
<ul>
<li><strong>getParameter()：</strong>您可以调用 request.getParameter() 方法来获取表单参数的值。</li>
<li><strong>getParameterValues()：</strong>如果参数出现一次以上，则调用该方法，并返回多个值，例如复选框。</li>
<li><strong>getParameterNames()：</strong>如果您想要得到当前请求中的所有参数的完整列表，则调用该方法。</li>
</ul>
<h3 id="🍁使用-URL-的-GET-方法实例"><a href="#🍁使用-URL-的-GET-方法实例" class="headerlink" title="🍁使用 URL 的 GET 方法实例"></a>🍁使用 URL 的 GET 方法实例</h3><p>下面是一个简单的 URL，将使用 GET 方法向 HelloForm 程序传递两个值。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://localhost:8080/TomcatTest/HelloForm?name=云澈&amp;url=https://liudufu.github.io</span><br></pre></td></tr></tbody></table></figure>

<p>下面是处理 Web 浏览器输入的 <strong>HelloForm.java</strong> Servlet 程序。我们将使用 <strong>getParameter()</strong> 方法，可以很容易地访问传递的信息</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class HelloForm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/HelloForm"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloForm</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloForm</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        <span class="comment">// 设置响应内容类型</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = <span class="string">"使用 GET 方法读取表单数据"</span>;</span><br><span class="line">        <span class="comment">// 处理中文</span></span><br><span class="line">        String name =<span class="keyword">new</span> String(request.getParameter(<span class="string">"name"</span>).getBytes(<span class="string">"UTF-8"</span>),<span class="string">"UTF-8"</span>);</span><br><span class="line">        String docType = <span class="string">"&lt;!DOCTYPE html&gt; \n"</span>;</span><br><span class="line">        out.println(docType +</span><br><span class="line">            <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;ul&gt;\n"</span> +</span><br><span class="line">            <span class="string">"  &lt;li&gt;&lt;b&gt;站点名&lt;/b&gt;："</span></span><br><span class="line">            + name + <span class="string">"\n"</span> +</span><br><span class="line">            <span class="string">"  &lt;li&gt;&lt;b&gt;网址&lt;/b&gt;："</span></span><br><span class="line">            + request.getParameter(<span class="string">"url"</span>) + <span class="string">"\n"</span> +</span><br><span class="line">            <span class="string">"&lt;/ul&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理 POST 方法请求的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后我们在 <strong>web.xml</strong> 文件中创建以下条目：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloForm<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.runoob.test.HelloForm<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloForm<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/TomcatTest/HelloForm<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>



<p>现在在浏览器的地址栏中输入<code>http://localhost:8080/TomcatTest/HelloForm?name=云澈&amp;url=https://liudufu.github.io</code>，并在触发上述命令之前确保已经启动 Tomcat 服务器。如果一切顺利，您会得到下面的结果：</p>
<p><a href="https://imgchr.com/i/wpxUXt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/02/wpxUXt.png" alt="wpxUXt.png"></a></p>
<h3 id="🍁使用表单的-GET-方法实例"><a href="#🍁使用表单的-GET-方法实例" class="headerlink" title="🍁使用表单的 GET 方法实例"></a>🍁使用表单的 GET 方法实例</h3><p>下面是一个简单的实例，使用 HTML 表单和提交按钮传递两个值。我们将使用相同的 Servlet HelloForm 来处理输入。</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"HelloForm"</span> <span class="attr">method</span>=<span class="string">"GET"</span>&gt;</span></span><br><span class="line">网址名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">网址：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"url"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>保存这个 HTML 到 hello.html 文件中，目录结构在WebContent下</p>
<p>尝试输入网址名和网址，然后点击”提交”按钮，</p>
<p><a href="https://imgchr.com/i/wpxYpd" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/02/wpxYpd.png" alt="wpxYpd.png"></a></p>
<p><a href="https://imgchr.com/i/wpxt1A" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/02/wpxt1A.png" alt="wpxt1A.png"></a></p>
<h3 id="🍁使用表单的-POST-方法实例"><a href="#🍁使用表单的-POST-方法实例" class="headerlink" title="🍁使用表单的 POST 方法实例"></a>🍁使用表单的 POST 方法实例</h3><p>让我们对上面的 Servlet 做小小的修改，以便它可以处理 GET 和 POST 方法。下面的 <strong>HelloForm.java</strong> Servlet 程序使用 GET 和 POST 方法处理由 Web 浏览器给出的输入。</p>
<p>注意：如果表单提交的数据中有中文数据则需要转码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">String name =<span class="keyword">new</span> String(request.getParameter(<span class="string">"name"</span>).getBytes(<span class="string">"ISO8859-1"</span>),<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class HelloForm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/HelloForm"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloForm</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloForm</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        <span class="comment">// 设置响应内容类型</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = <span class="string">"使用 POST 方法读取表单数据"</span>;</span><br><span class="line">        <span class="comment">// 处理中文</span></span><br><span class="line">        String name =<span class="keyword">new</span> String(request.getParameter(<span class="string">"name"</span>).getBytes(<span class="string">"ISO8859-1"</span>),<span class="string">"UTF-8"</span>);</span><br><span class="line">        String docType = <span class="string">"&lt;!DOCTYPE html&gt; \n"</span>;</span><br><span class="line">        out.println(docType +</span><br><span class="line">            <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;ul&gt;\n"</span> +</span><br><span class="line">            <span class="string">"  &lt;li&gt;&lt;b&gt;站点名&lt;/b&gt;："</span></span><br><span class="line">            + name + <span class="string">"\n"</span> +</span><br><span class="line">            <span class="string">"  &lt;li&gt;&lt;b&gt;网址&lt;/b&gt;："</span></span><br><span class="line">            + request.getParameter(<span class="string">"url"</span>) + <span class="string">"\n"</span> +</span><br><span class="line">            <span class="string">"&lt;/ul&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理 POST 方法请求的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在，编译部署上述的 Servlet，并使用带有 POST 方法的 hello.html 进行测试，如下所示</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>云澈(liudufu.github.io)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"HelloForm"</span> <span class="attr">method</span>=<span class="string">"GET"</span>&gt;</span></span><br><span class="line">网址名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">网址：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"url"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>表单的实际输出与get图相同</p>
<h3 id="🍁将复选框数据传递到-Servlet-程序"><a href="#🍁将复选框数据传递到-Servlet-程序" class="headerlink" title="🍁将复选框数据传递到 Servlet 程序"></a>🍁将复选框数据传递到 Servlet 程序</h3><p>当需要选择一个以上的选项时，则使用复选框。</p>
<p>下面是一个 HTML 代码实例 checkbox.html，一个带有两个复选框的表单。</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>云澈(liudufu.github.io)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"CheckBox"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"runoob"</span> <span class="attr">checked</span>=<span class="string">"checked"</span> /&gt;</span> 云澈</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"google"</span>  /&gt;</span> Google</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"taobao"</span> <span class="attr">checked</span>=<span class="string">"checked"</span> /&gt;</span> 淘宝</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"选择站点"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>下面是 CheckBox.java Servlet 程序，处理 Web 浏览器给出的复选框输入。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class CheckBox</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/CheckBox"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckBox</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置响应内容类型</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = <span class="string">"读取复选框数据"</span>;</span><br><span class="line">        String docType = <span class="string">"&lt;!DOCTYPE html&gt; \n"</span>;</span><br><span class="line">            out.println(docType +</span><br><span class="line">                <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;ul&gt;\n"</span> +</span><br><span class="line">                <span class="string">"  &lt;li&gt;&lt;b&gt;云澈标识：&lt;/b&gt;: "</span></span><br><span class="line">                + request.getParameter(<span class="string">"runoob"</span>) + <span class="string">"\n"</span> +</span><br><span class="line">                <span class="string">"  &lt;li&gt;&lt;b&gt;Google 标识：&lt;/b&gt;: "</span></span><br><span class="line">                + request.getParameter(<span class="string">"google"</span>) + <span class="string">"\n"</span> +</span><br><span class="line">                <span class="string">"  &lt;li&gt;&lt;b&gt;淘宝标识：&lt;/b&gt;: "</span></span><br><span class="line">                + request.getParameter(<span class="string">"taobao"</span>) + <span class="string">"\n"</span> +</span><br><span class="line">                <span class="string">"&lt;/ul&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理 POST 方法请求的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>设置对应的 web.xml：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>CheckBox<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.runoob.test.CheckBox<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>CheckBox<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/TomcatTest/CheckBox<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>上面的实例将显示下面的结果：</p>
<p><a href="https://imgchr.com/i/wpxGfH" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/02/wpxGfH.png" alt="wpxGfH.png"></a></p>
<p><a href="https://imgchr.com/i/wpxN6I" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/02/wpxN6I.png" alt="wpxN6I.png"></a></p>
<h3 id="🍁读取所有的表单参数"><a href="#🍁读取所有的表单参数" class="headerlink" title="🍁读取所有的表单参数"></a>🍁读取所有的表单参数</h3><p>以下是通用的实例，使用 HttpServletRequest 的 <strong>getParameterNames()</strong> 方法读取所有可用的表单参数。该方法返回一个枚举，其中包含未指定顺序的参数名。</p>
<p>一旦我们有一个枚举，我们可以以标准方式循环枚举，使用 <em>hasMoreElements()</em> 方法来确定何时停止，使用 <em>nextElement()</em> 方法来获取每个参数的名称。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class ReadParams</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/ReadParams"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadParams</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadParams</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        <span class="comment">// 设置响应内容类型</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = <span class="string">"读取所有的表单数据"</span>;</span><br><span class="line">        String docType =</span><br><span class="line">            <span class="string">"&lt;!doctype html public \"-//w3c//dtd html 4.0 "</span> +</span><br><span class="line">            <span class="string">"transitional//en\"&gt;\n"</span>;</span><br><span class="line">            out.println(docType +</span><br><span class="line">            <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;table width=\"100%\" border=\"1\" align=\"center\"&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;tr bgcolor=\"#949494\"&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;th&gt;参数名称&lt;/th&gt;&lt;th&gt;参数值&lt;/th&gt;\n"</span>+</span><br><span class="line">            <span class="string">"&lt;/tr&gt;\n"</span>);</span><br><span class="line"></span><br><span class="line">        Enumeration paramNames = request.getParameterNames();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(paramNames.hasMoreElements()) {</span><br><span class="line">            String paramName = (String)paramNames.nextElement();</span><br><span class="line">            out.print(<span class="string">"&lt;tr&gt;&lt;td&gt;"</span> + paramName + <span class="string">"&lt;/td&gt;\n"</span>);</span><br><span class="line">            String[] paramValues =</span><br><span class="line">            request.getParameterValues(paramName);</span><br><span class="line">            <span class="comment">// 读取单个值的数据</span></span><br><span class="line">            <span class="keyword">if</span> (paramValues.length == <span class="number">1</span>) {</span><br><span class="line">                String paramValue = paramValues[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (paramValue.length() == <span class="number">0</span>)</span><br><span class="line">                    out.println(<span class="string">"&lt;td&gt;&lt;i&gt;没有值&lt;/i&gt;&lt;/td&gt;"</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    out.println(<span class="string">"&lt;td&gt;"</span> + paramValue + <span class="string">"&lt;/td&gt;"</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 读取多个值的数据</span></span><br><span class="line">                out.println(<span class="string">"&lt;td&gt;&lt;ul&gt;"</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; paramValues.length; i++) {</span><br><span class="line">                out.println(<span class="string">"&lt;li&gt;"</span> + paramValues[i]);</span><br><span class="line">            }</span><br><span class="line">                out.println(<span class="string">"&lt;/ul&gt;&lt;/td&gt;"</span>);</span><br><span class="line">            }</span><br><span class="line">            out.print(<span class="string">"&lt;/tr&gt;"</span>);</span><br><span class="line">        }</span><br><span class="line">        out.println(<span class="string">"\n&lt;/table&gt;\n&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        doGet(request, response);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在，通过下面的表单尝试上面的 Servlet：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>云澈(liudufu.github.io)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"ReadParams"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"maths"</span> <span class="attr">checked</span>=<span class="string">"checked"</span> /&gt;</span> 数学</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"physics"</span>  /&gt;</span> 物理</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"chemistry"</span> <span class="attr">checked</span>=<span class="string">"checked"</span> /&gt;</span> 化学</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"选择学科"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>设置相应的 web.xml:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ReadParams<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.runoob.test.ReadParams<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ReadParams<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/TomcatTest/ReadParams<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>现在使用上面的表单调用 Servlet，将产生以下结果：</p>
<p><a href="https://imgchr.com/i/wpxw0f" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/02/wpxw0f.png" alt="wpxw0f.png"></a><br><a href="https://imgchr.com/i/wpx078" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/02/wpx078.png" alt="wpx078.png"></a></p>
<h2 id="🌸Servlet-客户端-HTTP-请求"><a href="#🌸Servlet-客户端-HTTP-请求" class="headerlink" title="🌸Servlet 客户端 HTTP 请求"></a>🌸Servlet 客户端 HTTP 请求</h2><p>当浏览器请求网页时，它会向 Web 服务器发送特定信息，这些信息不能被直接读取，因为这些信息是作为 HTTP 请求的头的一部分进行传输的。</p>
<p>以下是来自于浏览器端的重要头信息，您可以在 Web 编程中频繁使用：</p>
<table>
<thead>
<tr>
<th align="left">头信息</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accept</td>
<td align="left">这个头信息指定浏览器或其他客户端可以处理的 MIME 类型。值 <strong>image/png</strong> 或 <strong>image/jpeg</strong> 是最常见的两种可能值。</td>
</tr>
<tr>
<td align="left">Accept-Charset</td>
<td align="left">这个头信息指定浏览器可以用来显示信息的字符集。例如 ISO-8859-1。</td>
</tr>
<tr>
<td align="left">Accept-Encoding</td>
<td align="left">这个头信息指定浏览器知道如何处理的编码类型。值 <strong>gzip</strong> 或 <strong>compress</strong> 是最常见的两种可能值。</td>
</tr>
<tr>
<td align="left">Accept-Language</td>
<td align="left">这个头信息指定客户端的首选语言，在这种情况下，Servlet 会产生多种语言的结果。例如，en、en-us、ru 等。</td>
</tr>
<tr>
<td align="left">Authorization</td>
<td align="left">这个头信息用于客户端在访问受密码保护的网页时识别自己的身份。</td>
</tr>
<tr>
<td align="left">Connection</td>
<td align="left">这个头信息指示客户端是否可以处理持久 HTTP 连接。持久连接允许客户端或其他浏览器通过单个请求来检索多个文件。值 <strong>Keep-Alive</strong> 意味着使用了持续连接。</td>
</tr>
<tr>
<td align="left">Content-Length</td>
<td align="left">这个头信息只适用于 POST 请求，并给出 POST 数据的大小（以字节为单位）。</td>
</tr>
<tr>
<td align="left">Cookie</td>
<td align="left">这个头信息把之前发送到浏览器的 cookies 返回到服务器。</td>
</tr>
<tr>
<td align="left">Host</td>
<td align="left">这个头信息指定原始的 URL 中的主机和端口。</td>
</tr>
<tr>
<td align="left">If-Modified-Since</td>
<td align="left">这个头信息表示只有当页面在指定的日期后已更改时，客户端想要的页面。如果没有新的结果可以使用，服务器会发送一个 304 代码，表示 <strong>Not Modified</strong> 头信息。</td>
</tr>
<tr>
<td align="left">If-Unmodified-Since</td>
<td align="left">这个头信息是 If-Modified-Since 的对立面，它指定只有当文档早于指定日期时，操作才会成功。</td>
</tr>
<tr>
<td align="left">Referer</td>
<td align="left">这个头信息指示所指向的 Web 页的 URL。例如，如果您在网页 1，点击一个链接到网页 2，当浏览器请求网页 2 时，网页 1 的 URL 就会包含在 Referer 头信息中。</td>
</tr>
<tr>
<td align="left">User-Agent</td>
<td align="left">这个头信息识别发出请求的浏览器或其他客户端，并可以向不同类型的浏览器返回不同的内容。</td>
</tr>
</tbody></table>
<h3 id="🍁读取-HTTP-头的方法"><a href="#🍁读取-HTTP-头的方法" class="headerlink" title="🍁读取 HTTP 头的方法"></a>🍁读取 HTTP 头的方法</h3><p>下面的方法可用在 Servlet 程序中读取 HTTP 头。这些方法通过 <em>HttpServletRequest</em> 对象可用。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>Cookie[] getCookies()</strong> 返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>Enumeration getAttributeNames()</strong> 返回一个枚举，包含提供给该请求可用的属性名称。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>Enumeration getHeaderNames()</strong> 返回一个枚举，包含在该请求中包含的所有的头名。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>Enumeration getParameterNames()</strong> 返回一个 String 对象的枚举，包含在该请求中包含的参数的名称。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>HttpSession getSession()</strong> 返回与该请求关联的当前 session 会话，或者如果请求没有 session 会话，则创建一个。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>HttpSession getSession(boolean create)</strong> 返回与该请求关联的当前 HttpSession，或者如果没有当前会话，且创建是真的，则返回一个新的 session 会话。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>Locale getLocale()</strong> 基于 Accept-Language 头，返回客户端接受内容的首选的区域设置。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>Object getAttribute(String name)</strong> 以对象形式返回已命名属性的值，如果没有给定名称的属性存在，则返回 null。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>ServletInputStream getInputStream()</strong> 使用 ServletInputStream，以二进制数据形式检索请求的主体。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>String getAuthType()</strong> 返回用于保护 Servlet 的身份验证方案的名称，例如，”BASIC” 或 “SSL”，如果JSP没有受到保护则返回 null。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>String getCharacterEncoding()</strong> 返回请求主体中使用的字符编码的名称。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>String getContentType()</strong> 返回请求主体的 MIME 类型，如果不知道类型则返回 null。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>String getContextPath()</strong> 返回指示请求上下文的请求 URI 部分。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><strong>String getHeader(String name)</strong> 以字符串形式返回指定的请求头的值。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><strong>String getMethod()</strong> 返回请求的 HTTP 方法的名称，例如，GET、POST 或 PUT。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><strong>String getParameter(String name)</strong> 以字符串形式返回请求参数的值，或者如果参数不存在则返回 null。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><strong>String getPathInfo()</strong> 当请求发出时，返回与客户端发送的 URL 相关的任何额外的路径信息。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><strong>String getProtocol()</strong> 返回请求协议的名称和版本。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><strong>String getQueryString()</strong> 返回包含在路径后的请求 URL 中的查询字符串。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><strong>String getRemoteAddr()</strong> 返回发送请求的客户端的互联网协议（IP）地址。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><strong>String getRemoteHost()</strong> 返回发送请求的客户端的完全限定名称。</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><strong>String getRemoteUser()</strong> 如果用户已通过身份验证，则返回发出请求的登录用户，或者如果用户未通过身份验证，则返回 null。</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left"><strong>String getRequestURI()</strong> 从协议名称直到 HTTP 请求的第一行的查询字符串中，返回该请求的 URL 的一部分。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left"><strong>String getRequestedSessionId()</strong> 返回由客户端指定的 session 会话 ID。</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left"><strong>String getServletPath()</strong> 返回调用 JSP 的请求的 URL 的一部分。</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left"><strong>String[] getParameterValues(String name)</strong> 返回一个字符串对象的数组，包含所有给定的请求参数的值，如果参数不存在则返回 null。</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left"><strong>boolean isSecure()</strong> 返回一个布尔值，指示请求是否使用安全通道，如 HTTPS。</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left"><strong>int getContentLength()</strong> 以字节为单位返回请求主体的长度，并提供输入流，或者如果长度未知则返回 -1。</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left"><strong>int getIntHeader(String name)</strong> 返回指定的请求头的值为一个 int 值。</td>
</tr>
<tr>
<td align="left">30</td>
<td align="left"><strong>int getServerPort()</strong> 返回接收到这个请求的端口号。</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left"><strong>int getParameterMap()</strong> 将参数封装成 Map 类型。</td>
</tr>
</tbody></table>
<h3 id="🍁HTTP-Header-请求实例"><a href="#🍁HTTP-Header-请求实例" class="headerlink" title="🍁HTTP Header 请求实例"></a>🍁HTTP Header 请求实例</h3><p>下面的实例使用 HttpServletRequest 的 <strong>getHeaderNames()</strong> 方法读取 HTTP 头信息。该方法返回一个枚举，包含与当前的 HTTP 请求相关的头信息。</p>
<p>一旦我们有一个枚举，我们可以以标准方式循环枚举，使用 <em>hasMoreElements()</em> 方法来确定何时停止，使用 <em>nextElement()</em> 方法来获取每个参数的名称。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//导入必需的 java 库</span></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/DisplayHeader"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展 HttpServlet 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisplayHeader</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 GET 方法请求的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 设置响应内容类型</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = <span class="string">"HTTP Header 请求实例 - 云澈实例"</span>;</span><br><span class="line">        String docType =</span><br><span class="line">            <span class="string">"&lt;!DOCTYPE html&gt; \n"</span>;</span><br><span class="line">            out.println(docType +</span><br><span class="line">            <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span>+</span><br><span class="line">            <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;table width=\"100%\" border=\"1\" align=\"center\"&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;tr bgcolor=\"#949494\"&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;th&gt;Header 名称&lt;/th&gt;&lt;th&gt;Header 值&lt;/th&gt;\n"</span>+</span><br><span class="line">            <span class="string">"&lt;/tr&gt;\n"</span>);</span><br><span class="line"></span><br><span class="line">        Enumeration headerNames = request.getHeaderNames();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(headerNames.hasMoreElements()) {</span><br><span class="line">            String paramName = (String)headerNames.nextElement();</span><br><span class="line">            out.print(<span class="string">"&lt;tr&gt;&lt;td&gt;"</span> + paramName + <span class="string">"&lt;/td&gt;\n"</span>);</span><br><span class="line">            String paramValue = request.getHeader(paramName);</span><br><span class="line">            out.println(<span class="string">"&lt;td&gt; "</span> + paramValue + <span class="string">"&lt;/td&gt;&lt;/tr&gt;\n"</span>);</span><br><span class="line">        }</span><br><span class="line">        out.println(<span class="string">"&lt;/table&gt;\n&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 处理 POST 方法请求的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上测试实例是位于 TomcatTest 项目下，对应的 web.xml 配置为：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 类名 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DisplayHeader<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 所在的包 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.runoob.test.DisplayHeader<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DisplayHeader<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 访问的网址 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/TomcatTest/DisplayHeader<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>现在，调用上面的 Servlet，访问 <strong><a href="http://localhost:8080/TomcatTest/DisplayHeader" target="_blank" rel="noopener">http://localhost:8080/TomcatTest/DisplayHeader</a></strong> 会产生以下结果：</p>
<p><a href="https://imgchr.com/i/wPao0e" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/03/wPao0e.png" alt="wPao0e.png"></a></p>
<h2 id="🌸Servlet-服务器-HTTP-响应"><a href="#🌸Servlet-服务器-HTTP-响应" class="headerlink" title="🌸Servlet 服务器 HTTP 响应"></a>🌸Servlet 服务器 HTTP 响应</h2><p>正如前面的章节中讨论的那样，当一个 Web 服务器响应一个 HTTP 请求时，响应通常包括一个状态行、一些响应报头、一个空行和文档。一个典型的响应如下所示：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Header2: ...</span><br><span class="line">...</span><br><span class="line">HeaderN: ...</span><br><span class="line">  (Blank Line)</span><br><span class="line"><span class="meta">&lt;!doctype ...&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>...<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>状态行包括 HTTP 版本（在本例中为 HTTP/1.1）、一个状态码（在本例中为 200）和一个对应于状态码的短消息（在本例中为 OK）。</p>
<p>下表总结了从 Web 服务器端返回到浏览器的最有用的 HTTP 1.1 响应报头，您会在 Web 编程中频繁地使用它们：</p>
<table>
<thead>
<tr>
<th align="left">头信息</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Allow</td>
<td align="left">这个头信息指定服务器支持的请求方法（GET、POST 等）。</td>
</tr>
<tr>
<td align="left">Cache-Control</td>
<td align="left">这个头信息指定响应文档在何种情况下可以安全地缓存。可能的值有：<strong>public、private</strong> 或 <strong>no-cache</strong> 等。Public 意味着文档是可缓存，Private 意味着文档是单个用户私用文档，且只能存储在私有（非共享）缓存中，no-cache 意味着文档不应被缓存。</td>
</tr>
<tr>
<td align="left">Connection</td>
<td align="left">这个头信息指示浏览器是否使用持久 HTTP 连接。值 <strong>close</strong> 指示浏览器不使用持久 HTTP 连接，值 <strong>keep-alive</strong> 意味着使用持久连接。</td>
</tr>
<tr>
<td align="left">Content-Disposition</td>
<td align="left">这个头信息可以让您请求浏览器要求用户以给定名称的文件把响应保存到磁盘。</td>
</tr>
<tr>
<td align="left">Content-Encoding</td>
<td align="left">在传输过程中，这个头信息指定页面的编码方式。</td>
</tr>
<tr>
<td align="left">Content-Language</td>
<td align="left">这个头信息表示文档编写所使用的语言。例如，en、en-us、ru 等。</td>
</tr>
<tr>
<td align="left">Content-Length</td>
<td align="left">这个头信息指示响应中的字节数。只有当浏览器使用持久（keep-alive）HTTP 连接时才需要这些信息。</td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">这个头信息提供了响应文档的 MIME（Multipurpose Internet Mail Extension）类型。</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">这个头信息指定内容过期的时间，在这之后内容不再被缓存。</td>
</tr>
<tr>
<td align="left">Last-Modified</td>
<td align="left">这个头信息指示文档的最后修改时间。然后，客户端可以缓存文件，并在以后的请求中通过 <strong>If-Modified-Since</strong> 请求头信息提供一个日期。</td>
</tr>
<tr>
<td align="left">Location</td>
<td align="left">这个头信息应被包含在所有的带有状态码的响应中。在 300s 内，这会通知浏览器文档的地址。浏览器会自动重新连接到这个位置，并获取新的文档。</td>
</tr>
<tr>
<td align="left">Refresh</td>
<td align="left">这个头信息指定浏览器应该如何尽快请求更新的页面。您可以指定页面刷新的秒数。</td>
</tr>
<tr>
<td align="left">Retry-After</td>
<td align="left">这个头信息可以与 503（Service Unavailable 服务不可用）响应配合使用，这会告诉客户端多久就可以重复它的请求。</td>
</tr>
<tr>
<td align="left">Set-Cookie</td>
<td align="left">这个头信息指定一个与页面关联的 cookie。</td>
</tr>
</tbody></table>
<h3 id="🍁设置-HTTP-响应报头的方法"><a href="#🍁设置-HTTP-响应报头的方法" class="headerlink" title="🍁设置 HTTP 响应报头的方法"></a>🍁设置 HTTP 响应报头的方法</h3><p>下面的方法可用于在 Servlet 程序中设置 HTTP 响应报头。这些方法通过 <em>HttpServletResponse</em> 对象可用。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>String encodeRedirectURL(String url)</strong> 为 sendRedirect 方法中使用的指定的 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>String encodeURL(String url)</strong> 对包含 session 会话 ID 的指定 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>boolean containsHeader(String name)</strong> 返回一个布尔值，指示是否已经设置已命名的响应报头。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>boolean isCommitted()</strong> 返回一个布尔值，指示响应是否已经提交。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>void addCookie(Cookie cookie)</strong> 把指定的 cookie 添加到响应。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>void addDateHeader(String name, long date)</strong> 添加一个带有给定的名称和日期值的响应报头。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>void addHeader(String name, String value)</strong> 添加一个带有给定的名称和值的响应报头。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>void addIntHeader(String name, int value)</strong> 添加一个带有给定的名称和整数值的响应报头。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>void flushBuffer()</strong> 强制任何在缓冲区中的内容被写入到客户端。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>void reset()</strong> 清除缓冲区中存在的任何数据，包括状态码和头。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>void resetBuffer()</strong> 清除响应中基础缓冲区的内容，不清除状态码和头。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>void sendError(int sc)</strong> 使用指定的状态码发送错误响应到客户端，并清除缓冲区。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>void sendError(int sc, String msg)</strong> 使用指定的状态发送错误响应到客户端。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><strong>void sendRedirect(String location)</strong> 使用指定的重定向位置 URL 发送临时重定向响应到客户端。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><strong>void setBufferSize(int size)</strong> 为响应主体设置首选的缓冲区大小。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><strong>void setCharacterEncoding(String charset)</strong> 设置被发送到客户端的响应的字符编码（MIME 字符集）例如，UTF-8。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><strong>void setContentLength(int len)</strong> 设置在 HTTP Servlet 响应中的内容主体的长度，该方法设置 HTTP Content-Length 头。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><strong>void setContentType(String type)</strong> 如果响应还未被提交，设置被发送到客户端的响应的内容类型。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><strong>void setDateHeader(String name, long date)</strong> 设置一个带有给定的名称和日期值的响应报头。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><strong>void setHeader(String name, String value)</strong> 设置一个带有给定的名称和值的响应报头。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><strong>void setIntHeader(String name, int value)</strong> 设置一个带有给定的名称和整数值的响应报头。</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><strong>void setLocale(Locale loc)</strong> 如果响应还未被提交，设置响应的区域。</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left"><strong>void setStatus(int sc)</strong> 为该响应设置状态码。</td>
</tr>
</tbody></table>
<h3 id="🍁HTTP-Header-响应实例"><a href="#🍁HTTP-Header-响应实例" class="headerlink" title="🍁HTTP Header 响应实例"></a>🍁HTTP Header 响应实例</h3><p>您已经在前面的实例中看到 setContentType() 方法，下面的实例也使用了同样的方法，此外，我们会用 <strong>setIntHeader()</strong> 方法来设置 <strong>Refresh</strong> 头。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//导入必需的 java 库</span></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/Refresh"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展 HttpServlet 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Refresh</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 GET 方法请求的方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                        HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">      </span>{</span><br><span class="line">          <span class="comment">// 设置刷新自动加载时间为 5 秒</span></span><br><span class="line">          response.setIntHeader(<span class="string">"Refresh"</span>, <span class="number">5</span>);</span><br><span class="line">          <span class="comment">// 设置响应内容类型</span></span><br><span class="line">          response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">         </span><br><span class="line">          <span class="comment">//使用默认时区和语言环境获得一个日历  </span></span><br><span class="line">          Calendar cale = Calendar.getInstance();  </span><br><span class="line">          <span class="comment">//将Calendar类型转换成Date类型  </span></span><br><span class="line">          Date tasktime=cale.getTime();  </span><br><span class="line">          <span class="comment">//设置日期输出的格式  </span></span><br><span class="line">          SimpleDateFormat df=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);  </span><br><span class="line">          <span class="comment">//格式化输出  </span></span><br><span class="line">          String nowTime = df.format(tasktime);</span><br><span class="line">          PrintWriter out = response.getWriter();</span><br><span class="line">          String title = <span class="string">"自动刷新 Header 设置 - 云澈实例"</span>;</span><br><span class="line">          String docType =</span><br><span class="line">          <span class="string">"&lt;!DOCTYPE html&gt;\n"</span>;</span><br><span class="line">          out.println(docType +</span><br><span class="line">            <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span>+</span><br><span class="line">            <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;p&gt;当前时间是："</span> + nowTime + <span class="string">"&lt;/p&gt;\n"</span>);</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 处理 POST 方法请求的方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                         HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">         doGet(request, response);</span><br><span class="line">      }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上测试实例是位于 TomcatTest 项目下，对应的 web.xml 配置为：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">     <span class="comment">&lt;!-- 类名 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Refresh<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 所在的包 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.runoob.test.Refresh<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Refresh<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 访问的网址 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/TomcatTest/Refresh<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>现在，调用上面的 Servlet，每隔 5 秒会显示当前系统时间。只要运行 Servlet 并稍等片刻，即可看到如下的结果：</p>
<p><a href="https://imgchr.com/i/wPwqQP" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/03/wPwqQP.png" alt="wPwqQP.png"></a></p>
<h2 id="🌸Servlet-HTTP-状态码"><a href="#🌸Servlet-HTTP-状态码" class="headerlink" title="🌸Servlet HTTP 状态码"></a>🌸Servlet HTTP 状态码</h2><p>HTTP 请求和 HTTP 响应消息的格式是类似的，结构如下：</p>
<ul>
<li>初始状态行 + 回车换行符（回车+换行）</li>
<li>零个或多个标题行+回车换行符</li>
<li>一个空白行，即回车换行符</li>
<li>一个可选的消息主体，比如文件、查询数据或查询输出</li>
</ul>
<p>例如，服务器的响应头如下所示：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Header2: ...</span><br><span class="line">...</span><br><span class="line">HeaderN: ...</span><br><span class="line">  (Blank Line)</span><br><span class="line"><span class="meta">&lt;!doctype ...&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>...<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>状态行包括 HTTP 版本（在本例中为 HTTP/1.1）、一个状态码（在本例中为 200）和一个对应于状态码的短消息（在本例中为 OK）。</p>
<p>以下是可能从 Web 服务器返回的 HTTP 状态码和相关的信息列表：</p>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">消息</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100</td>
<td align="left">Continue</td>
<td align="left">只有请求的一部分已经被服务器接收，但只要它没有被拒绝，客户端应继续该请求。</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">Switching Protocols</td>
<td align="left">服务器切换协议。</td>
</tr>
<tr>
<td align="left">200</td>
<td align="left">OK</td>
<td align="left">请求成功。</td>
</tr>
<tr>
<td align="left">201</td>
<td align="left">Created</td>
<td align="left">该请求是完整的，并创建一个新的资源。</td>
</tr>
<tr>
<td align="left">202</td>
<td align="left">Accepted</td>
<td align="left">该请求被接受处理，但是该处理是不完整的。</td>
</tr>
<tr>
<td align="left">203</td>
<td align="left">Non-authoritative Information</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">204</td>
<td align="left">No Content</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">205</td>
<td align="left">Reset Content</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">206</td>
<td align="left">Partial Content</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">300</td>
<td align="left">Multiple Choices</td>
<td align="left">链接列表。用户可以选择一个链接，进入到该位置。最多五个地址。</td>
</tr>
<tr>
<td align="left">301</td>
<td align="left">Moved Permanently</td>
<td align="left">所请求的页面已经转移到一个新的 URL。</td>
</tr>
<tr>
<td align="left">302</td>
<td align="left">Found</td>
<td align="left">所请求的页面已经临时转移到一个新的 URL。</td>
</tr>
<tr>
<td align="left">303</td>
<td align="left">See Other</td>
<td align="left">所请求的页面可以在另一个不同的 URL 下被找到。</td>
</tr>
<tr>
<td align="left">304</td>
<td align="left">Not Modified</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">305</td>
<td align="left">Use Proxy</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">306</td>
<td align="left"><em>Unused</em></td>
<td align="left">在以前的版本中使用该代码。现在已不再使用它，但代码仍被保留。</td>
</tr>
<tr>
<td align="left">307</td>
<td align="left">Temporary Redirect</td>
<td align="left">所请求的页面已经临时转移到一个新的 URL。</td>
</tr>
<tr>
<td align="left">400</td>
<td align="left">Bad Request</td>
<td align="left">服务器不理解请求。</td>
</tr>
<tr>
<td align="left">401</td>
<td align="left">Unauthorized</td>
<td align="left">所请求的页面需要用户名和密码。</td>
</tr>
<tr>
<td align="left">402</td>
<td align="left">Payment Required</td>
<td align="left"><em>您还不能使用该代码。</em></td>
</tr>
<tr>
<td align="left">403</td>
<td align="left">Forbidden</td>
<td align="left">禁止访问所请求的页面。</td>
</tr>
<tr>
<td align="left">404</td>
<td align="left">Not Found</td>
<td align="left">服务器无法找到所请求的页面。.</td>
</tr>
<tr>
<td align="left">405</td>
<td align="left">Method Not Allowed</td>
<td align="left">在请求中指定的方法是不允许的。</td>
</tr>
<tr>
<td align="left">406</td>
<td align="left">Not Acceptable</td>
<td align="left">服务器只生成一个不被客户端接受的响应。</td>
</tr>
<tr>
<td align="left">407</td>
<td align="left">Proxy Authentication Required</td>
<td align="left">在请求送达之前，您必须使用代理服务器的验证。</td>
</tr>
<tr>
<td align="left">408</td>
<td align="left">Request Timeout</td>
<td align="left">请求需要的时间比服务器能够等待的时间长，超时。</td>
</tr>
<tr>
<td align="left">409</td>
<td align="left">Conflict</td>
<td align="left">请求因为冲突无法完成。</td>
</tr>
<tr>
<td align="left">410</td>
<td align="left">Gone</td>
<td align="left">所请求的页面不再可用。</td>
</tr>
<tr>
<td align="left">411</td>
<td align="left">Length Required</td>
<td align="left">“Content-Length” 未定义。服务器无法处理客户端发送的不带 Content-Length 的请求信息。</td>
</tr>
<tr>
<td align="left">412</td>
<td align="left">Precondition Failed</td>
<td align="left">请求中给出的先决条件被服务器评估为 false。</td>
</tr>
<tr>
<td align="left">413</td>
<td align="left">Request Entity Too Large</td>
<td align="left">服务器不接受该请求，因为请求实体过大。</td>
</tr>
<tr>
<td align="left">414</td>
<td align="left">Request-url Too Long</td>
<td align="left">服务器不接受该请求，因为 URL 太长。当您转换一个 “post” 请求为一个带有长的查询信息的 “get” 请求时发生。</td>
</tr>
<tr>
<td align="left">415</td>
<td align="left">Unsupported Media Type</td>
<td align="left">服务器不接受该请求，因为媒体类型不被支持。</td>
</tr>
<tr>
<td align="left">417</td>
<td align="left">Expectation Failed</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">500</td>
<td align="left">Internal Server Error</td>
<td align="left">未完成的请求。服务器遇到了一个意外的情况。</td>
</tr>
<tr>
<td align="left">501</td>
<td align="left">Not Implemented</td>
<td align="left">未完成的请求。服务器不支持所需的功能。</td>
</tr>
<tr>
<td align="left">502</td>
<td align="left">Bad Gateway</td>
<td align="left">未完成的请求。服务器从上游服务器收到无效响应。</td>
</tr>
<tr>
<td align="left">503</td>
<td align="left">Service Unavailable</td>
<td align="left">未完成的请求。服务器暂时超载或死机。</td>
</tr>
<tr>
<td align="left">504</td>
<td align="left">Gateway Timeout</td>
<td align="left">网关超时。</td>
</tr>
<tr>
<td align="left">505</td>
<td align="left">HTTP Version Not Supported</td>
<td align="left">服务器不支持”HTTP协议”版本。### 🍁HTTP 请求和 HTTP 响应消息的格式是类似的，结构如下：</td>
</tr>
</tbody></table>
<h3 id="🍁设置-HTTP-状态代码的方法"><a href="#🍁设置-HTTP-状态代码的方法" class="headerlink" title="🍁设置 HTTP 状态代码的方法"></a>🍁设置 HTTP 状态代码的方法</h3><p>下面的方法可用于在 Servlet 程序中设置 HTTP 状态码。这些方法通过 <em>HttpServletResponse</em> 对象可用。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public void setStatus ( int statusCode )</strong> 该方法设置一个任意的状态码。setStatus 方法接受一个 int（状态码）作为参数。如果您的响应包含了一个特殊的状态码和文档，请确保在使用 <em>PrintWriter</em> 实际返回任何内容之前调用 setStatus。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>public void sendRedirect(String url)</strong> 该方法生成一个 302 响应，连同一个带有新文档 URL 的 <em>Location</em> 头。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public void sendError(int code, String message)</strong> 该方法发送一个状态码（通常为 404），连同一个在 HTML 文档内部自动格式化并发送到客户端的短消息。</td>
</tr>
</tbody></table>
<h3 id="🍁HTTP-状态码实例"><a href="#🍁HTTP-状态码实例" class="headerlink" title="🍁HTTP 状态码实例"></a>🍁HTTP 状态码实例</h3><p>下面的例子把 407 错误代码发送到客户端浏览器，浏览器会显示 “Need authentication!!!” 消息。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 导入必需的 java 库</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/showError"</span>)</span><br><span class="line"><span class="comment">// 扩展 HttpServlet 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">showError</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 处理 GET 方法请求的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                    HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">      <span class="comment">// 设置错误代码和原因</span></span><br><span class="line">      response.sendError(<span class="number">407</span>, <span class="string">"Need authentication!!!"</span> );</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 处理 POST 方法请求的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                     HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">     doGet(request, response);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在，调用上面的 Servlet 将显示以下结果：</p>
<p><a href="https://imgchr.com/i/wPro0f" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/03/wPro0f.png" alt="wPro0f.png"></a></p>
<hr>
<h2 id="🌸Servlet-编写过滤器"><a href="#🌸Servlet-编写过滤器" class="headerlink" title="🌸Servlet 编写过滤器"></a>🌸Servlet 编写过滤器</h2><p>Servlet 过滤器可以动态地拦截请求和响应，以变换或使用包含在请求或响应中的信息。</p>
<p>可以将一个或多个 Servlet 过滤器附加到一个 Servlet 或一组 Servlet。Servlet 过滤器也可以附加到 JavaServer Pages (JSP) 文件和 HTML 页面。调用 Servlet 前调用所有附加的 Servlet 过滤器。</p>
<p>Servlet 过滤器是可用于 Servlet 编程的 Java 类，可以实现以下目的：</p>
<ul>
<li>在客户端的请求访问后端资源之前，拦截这些请求。</li>
<li>在服务器的响应发送回客户端之前，处理这些响应。</li>
</ul>
<p>根据规范建议的各种类型的过滤器：</p>
<ul>
<li>身份验证过滤器（Authentication Filters）。</li>
<li>数据压缩过滤器（Data compression Filters）。</li>
<li>加密过滤器（Encryption Filters）。</li>
<li>触发资源访问事件过滤器。</li>
<li>图像转换过滤器（Image Conversion Filters）。</li>
<li>日志记录和审核过滤器（Logging and Auditing Filters）。</li>
<li>MIME-TYPE 链过滤器（MIME-TYPE Chain Filters）。</li>
<li>标记化过滤器（Tokenizing Filters）。</li>
<li>XSL/T 过滤器（XSL/T Filters），转换 XML 内容。</li>
</ul>
<p>过滤器通过 Web 部署描述符（web.xml）中的 XML 标签来声明，然后映射到您的应用程序的部署描述符中的 Servlet 名称或 URL 模式。</p>
<p>当 Web 容器启动 Web 应用程序时，它会为您在部署描述符中声明的每一个过滤器创建一个实例。</p>
<p>Filter的执行顺序与在web.xml配置文件中的配置顺序一致，一般把Filter配置在所有的Servlet之前。</p>
<h3 id="🍁Servlet-过滤器方法"><a href="#🍁Servlet-过滤器方法" class="headerlink" title="🍁Servlet 过滤器方法"></a>🍁Servlet 过滤器方法</h3><p>过滤器是一个实现了 javax.servlet.Filter 接口的 Java 类。javax.servlet.Filter 接口定义了三个方法：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public void doFilter (ServletRequest, ServletResponse, FilterChain)</strong> 该方法完成实际的过滤操作，当客户端请求方法与过滤器设置匹配的URL时，Servlet容器将先调用过滤器的doFilter方法。FilterChain用户访问后续过滤器。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>public void init(FilterConfig filterConfig)</strong> web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public void destroy()</strong> Servlet容器在销毁过滤器实例前调用该方法，在该方法中释放Servlet过滤器占用的资源。</td>
</tr>
</tbody></table>
<h3 id="🍁FilterConfig-使用"><a href="#🍁FilterConfig-使用" class="headerlink" title="🍁FilterConfig 使用"></a>🍁FilterConfig 使用</h3><p>Filter 的 init 方法中提供了一个 FilterConfig 对象。</p>
<p>如 web.xml 文件配置如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">com</span>.<span class="title">runoob</span>.<span class="title">test</span>.<span class="title">LogFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">Site</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">value</span>&gt;云澈&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>



<p>在 init 方法使用 FilterConfig 对象获取参数：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException </span>{</span><br><span class="line">    <span class="comment">// 获取初始化参数</span></span><br><span class="line">    String site = config.getInitParameter(<span class="string">"Site"</span>); </span><br><span class="line">    <span class="comment">// 输出初始化参数</span></span><br><span class="line">    System.out.println(<span class="string">"网站名称: "</span> + site); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁Servlet-过滤器实例"><a href="#🍁Servlet-过滤器实例" class="headerlink" title="🍁Servlet 过滤器实例"></a>🍁Servlet 过滤器实例</h3><p>以下是 Servlet 过滤器的实例，将输出网站名称和地址。本实例让您对 Servlet 过滤器有基本的了解，您可以使用相同的概念编写更复杂的过滤器应用程序：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException </span>{</span><br><span class="line">        <span class="comment">// 获取初始化参数</span></span><br><span class="line">        String site = config.getInitParameter(<span class="string">"Site"</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出初始化参数</span></span><br><span class="line">        System.out.println(<span class="string">"网站名称: "</span> + site); </span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> java.io.IOException, ServletException </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出站点名称</span></span><br><span class="line">        System.out.println(<span class="string">"站点网址：http://liudufu.github.io"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把请求传回过滤链</span></span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">( )</span></span>{</span><br><span class="line">        <span class="comment">/* 在 Filter 实例被 Web 容器从服务移除之前调用 */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这边使用前文提到的 DisplayHeader.java 为例子：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入必需的 java 库</span></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/DisplayHeader"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展 HttpServlet 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisplayHeader</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 GET 方法请求的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 设置响应内容类型</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = <span class="string">"HTTP Header 请求实例 - 云澈实例"</span>;</span><br><span class="line">        String docType =</span><br><span class="line">            <span class="string">"&lt;!DOCTYPE html&gt; \n"</span>;</span><br><span class="line">            out.println(docType +</span><br><span class="line">            <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span>+</span><br><span class="line">            <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;table width=\"100%\" border=\"1\" align=\"center\"&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;tr bgcolor=\"#949494\"&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;th&gt;Header 名称&lt;/th&gt;&lt;th&gt;Header 值&lt;/th&gt;\n"</span>+</span><br><span class="line">            <span class="string">"&lt;/tr&gt;\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">		Enumeration headerNames = request.getHeaderNames();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(headerNames.hasMoreElements()) {</span><br><span class="line">            String paramName = (String)headerNames.nextElement();</span><br><span class="line">            out.print(<span class="string">"&lt;tr&gt;&lt;td&gt;"</span> + paramName + <span class="string">"&lt;/td&gt;\n"</span>);</span><br><span class="line">            String paramValue = request.getHeader(paramName);</span><br><span class="line">            out.println(<span class="string">"&lt;td&gt; "</span> + paramValue + <span class="string">"&lt;/td&gt;&lt;/tr&gt;\n"</span>);</span><br><span class="line">        }</span><br><span class="line">        out.println(<span class="string">"&lt;/table&gt;\n&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 处理 POST 方法请求的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁Web-xml-中的-Servlet-过滤器映射（Servlet-Filter-Mapping）"><a href="#🍁Web-xml-中的-Servlet-过滤器映射（Servlet-Filter-Mapping）" class="headerlink" title="🍁Web.xml 中的 Servlet 过滤器映射（Servlet Filter Mapping）"></a>🍁Web.xml 中的 Servlet 过滤器映射（Servlet Filter Mapping）</h3><p>定义过滤器，然后映射到一个 URL 或 Servlet，这与定义 Servlet，然后映射到一个 URL 模式方式大致相同。在部署描述符文件 <strong>web.xml</strong> 中为 filter 标签创建下面的条目：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>LogFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.runoob.test.LogFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>Site<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>云澈<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>LogFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">  <span class="comment">&lt;!-- 类名 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DisplayHeader<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">  <span class="comment">&lt;!-- 所在的包 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.runoob.test.DisplayHeader<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DisplayHeader<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">  <span class="comment">&lt;!-- 访问的网址 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/TomcatTest/DisplayHeader<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>上述过滤器适用于所有的 Servlet，因为我们在配置中指定 <strong>/*</strong> 。如果您只想在少数的 Servlet 上应用过滤器，您可以指定一个特定的 Servlet 路径。</p>
<p>现在试着以常用的方式调用任何 Servlet，您将会看到在 Web 服务器中生成的日志。您也可以使用 Log4J 记录器来把上面的日志记录到一个单独的文件中。</p>
<p>接下来我们访问这个实例地址 <strong><a href="http://localhost:8080/TomcatTest/DisplayHeader" target="_blank" rel="noopener">http://localhost:8080/TomcatTest/DisplayHeader</a></strong>, 然后在控制台看下输出内容，如下所示：</p>
<p><a href="https://imgchr.com/i/0UGZTg" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/06/0UGZTg.png" alt="0UGZTg.png"></a></p>
<h3 id="🍁使用多个过滤器"><a href="#🍁使用多个过滤器" class="headerlink" title="🍁使用多个过滤器"></a>🍁使用多个过滤器</h3><p>Web 应用程序可以根据特定的目的定义若干个不同的过滤器。假设您定义了两个过滤器 <em>AuthenFilter</em> 和 <em>LogFilter</em>。您需要创建一个如下所述的不同的映射，其余的处理与上述所讲解的大致相同：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>LogFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.runoob.test.LogFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>test-param<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>Initialization Paramter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>AuthenFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.runoob.test.AuthenFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>test-param<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>Initialization Paramter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>LogFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>AuthenFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁过滤器的应用顺序"><a href="#🍁过滤器的应用顺序" class="headerlink" title="🍁过滤器的应用顺序"></a>🍁过滤器的应用顺序</h3><p>web.xml 中的 filter-mapping 元素的顺序决定了 Web 容器应用过滤器到 Servlet 的顺序。若要反转过滤器的顺序，您只需要在 web.xml 文件中反转 filter-mapping 元素即可。</p>
<p>例如，上面的实例将先应用 LogFilter，然后再应用 AuthenFilter，但是下面的实例将颠倒这个顺序：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>AuthenFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>LogFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="🍁web-xml配置各节点说明"><a href="#🍁web-xml配置各节点说明" class="headerlink" title="🍁web.xml配置各节点说明"></a>🍁web.xml配置各节点说明</h3><ul>
<li><code>&lt;filter&gt;</code>指定一个过滤器。<ul>
<li><code>&lt;filter-name&gt;</code>用于为过滤器指定一个名字，该元素的内容不能为空。</li>
<li><code>&lt;filter-class&gt;</code>元素用于指定过滤器的完整的限定类名。</li>
<li><code>&lt;init-param&gt;</code>元素用于为过滤器指定初始化参数，它的子元素<code>&lt;param-name&gt;</code>指定参数的名字，<code>&lt;param-value&gt;</code>指定参数的值。</li>
<li>在过滤器中，可以使用<code>FilterConfig</code>接口对象来访问初始化参数。</li>
</ul>
</li>
<li><code>&lt;filter-mapping&gt;</code>元素用于设置一个 Filter 所负责拦截的资源。一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径<ul>
<li><code>&lt;filter-name&gt;</code>子元素用于设置filter的注册名称。该值必须是在<code>&lt;filter&gt;</code>元素中声明过的过滤器的名字</li>
<li><code>&lt;url-pattern&gt;</code>设置 filter 所拦截的请求路径(过滤器关联的URL样式)</li>
</ul>
</li>
<li><code>&lt;servlet-name&gt;</code>指定过滤器所拦截的Servlet名称。</li>
<li><code>&lt;dispatcher&gt;</code>指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是<code>REQUEST</code>,<code>INCLUDE</code>,<code>FORWARD</code>和<code>ERROR</code>之一，默认<code>REQUEST</code>。用户可以设置多个<code>&lt;dispatcher&gt;</code>子元素用来指定 Filter 对资源的多种调用方式进行拦截。</li>
<li><code>&lt;dispatcher&gt;</code>子元素可以设置的值及其意义<ul>
<li><code>REQUEST</code>：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过<code>RequestDispatcher</code>的include()或forward()方法访问时，那么该过滤器就不会被调用。</li>
<li><code>INCLUDE</code>：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。</li>
<li><code>FORWARD</code>：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。</li>
<li><code>ERROR</code>：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。</li>
</ul>
</li>
</ul>
<h2 id="🌸Servlet-异常处理"><a href="#🌸Servlet-异常处理" class="headerlink" title="🌸Servlet 异常处理"></a>🌸Servlet 异常处理</h2><p>当一个 Servlet 抛出一个异常时，Web 容器在使用了 exception-type 元素的 <strong>web.xml</strong> 中搜索与抛出异常类型相匹配的配置。</p>
<p>您必须在 web.xml 中使用 <strong>error-page</strong> 元素来指定对特定<strong>异常</strong> 或 HTTP <strong>状态码</strong> 作出相应的 Servlet 调用。</p>
<h3 id="🍁web-xml-配置"><a href="#🍁web-xml-配置" class="headerlink" title="🍁web.xml 配置"></a>🍁web.xml 配置</h3><p>假设，有一个 <em>ErrorHandler</em> 的 Servlet 在任何已定义的异常或错误出现时被调用。以下将是在 web.xml 中创建的项。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!-- servlet 定义 --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;ErrorHandler&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">ErrorHandler</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class">&lt;!-- <span class="title">servlet</span> 映射 --&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">ErrorHandler</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/<span class="title">ErrorHandler</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;!-- <span class="title">error</span>-<span class="title">code</span> 相关的错误页面 --&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">error</span>-<span class="title">page</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">error</span>-<span class="title">code</span>&gt;404&lt;/<span class="title">error</span>-<span class="title">code</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">location</span>&gt;/<span class="title">ErrorHandler</span>&lt;/<span class="title">location</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">error</span>-<span class="title">page</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">error</span>-<span class="title">page</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">error</span>-<span class="title">code</span>&gt;403&lt;/<span class="title">error</span>-<span class="title">code</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">location</span>&gt;/<span class="title">ErrorHandler</span>&lt;/<span class="title">location</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">error</span>-<span class="title">page</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;!-- <span class="title">exception</span>-<span class="title">type</span> 相关的错误页面 --&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">error</span>-<span class="title">page</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">exception</span>-<span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class">          <span class="title">javax</span>.<span class="title">servlet</span>.<span class="title">ServletException</span></span></span><br><span class="line"><span class="class">    &lt;/<span class="title">exception</span>-<span class="title">type</span> &gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">location</span>&gt;/<span class="title">ErrorHandler</span>&lt;/<span class="title">location</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">error</span>-<span class="title">page</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;<span class="title">error</span>-<span class="title">page</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">exception</span>-<span class="title">type</span>&gt;<span class="title">java</span>.<span class="title">io</span>.<span class="title">IOException</span>&lt;/<span class="title">exception</span>-<span class="title">type</span> &gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">location</span>&gt;/<span class="title">ErrorHandler</span>&lt;/<span class="title">location</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">error</span>-<span class="title">page</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果您想对所有的异常有一个通用的错误处理程序，那么应该定义下面的 error-page，而不是为每个异常定义单独的 error-page 元素：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exception-type</span>&gt;</span>java.lang.Throwable<span class="tag">&lt;/<span class="name">exception-type</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/ErrorHandler<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>以下是关于上面的 web.xml 异常处理要注意的点：</p>
<ul>
<li>Servlet ErrorHandler 与其他的 Servlet 的定义方式一样，且在 web.xml 中进行配置。</li>
<li>如果有错误状态代码出现，不管为 404（Not Found 未找到）或 403（Forbidden 禁止），则会调用 ErrorHandler 的 Servlet。</li>
<li>如果 Web 应用程序抛出 <em>ServletException</em> 或 <em>IOException</em>，那么 Web 容器会调用 ErrorHandler 的 Servlet。</li>
<li>您可以定义不同的错误处理程序来处理不同类型的错误或异常。上面的实例是非常通用的，希望您能通过实例理解基本的概念。</li>
</ul>
<h3 id="🍁请求属性-错误-异常"><a href="#🍁请求属性-错误-异常" class="headerlink" title="🍁请求属性 - 错误/异常"></a>🍁请求属性 - 错误/异常</h3><p>以下是错误处理的 Servlet 可以访问的请求属性列表，用来分析错误/异常的性质。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">属性 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>javax.servlet.error.status_code</strong> 该属性给出状态码，状态码可被存储，并在存储为 java.lang.Integer 数据类型后可被分析。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>javax.servlet.error.exception_type</strong> 该属性给出异常类型的信息，异常类型可被存储，并在存储为 java.lang.Class 数据类型后可被分析。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>javax.servlet.error.message</strong> 该属性给出确切错误消息的信息，信息可被存储，并在存储为 java.lang.String 数据类型后可被分析。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>javax.servlet.error.request_uri</strong> 该属性给出有关 URL 调用 Servlet 的信息，信息可被存储，并在存储为 java.lang.String 数据类型后可被分析。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>javax.servlet.error.exception</strong> 该属性给出异常产生的信息，信息可被存储，并在存储为 java.lang.Throwable 数据类型后可被分析。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>javax.servlet.error.servlet_name</strong> 该属性给出 Servlet 的名称，名称可被存储，并在存储为 java.lang.String 数据类型后可被分析。</td>
</tr>
</tbody></table>
<h3 id="🍁Servlet-错误处理程序实例"><a href="#🍁Servlet-错误处理程序实例" class="headerlink" title="🍁Servlet 错误处理程序实例"></a>🍁Servlet 错误处理程序实例</h3><p>以下是 Servlet 实例，将应对任何您所定义的错误或异常发生时的错误处理程序。</p>
<p>本实例让您对 Servlet 中的异常处理有基本的了解，您可以使用相同的概念编写更复杂的异常处理应用程序：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入必需的 java 库</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="comment">//import java.util.*;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展 HttpServlet 类</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorHandler</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 GET 方法请求的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">      Throwable throwable = (Throwable)</span><br><span class="line">      request.getAttribute(<span class="string">"javax.servlet.error.exception"</span>);</span><br><span class="line">      Integer statusCode = (Integer)</span><br><span class="line">      request.getAttribute(<span class="string">"javax.servlet.error.status_code"</span>);</span><br><span class="line">      String servletName = (String)</span><br><span class="line">      request.getAttribute(<span class="string">"javax.servlet.error.servlet_name"</span>);</span><br><span class="line">      <span class="keyword">if</span> (servletName == <span class="keyword">null</span>){</span><br><span class="line">          servletName = <span class="string">"Unknown"</span>;</span><br><span class="line">      }</span><br><span class="line">      String requestUri = (String)</span><br><span class="line">      request.getAttribute(<span class="string">"javax.servlet.error.request_uri"</span>);</span><br><span class="line">      <span class="keyword">if</span> (requestUri == <span class="keyword">null</span>){</span><br><span class="line">          requestUri = <span class="string">"Unknown"</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 设置响应内容类型</span></span><br><span class="line">      response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">  </span><br><span class="line">      PrintWriter out = response.getWriter();</span><br><span class="line">      String title = <span class="string">"云澈Error/Exception 信息"</span>;</span><br><span class="line">     </span><br><span class="line">      String docType = <span class="string">"&lt;!DOCTYPE html&gt;\n"</span>;</span><br><span class="line">      out.println(docType +</span><br><span class="line">          <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">           <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">           <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span>);</span><br><span class="line">         out.println(<span class="string">"&lt;h1&gt;云澈异常信息实例演示&lt;/h1&gt;"</span>);</span><br><span class="line">         <span class="keyword">if</span> (throwable == <span class="keyword">null</span> &amp;&amp; statusCode == <span class="keyword">null</span>){</span><br><span class="line">            out.println(<span class="string">"&lt;h2&gt;错误信息丢失&lt;/h2&gt;"</span>);</span><br><span class="line">            out.println(<span class="string">"请返回 &lt;a href=\""</span> + </span><br><span class="line">          response.encodeURL(<span class="string">"http://localhost:8080/"</span>) + </span><br><span class="line">              <span class="string">"\"&gt;主页&lt;/a&gt;。"</span>);</span><br><span class="line">         }<span class="keyword">else</span> <span class="keyword">if</span> (statusCode != <span class="keyword">null</span>) {</span><br><span class="line">            out.println(<span class="string">"错误代码 : "</span> + statusCode);</span><br><span class="line">      }<span class="keyword">else</span>{</span><br><span class="line">             out.println(<span class="string">"&lt;h2&gt;错误信息&lt;/h2&gt;"</span>);</span><br><span class="line">            out.println(<span class="string">"Servlet Name : "</span> + servletName + </span><br><span class="line">                            <span class="string">"&lt;/br&gt;&lt;/br&gt;"</span>);</span><br><span class="line">            out.println(<span class="string">"异常类型 : "</span> + </span><br><span class="line">                            throwable.getClass( ).getName( ) + </span><br><span class="line">                            <span class="string">"&lt;/br&gt;&lt;/br&gt;"</span>);</span><br><span class="line">            out.println(<span class="string">"请求 URI: "</span> + requestUri + </span><br><span class="line">                            <span class="string">"&lt;br&gt;&lt;br&gt;"</span>);</span><br><span class="line">            out.println(<span class="string">"异常信息: "</span> + </span><br><span class="line">                                throwable.getMessage( ));</span><br><span class="line">         }</span><br><span class="line">         out.println(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">         out.println(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 处理 POST 方法请求的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                    HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">      doGet(request, response);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以通常的方式编译 <strong>ErrorHandler.java</strong>，把您的类文件放入<tomcat-installation-directory>/webapps/ROOT/WEB-INF/classes 中。</tomcat-installation-directory></p>
<p>让我们在 web.xml 文件中添加如下配置来处理异常：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ErrorHandler<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.runoob.test.ErrorHandler<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- servlet mappings --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ErrorHandler<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/TomcatTest/ErrorHandler<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/TomcatTest/ErrorHandler<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exception-type</span>&gt;</span>java.lang.Throwable<span class="tag">&lt;/<span class="name">exception-type</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/ErrorHandler<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>现在，尝试使用一个会产生异常的 Servlet，或者输入一个错误的 URL，这将触发 Web 容器调用 <strong>ErrorHandler</strong> 的 Servlet，并显示适当的消息。例如，如果您输入了一个错误的 URL（如：<a href="http://localhost:8080/TomcatTest/UnKonwPage），那么它将显示下面的结果：" target="_blank" rel="noopener">http://localhost:8080/TomcatTest/UnKonwPage），那么它将显示下面的结果：</a></p>
<p><a href="https://imgchr.com/i/0UNCE8" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/06/0UNCE8.png" alt="0UNCE8.png"></a></p>
<hr>
<h2 id="🌸Servlet-Cookie-处理"><a href="#🌸Servlet-Cookie-处理" class="headerlink" title="🌸Servlet  Cookie 处理"></a>🌸Servlet  Cookie 处理</h2><p>Cookie 是存储在客户端计算机上的文本文件，并保留了各种跟踪信息。Java Servlet 显然支持 HTTP Cookie。</p>
<p>识别返回用户包括三个步骤：</p>
<ul>
<li>服务器脚本向浏览器发送一组 Cookie。例如：姓名、年龄或识别号码等。</li>
<li>浏览器将这些信息存储在本地计算机上，以备将来使用。</li>
<li>当下一次浏览器向 Web 服务器发送任何请求时，浏览器会把这些 Cookie 信息发送到服务器，服务器将使用这些信息来识别用户。</li>
</ul>
<p>本章将向您讲解如何设置或重置 Cookie，如何访问它们，以及如何将它们删除。</p>
<p>Servlet Cookie 处理需要对中文进行编码与解码，方法如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">String   str   =   java.net.URLEncoder.encode(<span class="string">"中文"</span>，<span class="string">"UTF-8"</span>);            <span class="comment">//编码</span></span><br><span class="line">String   str   =   java.net.URLDecoder.decode(<span class="string">"编码后的字符串"</span>,<span class="string">"UTF-8"</span>);   <span class="comment">// 解码</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁Cookie-剖析"><a href="#🍁Cookie-剖析" class="headerlink" title="🍁Cookie 剖析"></a>🍁Cookie 剖析</h3><p>Cookie 通常设置在 HTTP 头信息中（虽然 JavaScript 也可以直接在浏览器上设置一个 Cookie）。设置 Cookie 的 Servlet 会发送如下的头信息：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Date: Fri, <span class="number">04</span> Feb <span class="number">2000</span> <span class="number">21</span>:<span class="number">03</span>:<span class="number">38</span> GMT</span><br><span class="line">Server: Apache/<span class="number">1.3</span><span class="number">.9</span> (UNIX) PHP/<span class="number">4.0</span>b3</span><br><span class="line">Set-Cookie: name=xyz; expires=Friday, <span class="number">04</span>-Feb-<span class="number">07</span> <span class="number">22</span>:<span class="number">03</span>:<span class="number">38</span> GMT; </span><br><span class="line">                 path=/; domain=runoob.com</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></tbody></table></figure>

<p>正如您所看到的，Set-Cookie 头包含了一个名称值对、一个 GMT 日期、一个路径和一个域。名称和值会被 URL 编码。expires 字段是一个指令，告诉浏览器在给定的时间和日期之后”忘记”该 Cookie。</p>
<p>如果浏览器被配置为存储 Cookie，它将会保留此信息直到到期日期。如果用户的浏览器指向任何匹配该 Cookie 的路径和域的页面，它会重新发送 Cookie 到服务器。浏览器的头信息可能如下所示：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">GET / HTTP/<span class="number">1.0</span></span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">4.6</span> (X11; I; Linux <span class="number">2.2</span><span class="number">.6</span><span class="number">-15</span>apmac ppc)</span><br><span class="line">Host: zink.demon.co.uk:<span class="number">1126</span></span><br><span class="line">Accept: image/gif, *<span class="comment">/*</span></span><br><span class="line"><span class="comment">Accept-Encoding: gzip</span></span><br><span class="line"><span class="comment">Accept-Language: en</span></span><br><span class="line"><span class="comment">Accept-Charset: iso-8859-1,*,utf-8</span></span><br><span class="line"><span class="comment">Cookie: name=xyz</span></span><br></pre></td></tr></tbody></table></figure>

<p>Servlet 就能够通过请求方法 <em>request.getCookies()</em> 访问 Cookie，该方法将返回一个 <em>Cookie</em> 对象的数组。</p>
<h3 id="🍁Servlet-Cookie-方法"><a href="#🍁Servlet-Cookie-方法" class="headerlink" title="🍁Servlet Cookie 方法"></a>🍁Servlet Cookie 方法</h3><p>以下是在 Servlet 中操作 Cookie 时可使用的有用的方法列表。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public void setDomain(String pattern)</strong> 该方法设置 cookie 适用的域，例如 runoob.com。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>public String getDomain()</strong> 该方法获取 cookie 适用的域，例如 runoob.com。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public void setMaxAge(int expiry)</strong> 该方法设置 cookie 过期的时间（以秒为单位）。如果不这样设置，cookie 只会在当前 session 会话中持续有效。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public int getMaxAge()</strong> 该方法返回 cookie 的最大生存周期（以秒为单位），默认情况下，-1 表示 cookie 将持续下去，直到浏览器关闭。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>public String getName()</strong> 该方法返回 cookie 的名称。名称在创建后不能改变。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>public void setValue(String newValue)</strong> 该方法设置与 cookie 关联的值。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>public String getValue()</strong> 该方法获取与 cookie 关联的值。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>public void setPath(String uri)</strong> 该方法设置 cookie 适用的路径。如果您不指定路径，与当前页面相同目录下的（包括子目录下的）所有 URL 都会返回 cookie。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>public String getPath()</strong> 该方法获取 cookie 适用的路径。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>public void setSecure(boolean flag)</strong> 该方法设置布尔值，表示 cookie 是否应该只在加密的（即 SSL）连接上发送。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>public void setComment(String purpose)</strong> 设置cookie的注释。该注释在浏览器向用户呈现 cookie 时非常有用。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>public String getComment()</strong> 获取 cookie 的注释，如果 cookie 没有注释则返回 null。</td>
</tr>
</tbody></table>
<h3 id="🍁通过-Servlet-设置-Cookie"><a href="#🍁通过-Servlet-设置-Cookie" class="headerlink" title="🍁通过 Servlet 设置 Cookie"></a>🍁通过 Servlet 设置 Cookie</h3><p>通过 Servlet 设置 Cookie 包括三个步骤：</p>
<p><strong>(1) 创建一个 Cookie 对象：</strong>您可以调用带有 cookie 名称和 cookie 值的 Cookie 构造函数，cookie 名称和 cookie 值都是字符串。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"key"</span>,<span class="string">"value"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>请记住，无论是名字还是值，都不应该包含空格或以下任何字符：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[ ] ( ) = , <span class="string">" / ? @ : ;</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>(2) 设置最大生存周期：</strong>您可以使用 setMaxAge 方法来指定 cookie 能够保持有效的时间（以秒为单位）。下面将设置一个最长有效期为 24 小时的 cookie。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">cookie.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>(3) 发送 Cookie 到 HTTP 响应头：</strong>您可以使用 <strong>response.addCookie</strong> 来添加 HTTP 响应头中的 Cookie，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></tbody></table></figure>



<h3 id="🍁实例"><a href="#🍁实例" class="headerlink" title="🍁实例"></a>🍁实例</h3><p>让我们修改我们的 <a href="">表单数据实例</a>，为名字和姓氏设置 Cookie。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class HelloServlet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/HelloForm"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloForm</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloForm</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 为名字和姓氏创建 Cookie      </span></span><br><span class="line">        Cookie name = <span class="keyword">new</span> Cookie(<span class="string">"name"</span>,</span><br><span class="line">                URLEncoder.encode(request.getParameter(<span class="string">"name"</span>), <span class="string">"UTF-8"</span>)); <span class="comment">// 中文转码</span></span><br><span class="line">        Cookie url = <span class="keyword">new</span> Cookie(<span class="string">"url"</span>,</span><br><span class="line">                      request.getParameter(<span class="string">"url"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为两个 Cookie 设置过期日期为 24 小时后</span></span><br><span class="line">        name.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>); </span><br><span class="line">        url.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在响应头中添加两个 Cookie</span></span><br><span class="line">        response.addCookie( name );</span><br><span class="line">        response.addCookie( url );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置响应内容类型</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        </span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = <span class="string">"设置 Cookie 实例"</span>;</span><br><span class="line">        String docType = <span class="string">"&lt;!DOCTYPE html&gt;\n"</span>;</span><br><span class="line">        out.println(docType +</span><br><span class="line">                <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;ul&gt;\n"</span> +</span><br><span class="line">                <span class="string">"  &lt;li&gt;&lt;b&gt;站点名：&lt;/b&gt;："</span></span><br><span class="line">                + request.getParameter(<span class="string">"name"</span>) + <span class="string">"\n&lt;/li&gt;"</span> +</span><br><span class="line">                <span class="string">"  &lt;li&gt;&lt;b&gt;站点 URL：&lt;/b&gt;："</span></span><br><span class="line">                + request.getParameter(<span class="string">"url"</span>) + <span class="string">"\n&lt;/li&gt;"</span> +</span><br><span class="line">                <span class="string">"&lt;/ul&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        doGet(request, response);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>编译上面的 Servlet <strong>HelloForm</strong>，并在 web.xml 文件中创建适当的条目:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 类名 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloForm<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 所在的包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.runoob.test.HelloForm<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloForm<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 访问的网址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/TomcatTest/HelloForm<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>最后尝试下面的 HTML 页面来调用 Servlet。</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>云澈<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/TomcatTest/HelloForm"</span> <span class="attr">method</span>=<span class="string">"GET"</span>&gt;</span></span><br><span class="line">站点名 ：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">站点 URL：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"url"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>保存上面的 HTML 内容到文件 /TomcatTest/test.html 中。</p>
<p>接下来我们访问<a href="http://localhost:8080/TomcatTest/test.html，如下：" target="_blank" rel="noopener">http://localhost:8080/TomcatTest/test.html，如下：</a></p>
<p><img src="https://s1.ax1x.com/2020/10/08/007Dl8.png" alt="007Dl8.png"></p>
<p><img src="https://s1.ax1x.com/2020/10/08/007WYq.png" alt="007WYq.png"></p>
<h3 id="🍁通过-Servlet-读取-Cookie"><a href="#🍁通过-Servlet-读取-Cookie" class="headerlink" title="🍁通过 Servlet 读取 Cookie"></a>🍁通过 Servlet 读取 Cookie</h3><p>要读取 Cookie，您需要通过调用 <em>HttpServletRequest</em> 的 <strong>getCookies( )</strong> 方法创建一个 <em>javax.servlet.http.Cookie</em> 对象的数组。然后循环遍历数组，并使用 getName() 和 getValue() 方法来访问每个 cookie 和关联的值。</p>
<h4 id="🍂-实例"><a href="#🍂-实例" class="headerlink" title="🍂 实例"></a>🍂 实例</h4><p>让我们读取上面的实例中设置的 Cookie</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class ReadCookies</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/ReadCookies"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadCookies</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadCookies</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        Cookie cookie = <span class="keyword">null</span>;</span><br><span class="line">        Cookie[] cookies = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 获取与该域相关的 Cookie 的数组</span></span><br><span class="line">        cookies = request.getCookies();</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 设置响应内容类型</span></span><br><span class="line">         response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">    </span><br><span class="line">         PrintWriter out = response.getWriter();</span><br><span class="line">         String title = <span class="string">"Delete Cookie Example"</span>;</span><br><span class="line">         String docType = <span class="string">"&lt;!DOCTYPE html&gt;\n"</span>;</span><br><span class="line">         out.println(docType +</span><br><span class="line">                   <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">                   <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">                   <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> );</span><br><span class="line">          <span class="keyword">if</span>( cookies != <span class="keyword">null</span> ){</span><br><span class="line">            out.println(<span class="string">"&lt;h2&gt;Cookie 名称和值&lt;/h2&gt;"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cookies.length; i++){</span><br><span class="line">               cookie = cookies[i];</span><br><span class="line">               <span class="keyword">if</span>((cookie.getName( )).compareTo(<span class="string">"name"</span>) == <span class="number">0</span> ){</span><br><span class="line">                    cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">                    response.addCookie(cookie);</span><br><span class="line">                    out.print(<span class="string">"已删除的 cookie："</span> + </span><br><span class="line">                                 cookie.getName( ) + <span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line">               }</span><br><span class="line">               out.print(<span class="string">"名称："</span> + cookie.getName( ) + <span class="string">"，"</span>);</span><br><span class="line">               out.print(<span class="string">"值："</span> +  URLDecoder.decode(cookie.getValue(), <span class="string">"utf-8"</span>) +<span class="string">" &lt;br/&gt;"</span>);</span><br><span class="line">            }</span><br><span class="line">         }<span class="keyword">else</span>{</span><br><span class="line">             out.println(</span><br><span class="line">               <span class="string">"&lt;h2 class=\"tutheader\"&gt;No Cookie founds&lt;/h2&gt;"</span>);</span><br><span class="line">         }</span><br><span class="line">         out.println(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">         out.println(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        doGet(request, response);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁通过-Servlet-删除-Cookie"><a href="#🍁通过-Servlet-删除-Cookie" class="headerlink" title="🍁通过 Servlet 删除 Cookie"></a>🍁通过 Servlet 删除 Cookie</h3><p>删除 Cookie 是非常简单的。如果您想删除一个 cookie，那么您只需要按照以下三个步骤进行：</p>
<ul>
<li>读取一个现有的 cookie，并把它存储在 Cookie 对象中。</li>
<li>使用 <strong>setMaxAge()</strong> 方法设置 cookie 的年龄为零，来删除现有的 cookie。</li>
<li>把这个 cookie 添加到响应头。</li>
</ul>
<h4 id="🍂实例"><a href="#🍂实例" class="headerlink" title="🍂实例"></a>🍂实例</h4><p>下面的例子将删除现有的名为 “url” 的 cookie，当您下次运行 ReadCookies 的 Servlet 时，它会返回 url 为 null。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class DeleteCookies</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/DeleteCookies"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteCookies</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeleteCookies</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        Cookie cookie = <span class="keyword">null</span>;</span><br><span class="line">        Cookie[] cookies = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 获取与该域相关的 Cookie 的数组</span></span><br><span class="line">        cookies = request.getCookies();</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 设置响应内容类型</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">   </span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = <span class="string">"删除 Cookie 实例"</span>;</span><br><span class="line">        String docType = <span class="string">"&lt;!DOCTYPE html&gt;\n"</span>;</span><br><span class="line">        out.println(docType +</span><br><span class="line">                  <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">                  <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">                  <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> );</span><br><span class="line">         <span class="keyword">if</span>( cookies != <span class="keyword">null</span> ){</span><br><span class="line">           out.println(<span class="string">"&lt;h2&gt;Cookie 名称和值&lt;/h2&gt;"</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cookies.length; i++){</span><br><span class="line">              cookie = cookies[i];</span><br><span class="line">              <span class="keyword">if</span>((cookie.getName( )).compareTo(<span class="string">"url"</span>) == <span class="number">0</span> ){</span><br><span class="line">                   cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">                   response.addCookie(cookie);</span><br><span class="line">                   out.print(<span class="string">"已删除的 cookie："</span> + </span><br><span class="line">                                cookie.getName( ) + <span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line">              }</span><br><span class="line">              out.print(<span class="string">"名称："</span> + cookie.getName( ) + <span class="string">"，"</span>);</span><br><span class="line">              out.print(<span class="string">"值："</span> + cookie.getValue( )+<span class="string">" &lt;br/&gt;"</span>);</span><br><span class="line">           }</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            out.println(</span><br><span class="line">              <span class="string">"&lt;h2 class=\"tutheader\"&gt;No Cookie founds&lt;/h2&gt;"</span>);</span><br><span class="line">        }</span><br><span class="line">        out.println(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        out.println(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        doGet(request, response);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸Servlet-Session-跟踪"><a href="#🌸Servlet-Session-跟踪" class="headerlink" title="🌸Servlet Session 跟踪"></a>🌸Servlet Session 跟踪</h2><p>HTTP 是一种”无状态”协议，这意味着每次客户端检索网页时，客户端打开一个单独的连接到 Web 服务器，服务器会自动不保留之前客户端请求的任何记录。</p>
<p>但是仍然有以下三种方式来维持 Web 客户端和 Web 服务器之间的 session 会话：</p>
<h3 id="🍁Cookies"><a href="#🍁Cookies" class="headerlink" title="🍁Cookies"></a>🍁Cookies</h3><p>一个 Web 服务器可以分配一个唯一的 session 会话 ID 作为每个 Web 客户端的 cookie，对于客户端的后续请求可以使用接收到的 cookie 来识别。</p>
<p>这可能不是一个有效的方法，因为很多浏览器不支持 cookie，所以我们建议不要使用这种方式来维持 session 会话。</p>
<h3 id="🍁隐藏的表单字段"><a href="#🍁隐藏的表单字段" class="headerlink" title="🍁隐藏的表单字段"></a>🍁隐藏的表单字段</h3><h3 id="🍁Servlet一个-Web-服务器可以发送一个隐藏的-HTML-表单字段，以及一个唯一的-session-会话-ID，如下所示："><a href="#🍁Servlet一个-Web-服务器可以发送一个隐藏的-HTML-表单字段，以及一个唯一的-session-会话-ID，如下所示：" class="headerlink" title="🍁Servlet一个 Web 服务器可以发送一个隐藏的 HTML 表单字段，以及一个唯一的 session 会话 ID，如下所示："></a>🍁Servlet一个 Web 服务器可以发送一个隐藏的 HTML 表单字段，以及一个唯一的 session 会话 ID，如下所示：</h3><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"hidden"</span> name=<span class="string">"sessionid"</span> value=<span class="string">"12345"</span>&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>该条目意味着，当表单被提交时，指定的名称和值会被自动包含在 GET 或 POST 数据中。每次当 Web 浏览器发送回请求时，session_id 值可以用于保持不同的 Web 浏览器的跟踪。</p>
<p>这可能是一种保持 session 会话跟踪的有效方式，但是点击常规的超文本链接（<a href...="">）不会导致表单提交，因此隐藏的表单字段也不支持常规的 session 会话跟踪。</a></p><a href...="">
</a><h3 id="🍁URL-重写"><a href...=""></a><a href="#🍁URL-重写" class="headerlink" title="🍁URL 重写"></a>🍁URL 重写</h3><p>您可以在每个 URL 末尾追加一些额外的数据来标识 session 会话，服务器会把该 session 会话标识符与已存储的有关 session 会话的数据相关联。</p>
<p>例如，http://w3cschool.cc/file.htm;sessionid=12345，session 会话标识符被附加为 sessionid=12345，标识符可被 Web 服务器访问以识别客户端。</p>
<p>URL 重写是一种更好的维持 session 会话的方式，它在浏览器不支持 cookie 时能够很好地工作，但是它的缺点是会动态生成每个 URL 来为页面分配一个 session 会话 ID，即使是在很简单的静态 HTML 页面中也会如此。</p>
<h3 id="🍁HttpSession-对象"><a href="#🍁HttpSession-对象" class="headerlink" title="🍁HttpSession 对象"></a>🍁HttpSession 对象</h3><p>除了上述的三种方式，Servlet 还提供了 HttpSession 接口，该接口提供了一种跨多个页面请求或访问网站时识别用户以及存储有关用户信息的方式。</p>
<p>Servlet 容器使用这个接口来创建一个 HTTP 客户端和 HTTP 服务器之间的 session 会话。会话持续一个指定的时间段，跨多个连接或页面请求。</p>
<p>您会通过调用 HttpServletRequest 的公共方法 <strong>getSession()</strong> 来获取 HttpSession 对象，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br></pre></td></tr></tbody></table></figure>

<p>你需要在向客户端发送任何文档内容之前调用 <em>request.getSession()</em>。下面总结了 HttpSession 对象中可用的几个重要的方法：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public Object getAttribute(String name)</strong> 该方法返回在该 session 会话中具有指定名称的对象，如果没有指定名称的对象，则返回 null。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>public Enumeration getAttributeNames()</strong> 该方法返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public long getCreationTime()</strong> 该方法返回该 session 会话被创建的时间，自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public String getId()</strong> 该方法返回一个包含分配给该 session 会话的唯一标识符的字符串。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>public long getLastAccessedTime()</strong> 该方法返回客户端最后一次发送与该 session 会话相关的请求的时间自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>public int getMaxInactiveInterval()</strong> 该方法返回 Servlet 容器在客户端访问时保持 session 会话打开的最大时间间隔，以秒为单位。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>public void invalidate()</strong> 该方法指示该 session 会话无效，并解除绑定到它上面的任何对象。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>public boolean isNew()</strong> 如果客户端还不知道该 session 会话，或者如果客户选择不参入该 session 会话，则该方法返回 true。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>public void removeAttribute(String name)</strong> 该方法将从该 session 会话移除指定名称的对象。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>public void setAttribute(String name, Object value)</strong>  该方法使用指定的名称绑定一个对象到该 session 会话。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>public void setMaxInactiveInterval(int interval)</strong> 该方法在 Servlet 容器指示该 session 会话无效之前，指定客户端请求之间的时间，以秒为单位。</td>
</tr>
</tbody></table>
<h3 id="🍁Session-跟踪实例"><a href="#🍁Session-跟踪实例" class="headerlink" title="🍁Session 跟踪实例"></a>🍁Session 跟踪实例</h3><p>本实例说明了如何使用 HttpSession 对象获取 session 会话创建时间和最后访问时间。如果不存在 session 会话，我们将通过请求创建一个新的 session 会话。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class SessionTrack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/SessionTrack"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionTrack</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 如果不存在 session 会话，则创建一个 session 对象</span></span><br><span class="line">        HttpSession session = request.getSession(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 获取 session 创建时间</span></span><br><span class="line">        Date createTime = <span class="keyword">new</span> Date(session.getCreationTime());</span><br><span class="line">        <span class="comment">// 获取该网页的最后一次访问时间</span></span><br><span class="line">        Date lastAccessTime = <span class="keyword">new</span> Date(session.getLastAccessedTime());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//设置日期输出的格式  </span></span><br><span class="line">        SimpleDateFormat df=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);  </span><br><span class="line">    </span><br><span class="line">        String title = <span class="string">"Servlet Session 实例 - 云澈"</span>;</span><br><span class="line">        Integer visitCount = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line">        String visitCountKey = <span class="keyword">new</span> String(<span class="string">"visitCount"</span>);</span><br><span class="line">        String userIDKey = <span class="keyword">new</span> String(<span class="string">"userID"</span>);</span><br><span class="line">        String userID = <span class="keyword">new</span> String(<span class="string">"Runoob"</span>);</span><br><span class="line">        <span class="keyword">if</span>(session.getAttribute(visitCountKey) == <span class="keyword">null</span>) {</span><br><span class="line">            session.setAttribute(visitCountKey, <span class="keyword">new</span> Integer(<span class="number">0</span>));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 检查网页上是否有新的访问者</span></span><br><span class="line">        <span class="keyword">if</span> (session.isNew()){</span><br><span class="line">            title = <span class="string">"Servlet Session 实例 - 云澈"</span>;</span><br><span class="line">             session.setAttribute(userIDKey, userID);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">             visitCount = (Integer)session.getAttribute(visitCountKey);</span><br><span class="line">             visitCount = visitCount + <span class="number">1</span>;</span><br><span class="line">             userID = (String)session.getAttribute(userIDKey);</span><br><span class="line">        }</span><br><span class="line">        session.setAttribute(visitCountKey,  visitCount);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 设置响应内容类型</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">    </span><br><span class="line">        String docType = <span class="string">"&lt;!DOCTYPE html&gt;\n"</span>;</span><br><span class="line">        out.println(docType +</span><br><span class="line">                <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">                 <span class="string">"&lt;h2 align=\"center\"&gt;Session 信息&lt;/h2&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;table border=\"1\" align=\"center\"&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;tr bgcolor=\"#949494\"&gt;\n"</span> +</span><br><span class="line">                <span class="string">"  &lt;th&gt;Session 信息&lt;/th&gt;&lt;th&gt;值&lt;/th&gt;&lt;/tr&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;tr&gt;\n"</span> +</span><br><span class="line">                <span class="string">"  &lt;td&gt;id&lt;/td&gt;\n"</span> +</span><br><span class="line">                <span class="string">"  &lt;td&gt;"</span> + session.getId() + <span class="string">"&lt;/td&gt;&lt;/tr&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;tr&gt;\n"</span> +</span><br><span class="line">                <span class="string">"  &lt;td&gt;创建时间&lt;/td&gt;\n"</span> +</span><br><span class="line">                <span class="string">"  &lt;td&gt;"</span> +  df.format(createTime) + </span><br><span class="line">                <span class="string">"  &lt;/td&gt;&lt;/tr&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;tr&gt;\n"</span> +</span><br><span class="line">                <span class="string">"  &lt;td&gt;最后访问时间&lt;/td&gt;\n"</span> +</span><br><span class="line">                <span class="string">"  &lt;td&gt;"</span> + df.format(lastAccessTime) + </span><br><span class="line">                <span class="string">"  &lt;/td&gt;&lt;/tr&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;tr&gt;\n"</span> +</span><br><span class="line">                <span class="string">"  &lt;td&gt;用户 ID&lt;/td&gt;\n"</span> +</span><br><span class="line">                <span class="string">"  &lt;td&gt;"</span> + userID + </span><br><span class="line">                <span class="string">"  &lt;/td&gt;&lt;/tr&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;tr&gt;\n"</span> +</span><br><span class="line">                <span class="string">"  &lt;td&gt;访问统计：&lt;/td&gt;\n"</span> +</span><br><span class="line">                <span class="string">"  &lt;td&gt;"</span> + visitCount + <span class="string">"&lt;/td&gt;&lt;/tr&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;/table&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>); </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>编译上面的 Servlet <strong>SessionTrack</strong>，并在 web.xml 文件中创建适当的条目。</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 类名 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SessionTrack<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 所在的包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.runoob.test.SessionTrack<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SessionTrack<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 访问的网址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/TomcatTest/SessionTrack<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>在浏览器地址栏输入 <em>http://localhost:8080/TomcatTest/SessionTrack</em>，当您第一次运行时将显示如下结果：</p>
<p><a href="https://imgchr.com/i/0rsYND" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/09/0rsYND.png" alt="0rsYND.png"></a></p>
<p>再次尝试运行相同的 Servlet，它将显示如下结果</p>
<p><a href="https://imgchr.com/i/0rsBut" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/09/0rsBut.png" alt="0rsBut.png"></a></p>
<h3 id="🍁删除-Session-会话数据"><a href="#🍁删除-Session-会话数据" class="headerlink" title="🍁删除 Session 会话数据"></a>🍁删除 Session 会话数据</h3><p>当您完成了一个用户的 session 会话数据，您有以下几种选择：</p>
<ul>
<li><strong>移除一个特定的属性：</strong>您可以调用 <em>public void removeAttribute(String name)</em> 方法来删除与特定的键相关联的值。</li>
<li><strong>删除整个 session 会话：</strong>您可以调用 <em>public void invalidate()</em> 方法来丢弃整个 session 会话。</li>
<li><strong>设置 session 会话过期时间：</strong>您可以调用 <em>public void setMaxInactiveInterval(int interval)</em> 方法来单独设置 session 会话超时。</li>
<li><strong>注销用户：</strong>如果使用的是支持 servlet 2.4 的服务器，您可以调用 <strong>logout</strong> 来注销 Web 服务器的客户端，并把属于所有用户的所有 session 会话设置为无效。</li>
<li><strong>web.xml 配置：</strong>如果您使用的是 Tomcat，除了上述方法，您还可以在 web.xml 文件中配置 session 会话超时，如下所示：</li>
</ul>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>15<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>上面实例中的超时时间是以分钟为单位，将覆盖 Tomcat 中默认的 30 分钟超时时间。</p>
<p>在一个 Servlet 中的 getMaxInactiveInterval() 方法会返回 session 会话的超时时间，以秒为单位。所以，如果在 web.xml 中配置 session 会话超时时间为 15 分钟，那么 getMaxInactiveInterval() 会返回 900。</p>
<h2 id="🌸Servlet数据库访问"><a href="#🌸Servlet数据库访问" class="headerlink" title="🌸Servlet数据库访问"></a>🌸Servlet数据库访问</h2><blockquote>
<p>在 java 项目中，只需要在 Eclipse 中引入 mysql-connector-java-5.1.39-bin.jar 就可以运行java项目。</p>
<p>但是在 Eclipse web 项目中，当执行 Class.forName(“com.mysql.jdbc.Driver”);时 不会去查找驱动的。所以本实例中我们需要把 mysql-connector-java-5.1.39-bin.jar 拷贝到 tomcat 下 lib 目录。</p>
</blockquote>
<h3 id="🍁创建测试数据"><a href="#🍁创建测试数据" class="headerlink" title="🍁创建测试数据"></a>🍁创建测试数据</h3><p>接下来我们在 MySQL 中创建 RUNOOB 数据库，并创建 websites 数据表，表结构如下：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`websites`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'站点名称'</span>,</span><br><span class="line">  <span class="string">`url`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`alexa`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'Alexa 排名'</span>,</span><br><span class="line">  <span class="string">`country`</span> <span class="built_in">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'国家'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">10</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></tbody></table></figure>

<p>插入一些数据：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`websites`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'Google'</span>, <span class="string">'https://www.google.cm/'</span>, <span class="string">'1'</span>, <span class="string">'USA'</span>), (<span class="string">'2'</span>, <span class="string">'淘宝'</span>, <span class="string">'https://www.taobao.com/'</span>, <span class="string">'13'</span>, <span class="string">'CN'</span>), (<span class="string">'3'</span>, <span class="string">'菜鸟教程'</span>, <span class="string">'http://www.runoob.com'</span>, <span class="string">'5892'</span>, <span class="string">''</span>), (<span class="string">'4'</span>, <span class="string">'微博'</span>, <span class="string">'http://weibo.com/'</span>, <span class="string">'20'</span>, <span class="string">'CN'</span>), (<span class="string">'5'</span>, <span class="string">'Facebook'</span>, <span class="string">'https://www.facebook.com/'</span>, <span class="string">'3'</span>, <span class="string">'USA'</span>);</span><br></pre></td></tr></tbody></table></figure>





<h3 id="🍁访问数据库"><a href="#🍁访问数据库" class="headerlink" title="🍁访问数据库"></a>🍁访问数据库</h3><p>下面的实例演示了如何使用 Servlet 访问 RUNOOB 数据库。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class DatabaseAccess</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/DatabaseAccess"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseAccess</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">// JDBC 驱动名及数据库 URL</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://localhost:3306/RUNOOB"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据库的用户名与密码，需要根据自己的设置</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">"123456"</span>; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DatabaseAccess</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 设置响应内容类型</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = <span class="string">"Servlet Mysql 测试 - 菜鸟教程"</span>;</span><br><span class="line">        String docType = <span class="string">"&lt;!DOCTYPE html&gt;\n"</span>;</span><br><span class="line">        out.println(docType +</span><br><span class="line">        <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">        <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">        <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">        <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">try</span>{</span><br><span class="line">            <span class="comment">// 注册 JDBC 驱动器</span></span><br><span class="line">            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 打开一个连接</span></span><br><span class="line">            conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行 SQL 查询</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            String sql;</span><br><span class="line">            sql = <span class="string">"SELECT id, name, url FROM websites"</span>;</span><br><span class="line">            ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 展开结果集数据库</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next()){</span><br><span class="line">                <span class="comment">// 通过字段检索</span></span><br><span class="line">                <span class="keyword">int</span> id  = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">                String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">                String url = rs.getString(<span class="string">"url"</span>);</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// 输出数据</span></span><br><span class="line">                out.println(<span class="string">"ID: "</span> + id);</span><br><span class="line">                out.println(<span class="string">", 站点名称: "</span> + name);</span><br><span class="line">                out.println(<span class="string">", 站点 URL: "</span> + url);</span><br><span class="line">                out.println(<span class="string">"&lt;br /&gt;"</span>);</span><br><span class="line">            }</span><br><span class="line">            out.println(<span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 完成后关闭</span></span><br><span class="line">            rs.close();</span><br><span class="line">            stmt.close();</span><br><span class="line">            conn.close();</span><br><span class="line">        } <span class="keyword">catch</span>(SQLException se) {</span><br><span class="line">            <span class="comment">// 处理 JDBC 错误</span></span><br><span class="line">            se.printStackTrace();</span><br><span class="line">        } <span class="keyword">catch</span>(Exception e) {</span><br><span class="line">            <span class="comment">// 处理 Class.forName 错误</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }<span class="keyword">finally</span>{</span><br><span class="line">            <span class="comment">// 最后是用于关闭资源的块</span></span><br><span class="line">            <span class="keyword">try</span>{</span><br><span class="line">                <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>)</span><br><span class="line">                stmt.close();</span><br><span class="line">            }<span class="keyword">catch</span>(SQLException se2){</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">try</span>{</span><br><span class="line">                <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)</span><br><span class="line">                conn.close();</span><br><span class="line">            }<span class="keyword">catch</span>(SQLException se){</span><br><span class="line">                se.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">       </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        doGet(request, response);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在让我们来编译上面的 Servlet，并在 web.xml 文件中创建以下条目：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DatabaseAccess<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.runoob.test.DatabaseAccess<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DatabaseAccess<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/TomcatTest/DatabaseAccess<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁笔记"><a href="#🍁笔记" class="headerlink" title="🍁笔记"></a>🍁笔记</h3><p>进行数据库插入操作的时候使用 PreparedStatement 更好，好处如下：</p>
<ul>
<li>1.PreparedStatement可以写动态参数化的查询；</li>
<li>2.PreparedStatement比 Statement 更快；</li>
<li>3.PreparedStatement可以防止SQL注入式攻击</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//编写预处理 SQL 语句</span></span><br><span class="line">String sql= <span class="string">"INSERT INTO websites1 VALUES(?,?,?,?,?)"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化 PreparedStatement</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入参数，这里的参数来自于一个带有表单的jsp文件，很容易实现</span></span><br><span class="line">ps.setString(<span class="number">1</span>, request.getParameter(<span class="string">"id"</span>));</span><br><span class="line">ps.setString(<span class="number">2</span>, request.getParameter(<span class="string">"name"</span>));</span><br><span class="line">ps.setString(<span class="number">3</span>, request.getParameter(<span class="string">"url"</span>));</span><br><span class="line">ps.setString(<span class="number">4</span>, request.getParameter(<span class="string">"alexa"</span>));</span><br><span class="line">ps.setString(<span class="number">5</span>, request.getParameter(<span class="string">"country"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行数据库更新操作，不需要SQL语句</span></span><br><span class="line">ps.executeUpdate();</span><br><span class="line">sql = <span class="string">"SELECT id, name, url FROM websites1"</span>;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取查询结果</span></span><br><span class="line">ResultSet rs = ps.executeQuery();</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁注意"><a href="#🍁注意" class="headerlink" title="🍁注意"></a>🍁注意</h3><p>由于更新的 MySQL8.0，所以本网站提供的 jar 包：<strong>mysql-connector-java-5.1.39-bin.jar</strong> 就不能用了，连接时会报：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connection to database server</span><br></pre></td></tr></tbody></table></figure>

<p>这个异常。</p>
<p>需要重新下载，下载地址 <a href="https://dev.mysql.com/downloads/file/?id=484819，暂时我下载到的是" target="_blank" rel="noopener">https://dev.mysql.com/downloads/file/?id=484819，暂时我下载到的是</a> <strong>mysql-connector-java-8.0.15</strong> 替换这个 jar 包后，又出现异常 <strong>java.sql.SQLException: The server time zone value</strong>，只需在数据库地址后边添加 <strong>serverTimezone=UTC</strong> 即可，例如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">DB_URL = <span class="string">"jdbc:mysql://localhost:3306/servlet_db?serverTimezone=UTC"</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>还有注册 jdbc 的驱动也换了。</p>
<p>注册 JDBC 驱动器：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸Servlet-文件上传"><a href="#🌸Servlet-文件上传" class="headerlink" title="🌸Servlet 文件上传"></a>🌸Servlet 文件上传</h2><p>Servlet 可以与 HTML form 标签一起使用，来允许用户上传文件到服务器。上传的文件可以是文本文件或图像文件或任何文档。</p>
<p>本文使用到的文件有：</p>
<ul>
<li>upload.jsp : 文件上传表单。</li>
<li>message.jsp : 上传成功后跳转页面。</li>
<li>UploadServlet.java : 上传处理 Servlet。</li>
<li>需要引入的 jar 文件：commons-fileupload-1.4、commons-io-2.8.jar。</li>
<li><em>Servlet3.0 已经内置了文件上传这一特性，开发者不再需要将 Commons FileUpload 组件导入到工程中去。</em></li>
</ul>
<h3 id="🍁创建一个文件上传表单"><a href="#🍁创建一个文件上传表单" class="headerlink" title="🍁创建一个文件上传表单"></a>🍁创建一个文件上传表单</h3><p>下面的 HTML 代码创建了一个文件上传表单。以下几点需要注意：</p>
<ul>
<li>表单 <strong>method</strong> 属性应该设置为 <strong>POST</strong> 方法，不能使用 GET 方法。</li>
<li>表单 <strong>enctype</strong> 属性应该设置为 <strong>multipart/form-data</strong>.</li>
<li>表单 <strong>action</strong> 属性应该设置为在后端服务器上处理文件上传的 Servlet 文件。下面的实例使用了 <strong>UploadServlet</strong> Servlet 来上传文件。</li>
<li>上传单个文件，您应该使用单个带有属性 type=”file” 的 &lt;input …/&gt; 标签。为了允许多个文件上传，请包含多个 name 属性值不同的 input 标签。输入标签具有不同的名称属性的值。浏览器会为每个 input 标签关联一个浏览按钮。</li>
</ul>
<p>upload.jsp 文件代码如下：</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">    pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;文件上传实例 - 云澈&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;文件上传实例 - 云澈&lt;/h1&gt;</span><br><span class="line">&lt;form method=<span class="string">"post"</span> action=<span class="string">"/TomcatTest/UploadServlet"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">    选择一个文件:</span><br><span class="line">    &lt;input type=<span class="string">"file"</span> name=<span class="string">"uploadFile"</span> /&gt;</span><br><span class="line">    &lt;br/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"上传"</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>



<h3 id="🍁编写后台-Servlet"><a href="#🍁编写后台-Servlet" class="headerlink" title="🍁编写后台 Servlet"></a>🍁编写后台 Servlet</h3><p>以下是 UploadServlet 的源代码，同于处理文件上传，在这之前我们先确保依赖包已经引入到项目的 WEB-INF/lib 目录下：</p>
<ul>
<li>下面的实例依赖于 FileUpload，所以一定要确保在您的 classpath 中有最新版本的 <strong>commons-fileupload.x.x.jar</strong>文件。可以从 <a href="http://commons.apache.org/proper/commons-fileupload/" target="_blank" rel="noopener">http://commons.apache.org/proper/commons-fileupload/</a> 下载。</li>
<li>FileUpload 依赖于 Commons IO，所以一定要确保在您的 classpath 中有最新版本的 <strong>commons-io-x.x.jar</strong> 文件。可以从 <a href="http://commons.apache.org/proper/commons-io/" target="_blank" rel="noopener">http://commons.apache.org/proper/commons-io/</a> 下载。</li>
</ul>
<p>UploadServlet 的源代码 如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.FileItem;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.disk.DiskFileItemFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.fileupload.servlet.ServletFileUpload;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class UploadServlet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/UploadServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 上传文件存储目录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String UPLOAD_DIRECTORY = <span class="string">"upload"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 上传配置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MEMORY_THRESHOLD   = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">3</span>;  <span class="comment">// 3MB</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_FILE_SIZE      = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">40</span>; <span class="comment">// 40MB</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_REQUEST_SIZE   = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">50</span>; <span class="comment">// 50MB</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传数据及保存文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line">        <span class="comment">// 检测是否为多媒体上传</span></span><br><span class="line">        <span class="keyword">if</span> (!ServletFileUpload.isMultipartContent(request)) {</span><br><span class="line">            <span class="comment">// 如果不是则停止</span></span><br><span class="line">            PrintWriter writer = response.getWriter();</span><br><span class="line">            writer.println(<span class="string">"Error: 表单必须包含 enctype=multipart/form-data"</span>);</span><br><span class="line">            writer.flush();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 配置上传参数</span></span><br><span class="line">        DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">        <span class="comment">// 设置内存临界值 - 超过后将产生临时文件并存储于临时目录中</span></span><br><span class="line">        factory.setSizeThreshold(MEMORY_THRESHOLD);</span><br><span class="line">        <span class="comment">// 设置临时存储目录</span></span><br><span class="line">        factory.setRepository(<span class="keyword">new</span> File(System.getProperty(<span class="string">"java.io.tmpdir"</span>)));</span><br><span class="line"> </span><br><span class="line">        ServletFileUpload upload = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 设置最大文件上传值</span></span><br><span class="line">        upload.setFileSizeMax(MAX_FILE_SIZE);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 设置最大请求值 (包含文件和表单数据)</span></span><br><span class="line">        upload.setSizeMax(MAX_REQUEST_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中文处理</span></span><br><span class="line">        upload.setHeaderEncoding(<span class="string">"UTF-8"</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造临时路径来存储上传的文件</span></span><br><span class="line">        <span class="comment">// 这个路径相对当前应用的目录</span></span><br><span class="line">        String uploadPath = request.getServletContext().getRealPath(<span class="string">"./"</span>) + File.separator + UPLOAD_DIRECTORY;</span><br><span class="line">       </span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 如果目录不存在则创建</span></span><br><span class="line">        File uploadDir = <span class="keyword">new</span> File(uploadPath);</span><br><span class="line">        <span class="keyword">if</span> (!uploadDir.exists()) {</span><br><span class="line">            uploadDir.mkdir();</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 解析请求的内容提取文件数据</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            List&lt;FileItem&gt; formItems = upload.parseRequest(request);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (formItems != <span class="keyword">null</span> &amp;&amp; formItems.size() &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 迭代表单数据</span></span><br><span class="line">                <span class="keyword">for</span> (FileItem item : formItems) {</span><br><span class="line">                    <span class="comment">// 处理不在表单中的字段</span></span><br><span class="line">                    <span class="keyword">if</span> (!item.isFormField()) {</span><br><span class="line">                        String fileName = <span class="keyword">new</span> File(item.getName()).getName();</span><br><span class="line">                        String filePath = uploadPath + File.separator + fileName;</span><br><span class="line">                        File storeFile = <span class="keyword">new</span> File(filePath);</span><br><span class="line">                        <span class="comment">// 在控制台输出文件的上传路径</span></span><br><span class="line">                        System.out.println(filePath);</span><br><span class="line">                        <span class="comment">// 保存文件到硬盘</span></span><br><span class="line">                        item.write(storeFile);</span><br><span class="line">                        request.setAttribute(<span class="string">"message"</span>,</span><br><span class="line">                            <span class="string">"文件上传成功!"</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">            request.setAttribute(<span class="string">"message"</span>,</span><br><span class="line">                    <span class="string">"错误信息: "</span> + ex.getMessage());</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 跳转到 message.jsp</span></span><br><span class="line">        request.getServletContext().getRequestDispatcher(<span class="string">"/message.jsp"</span>).forward(</span><br><span class="line">                request, response);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>message.jsp 文件代码如下：</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">    pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;文件上传结果&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;center&gt;</span><br><span class="line">        &lt;h2&gt;${message}&lt;/h2&gt;</span><br><span class="line">    &lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>



<h3 id="🍁编译和运行-Servlet"><a href="#🍁编译和运行-Servlet" class="headerlink" title="🍁编译和运行 Servlet"></a>🍁编译和运行 Servlet</h3><p>编译上面的 Servlet UploadServlet，并在 web.xml 文件中创建所需的条目，如下所示：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">"2.5"</span>   </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span>   </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>   </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee   </span></span></span><br><span class="line"><span class="tag"><span class="string">    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">     <span class="comment">&lt;!-- 类名 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>UploadServlet<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>UploadServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 所在的包 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.runoob.test.UploadServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>UploadServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 访问的网址 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/TomcatTest/UploadServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸Servlet-处理日期"><a href="#🌸Servlet-处理日期" class="headerlink" title="🌸Servlet 处理日期"></a>🌸Servlet 处理日期</h2><p>Date 类支持两个构造函数。第一个构造函数初始化当前日期和时间的对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Date( )</span><br></pre></td></tr></tbody></table></figure>

<p>下面的构造函数接受一个参数，该参数等于 1970 年 1 月 1 日午夜以来经过的毫秒数。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Date(<span class="keyword">long</span> millisec)</span><br></pre></td></tr></tbody></table></figure>

<p>一旦您有一个可用的 Date 对象，您可以调用下列任意支持的方法来使用日期：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>boolean after(Date date)</strong> 如果调用的 Date 对象中包含的日期在 date 指定的日期之后，则返回 true，否则返回 false。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>boolean before(Date date)</strong> 如果调用的 Date 对象中包含的日期在 date 指定的日期之前，则返回 true，否则返回 false。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>Object clone( )</strong> 重复调用 Date 对象。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>int compareTo(Date date)</strong> 把调用对象的值与 date 的值进行比较。如果两个值是相等的，则返回 0。如果调用对象在 date 之前，则返回一个负值。如果调用对象在 date 之后，则返回一个正值。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>int compareTo(Object obj)</strong> 如果 obj 是 Date 类，则操作等同于 compareTo(Date)。否则，它会抛出一个 ClassCastException。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>boolean equals(Object date)</strong> 如果调用的 Date 对象中包含的时间和日期与 date 指定的相同，则返回 true，否则返回 false。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>long getTime( )</strong> 返回 1970 年 1 月 1 日以来经过的毫秒数。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>int hashCode( )</strong> 为调用对象返回哈希代码。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>void setTime(long time)</strong> 设置 time 指定的时间和日期，这表示从 1970 年 1 月 1 日午夜以来经过的时间（以毫秒为单位）。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>String toString( )</strong> 转换调用的 Date 对象为一个字符串，并返回结果。</td>
</tr>
</tbody></table>
<h3 id="🍁获取当前的日期和时间"><a href="#🍁获取当前的日期和时间" class="headerlink" title="🍁获取当前的日期和时间"></a>🍁获取当前的日期和时间</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class CurrentDate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/CurrentDate"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentDate</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrentDate</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">          String title = <span class="string">"显示当前的日期和时间"</span>;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        String docType = <span class="string">"&lt;!DOCTYPE html&gt; \n"</span>;</span><br><span class="line">          out.println(docType +</span><br><span class="line">            <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;h2 align=\"center\"&gt;"</span> + date.toString() + <span class="string">"&lt;/h2&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>CurrentDate<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.runoob.test.CurrentDate<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>CurrentDate<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/TomcatTest/CurrentDate<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="🍁日期比较"><a href="#🍁日期比较" class="headerlink" title="🍁日期比较"></a>🍁日期比较</h3><ul>
<li>可以使用 getTime() 来获取两个对象自 1970 年 1 月 1 日午夜以来经过的时间（以毫秒为单位），然后对这两个值进行比较。</li>
<li>可以使用方法 before( )、after( ) 和 equals( )。由于一个月里 12 号在 18 号之前，例如，new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回 true。</li>
<li>可以使用 compareTo( ) 方法，该方法由 Comparable 接口定义，由 Date 实现。</li>
</ul>
<h3 id="🍁使用-SimpleDateFormat-格式化日期"><a href="#🍁使用-SimpleDateFormat-格式化日期" class="headerlink" title="🍁使用 SimpleDateFormat 格式化日期"></a>🍁使用 SimpleDateFormat 格式化日期</h3><p>SimpleDateFormat 是一个以语言环境敏感的方式来格式化和解析日期的具体类。 SimpleDateFormat 允许您选择任何用户定义的日期时间格式化的模式。</p>
<p>让我们修改上面的实例，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class CurrentDate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/CurrentDate"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentDate</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrentDate</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        </span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = <span class="string">"显示当前的日期和时间"</span>;</span><br><span class="line">        Date dNow = <span class="keyword">new</span> Date( );</span><br><span class="line">        SimpleDateFormat ft = </span><br><span class="line">                <span class="keyword">new</span> SimpleDateFormat (<span class="string">"yyyy.MM.dd  hh:mm:ss E a "</span>);</span><br><span class="line">        String docType = <span class="string">"&lt;!DOCTYPE html&gt; \n"</span>;</span><br><span class="line">        out.println(docType +</span><br><span class="line">            <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;h2 align=\"center\"&gt;"</span> + ft.format(dNow) + <span class="string">"&lt;/h2&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁简单的日期格式的格式代码"><a href="#🍁简单的日期格式的格式代码" class="headerlink" title="🍁简单的日期格式的格式代码"></a>🍁简单的日期格式的格式代码</h3><p>使用事件模式字符串来指定时间格式。在这种模式下，所有的 ASCII 字母被保留为模式字母，这些字母定义如下：</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">G</td>
<td align="left">Era 指示器</td>
<td align="left">AD</td>
</tr>
<tr>
<td align="left">y</td>
<td align="left">四位数表示的年</td>
<td align="left">2001</td>
</tr>
<tr>
<td align="left">M</td>
<td align="left">一年中的月</td>
<td align="left">July 或 07</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">一月中的第几天</td>
<td align="left">10</td>
</tr>
<tr>
<td align="left">h</td>
<td align="left">带有 A.M./P.M. 的小时（1~12）</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">H</td>
<td align="left">一天中的第几小时（0~23）</td>
<td align="left">22</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">一小时中的第几分</td>
<td align="left">30</td>
</tr>
<tr>
<td align="left">s</td>
<td align="left">一分中的第几秒</td>
<td align="left">55</td>
</tr>
<tr>
<td align="left">S</td>
<td align="left">毫秒</td>
<td align="left">234</td>
</tr>
<tr>
<td align="left">E</td>
<td align="left">一周中的星期几</td>
<td align="left">Tuesday</td>
</tr>
<tr>
<td align="left">D</td>
<td align="left">一年中的第几天</td>
<td align="left">360</td>
</tr>
<tr>
<td align="left">F</td>
<td align="left">所在的周是这个月的第几周</td>
<td align="left">2 (second Wed. in July)</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">一年中的第几周</td>
<td align="left">40</td>
</tr>
<tr>
<td align="left">W</td>
<td align="left">一月中的第几周</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">A.M./P.M. 标记</td>
<td align="left">PM</td>
</tr>
<tr>
<td align="left">k</td>
<td align="left">一天中的第几小时（1~24）</td>
<td align="left">24</td>
</tr>
<tr>
<td align="left">K</td>
<td align="left">带有 A.M./P.M. 的小时（0~11）</td>
<td align="left">10</td>
</tr>
<tr>
<td align="left">z</td>
<td align="left">时区</td>
<td align="left">Eastern Standard Time</td>
</tr>
<tr>
<td align="left">‘</td>
<td align="left">Escape for text</td>
<td align="left">Delimiter</td>
</tr>
<tr>
<td align="left">“</td>
<td align="left">单引号</td>
<td align="left">`</td>
</tr>
</tbody></table>
<h2 id="🌸"><a href="#🌸" class="headerlink" title="🌸"></a>🌸</h2><p>当文档移动到新的位置，我们需要向客户端发送这个新位置时，我们需要用到网页重定向。当然，也可能是为了负载均衡，或者只是为了简单的随机，这些情况都有可能用到网页重定向。</p>
<p>重定向请求到另一个网页的最简单的方式是使用 response 对象的 sendRedirect() 方法。下面是该方法的定义：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> HttpServletResponse.sendRedirect(String location)</span><br><span class="line"><span class="keyword">throws</span> IOException</span><br></pre></td></tr></tbody></table></figure>

<p>该方法把响应连同状态码和新的网页位置发送回浏览器。您也可以通过把 setStatus() 和 setHeader() 方法一起使用来达到同样的效果：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">....</span><br><span class="line">String site = <span class="string">"http://www.runoob.com"</span> ;</span><br><span class="line">response.setStatus(response.SC_MOVED_TEMPORARILY);</span><br><span class="line">response.setHeader(<span class="string">"Location"</span>, site); </span><br><span class="line">....</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁实例-1"><a href="#🍁实例-1" class="headerlink" title="🍁实例"></a>🍁实例</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class PageRedirect</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/PageRedirect"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageRedirect</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>{</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"static-access"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                    HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">      <span class="comment">// 设置响应内容类型</span></span><br><span class="line">      response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 要重定向的新位置</span></span><br><span class="line">      String site = <span class="keyword">new</span> String(<span class="string">"http://liudufu.gihub.io"</span>);</span><br><span class="line"></span><br><span class="line">      response.setStatus(response.SC_MOVED_TEMPORARILY);</span><br><span class="line">      response.setHeader(<span class="string">"Location"</span>, site);    </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>PageRedirect<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>PageRedirect<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>PageRedirect<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/TomcatTest/PageRedirect<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>现在通过访问 URL <a href="http://localhost:8080/PageRedirect" target="_blank" rel="noopener">http://localhost:8080/PageRedirect</a> 来调用这个 Servlet</p>
<h2 id="🌸Servlet-点击计数器"><a href="#🌸Servlet-点击计数器" class="headerlink" title="🌸Servlet 点击计数器"></a>🌸Servlet 点击计数器</h2><p>很多时候，您可能有兴趣知道网站的某个特定页面上的总点击量。使用 Servlet 来计算这些点击量是非常简单的，因为一个 Servlet 的生命周期是由它运行所在的容器控制的。</p>
<p>以下是实现一个简单的基于 Servlet 生命周期的网页点击计数器需要采取的步骤：</p>
<ul>
<li>在 init() 方法中初始化一个全局变量。</li>
<li>每次调用 doGet() 或 doPost() 方法时，都增加全局变量。</li>
<li>如果需要，您可以使用一个数据库表来存储全局变量的值在 destroy() 中。在下次初始化 Servlet 时，该值可在 init() 方法内被读取。这一步是可选的。</li>
<li>如果您只想对一个 session 会话计数一次页面点击，那么请使用 isNew() 方法来检查该 session 会话是否已点击过相同页面。这一步是可选的。</li>
<li>您可以通过显示全局计数器的值，来在网站上展示页面的总点击量。这一步是可选的。</li>
</ul>
<p>在这里，我们假设 Web 容器将无法重新启动。如果是重新启动或 Servlet 被销毁，计数器将被重置。</p>
<h3 id="🍁实例-2"><a href="#🍁实例-2" class="headerlink" title="🍁实例"></a>🍁实例</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class PageHitCounter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/PageHitCounter"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageHitCounter</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hitCount; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>{ </span><br><span class="line">        <span class="comment">// 重置点击计数器</span></span><br><span class="line">        hitCount = <span class="number">0</span>;</span><br><span class="line">    } </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        <span class="comment">// 增加 hitCount </span></span><br><span class="line">        hitCount++; </span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = <span class="string">"总点击量"</span>;</span><br><span class="line">        String docType = <span class="string">"&lt;!DOCTYPE html&gt; \n"</span>;</span><br><span class="line">        out.println(docType +</span><br><span class="line">            <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;h2 align=\"center\"&gt;"</span> + hitCount + <span class="string">"&lt;/h2&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>{ </span><br><span class="line">        <span class="comment">// 这一步是可选的，但是如果需要，您可以把 hitCount 的值写入到数据库</span></span><br><span class="line">    } </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>PageHitCounter<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.runoob.test.PageHitCounter<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>PageHitCounter<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/TomcatTest/PageHitCounter<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁网站点击计数器"><a href="#🍁网站点击计数器" class="headerlink" title="🍁网站点击计数器"></a>🍁网站点击计数器</h3><p>很多时候，您可能有兴趣知道整个网站的总点击量。在 Servlet 中，这也是非常简单的，我们可以使用过滤器做到这一点。</p>
<p>以下是实现一个简单的基于过滤器生命周期的网站点击计数器需要采取的步骤：</p>
<ul>
<li>在过滤器的 init() 方法中初始化一个全局变量。</li>
<li>每次调用 doFilter 方法时，都增加全局变量。</li>
<li>如果需要，您可以在过滤器的 destroy() 中使用一个数据库表来存储全局变量的值。在下次初始化过滤器时，该值可在 init() 方法内被读取, 这一步是可选的。</li>
</ul>
<p>在这里，我们假设 Web 容器将无法重新启动。如果是重新启动或 Servlet 被销毁，点击计数器将被重置。</p>
<h3 id="🍁实例-3"><a href="#🍁实例-3" class="headerlink" title="🍁实例"></a>🍁实例</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 导入必需的 java 库</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SiteHitCounter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>{</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> hitCount; </span><br><span class="line">               </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">init</span><span class="params">(FilterConfig config)</span> </span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> ServletException</span>{</span><br><span class="line">     <span class="comment">// 重置点击计数器</span></span><br><span class="line">     hitCount = <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">doFilter</span><span class="params">(ServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">              ServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">              FilterChain chain)</span> </span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> java.io.IOException, ServletException </span>{</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把计数器的值增加 1</span></span><br><span class="line">      hitCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 输出计数器</span></span><br><span class="line">      System.out.println(<span class="string">"网站访问统计："</span>+ hitCount );</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把请求传回到过滤器链</span></span><br><span class="line">      chain.doFilter(request,response);</span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  </span>{ </span><br><span class="line">      <span class="comment">// 这一步是可选的，但是如果需要，您可以把 hitCount 的值写入到数据库</span></span><br><span class="line">  } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>SiteHitCounter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>SiteHitCounter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>SiteHitCounter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>现在访问网站的任意页面，比如 <a href="http://localhost:8080/。这将会在每次任意页面被点击时，把计数器的值增加" target="_blank" rel="noopener">http://localhost:8080/。这将会在每次任意页面被点击时，把计数器的值增加</a> 1，它会在日志中显示以下消息：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">网站访问统计： 1</span><br><span class="line">网站访问统计： 2</span><br><span class="line">网站访问统计： 3</span><br><span class="line">网站访问统计： 4</span><br><span class="line">网站访问统计： 5</span><br><span class="line">..................</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸Servlet-自动刷新页面"><a href="#🌸Servlet-自动刷新页面" class="headerlink" title="🌸Servlet 自动刷新页面"></a>🌸Servlet 自动刷新页面</h2><p>假设有一个网页，它是显示现场比赛成绩或股票市场状况或货币兑换率。对于所有这些类型的页面，您需要定期刷新网页。</p>
<p>Java Servlet 提供了一个机制，使得网页会在给定的时间间隔自动刷新。</p>
<p>刷新网页的最简单的方式是使用响应对象的方法 <strong>setIntHeader()</strong>。以下是这种方法的定义：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public void setIntHeader(String header, int headerValue)</span><br></pre></td></tr></tbody></table></figure>

<p>此方法把头信息 “Refresh” 连同一个表示时间间隔的整数值（以秒为单位）发送回浏览器。</p>
<h3 id="🍁自动刷新页面实例"><a href="#🍁自动刷新页面实例" class="headerlink" title="🍁自动刷新页面实例"></a>🍁自动刷新页面实例</h3><p>本实例演示了 Servlet 如何使用 <strong>setIntHeader()</strong> 方法来设置 <strong>Refresh</strong> 头信息，从而实现自动刷新页面。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.GregorianCalendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class Refresh</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/Refresh"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Refresh</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置刷新自动加载的事件间隔为 5 秒</span></span><br><span class="line">        response.setIntHeader(<span class="string">"Refresh"</span>, <span class="number">5</span>);</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 设置响应内容类型</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 获取当前的时间</span></span><br><span class="line">        Calendar calendar = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">        String am_pm;</span><br><span class="line">        <span class="keyword">int</span> hour = calendar.get(Calendar.HOUR);</span><br><span class="line">        <span class="keyword">int</span> minute = calendar.get(Calendar.MINUTE);</span><br><span class="line">        <span class="keyword">int</span> second = calendar.get(Calendar.SECOND);</span><br><span class="line">        <span class="keyword">if</span>(calendar.get(Calendar.AM_PM) == <span class="number">0</span>)</span><br><span class="line">            am_pm = <span class="string">"AM"</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            am_pm = <span class="string">"PM"</span>;</span><br><span class="line">     </span><br><span class="line">        String CT = hour+<span class="string">":"</span>+ minute +<span class="string">":"</span>+ second +<span class="string">" "</span>+ am_pm;</span><br><span class="line">        </span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = <span class="string">"使用 Servlet 自动刷新页面"</span>;</span><br><span class="line">        String docType = <span class="string">"&lt;!DOCTYPE html&gt; \n"</span>;</span><br><span class="line">        out.println(docType +</span><br><span class="line">            <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span>+</span><br><span class="line">            <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;p&gt;当前时间是："</span> + CT + <span class="string">"&lt;/p&gt;\n"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Refresh<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.runoob.test.Refresh<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Refresh<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/TomcatTest/Refresh<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸Servlet-发送电子邮件"><a href="#🌸Servlet-发送电子邮件" class="headerlink" title="🌸Servlet 发送电子邮件"></a>🌸Servlet 发送电子邮件</h2><p>使用 Servlet 发送一封电子邮件是很简单的，但首先您必须在您的计算机上安装 <strong>JavaMail API</strong> 和 <strong>Java Activation Framework）JAF）</strong>。</p>
<ul>
<li>您可以从 Java 网站下载最新版本的 <a href="http://www.oracle.com/technetwork/java/javamail/index.html" target="_blank" rel="noopener">JavaMail</a>，打开网页右侧有个 <strong>Downloads</strong> 链接，点击它下载。</li>
<li>您可以从 Java 网站下载最新版本的 <a href="http://www.oracle.com/technetwork/articles/java/index-135046.html" target="_blank" rel="noopener">JAF（）</a>。</li>
</ul>
<p>下载并解压缩这些文件，在新创建的顶层目录中，您会发现这两个应用程序的一些 jar 文件。您需要把 <strong>mail.jar</strong> 和 <strong>activation.jar</strong> 文件添加到您的 CLASSPATH 中。</p>
<h3 id="🍁发送一封简单的电子邮件"><a href="#🍁发送一封简单的电子邮件" class="headerlink" title="🍁发送一封简单的电子邮件"></a>🍁发送一封简单的电子邮件</h3><p>下面的实例将从您的计算机上发送一封简单的电子邮件。这里假设您的<strong>本地主机</strong>已连接到互联网，并支持发送电子邮件。同时确保 Java Email API 包和 JAF 包的所有的 jar 文件在 CLASSPATH 中都是可用的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名 SendEmail.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.*;</span><br><span class="line"><span class="keyword">import</span> javax.activation.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendEmail</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>{</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                    HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">      <span class="comment">// 收件人的电子邮件 ID</span></span><br><span class="line">      String to = <span class="string">"abcd@gmail.com"</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 发件人的电子邮件 ID</span></span><br><span class="line">      String from = <span class="string">"web@gmail.com"</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 假设您是从本地主机发送电子邮件</span></span><br><span class="line">      String host = <span class="string">"localhost"</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 获取系统的属性</span></span><br><span class="line">      Properties properties = System.getProperties();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 设置邮件服务器</span></span><br><span class="line">      properties.setProperty(<span class="string">"mail.smtp.host"</span>, host);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 获取默认的 Session 对象</span></span><br><span class="line">      Session session = Session.getDefaultInstance(properties);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 设置响应内容类型</span></span><br><span class="line">      response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">      PrintWriter out = response.getWriter();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span>{</span><br><span class="line">         <span class="comment">// 创建一个默认的 MimeMessage 对象</span></span><br><span class="line">         MimeMessage message = <span class="keyword">new</span> MimeMessage(session);</span><br><span class="line">         <span class="comment">// 设置 From: header field of the header.</span></span><br><span class="line">         message.setFrom(<span class="keyword">new</span> InternetAddress(from));</span><br><span class="line">         <span class="comment">// 设置 To: header field of the header.</span></span><br><span class="line">         message.addRecipient(Message.RecipientType.TO,</span><br><span class="line">                                  <span class="keyword">new</span> InternetAddress(to));</span><br><span class="line">         <span class="comment">// 设置 Subject: header field</span></span><br><span class="line">         message.setSubject(<span class="string">"This is the Subject Line!"</span>);</span><br><span class="line">         <span class="comment">// 现在设置实际消息</span></span><br><span class="line">         message.setText(<span class="string">"This is actual message"</span>);</span><br><span class="line">         <span class="comment">// 发送消息</span></span><br><span class="line">         Transport.send(message);</span><br><span class="line">         String title = <span class="string">"发送电子邮件"</span>;</span><br><span class="line">         String res = <span class="string">"成功发送消息..."</span>;</span><br><span class="line">         String docType = <span class="string">"&lt;!DOCTYPE html&gt; \n"</span>;</span><br><span class="line">         out.println(docType +</span><br><span class="line">         <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">         <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">         <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">         <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">         <span class="string">"&lt;p align=\"center\"&gt;"</span> + res + <span class="string">"&lt;/p&gt;\n"</span> +</span><br><span class="line">         <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">      }<span class="keyword">catch</span> (MessagingException mex) {</span><br><span class="line">         mex.printStackTrace();</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SendEmail<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>SendEmail<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SendEmail<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/SendEmail<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>现在通过访问 URL <a href="http://localhost:8080/SendEmail" target="_blank" rel="noopener">http://localhost:8080/SendEmail</a> 来调用这个 Servlet。这将会发送一封电子邮件到给定的电子邮件 ID <em><a href="mailto:abcd@gmail.com">abcd@gmail.com</a></em>，并将显示下面所示的响应：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">发送电子邮件</span><br><span class="line">成功发送消息...</span><br></pre></td></tr></tbody></table></figure>

<p>如果您想要发送一封电子邮件给多个收件人，那么请使用下面的方法来指定多个电子邮件 ID：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addRecipients</span><span class="params">(Message.RecipientType type, </span></span></span><br><span class="line"><span class="function"><span class="params">                   Address[] addresses)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> MessagingException</span></span><br></pre></td></tr></tbody></table></figure>

<p>下面是对参数的描述：</p>
<ul>
<li><strong>type：</strong>这将被设置为 TO、CC 或 BCC。在这里，CC 代表抄送，BCC 代表密件抄送。例如 <em>Message.RecipientType.TO</em>。</li>
<li><strong>addresses：</strong>这是电子邮件 ID 的数组。当指定电子邮件 ID 时，您需要使用 InternetAddress() 方法。</li>
</ul>
<h3 id="🍁发送一封-HTML-电子邮件"><a href="#🍁发送一封-HTML-电子邮件" class="headerlink" title="🍁发送一封 HTML 电子邮件"></a>🍁发送一封 HTML 电子邮件</h3><p>下面的实例将从您的计算机上发送一封 HTML 格式的电子邮件。这里假设您的<strong>本地主机</strong>已连接到互联网，并支持发送电子邮件。同时确保 Java Email API 包和 JAF 包的所有的 jar 文件在 CLASSPATH 中都是可用的。</p>
<p>本实例与上一个实例很类似，但是这里我们使用 setContent() 方法来设置第二个参数为 “text/html” 的内容，该参数用来指定 HTML 内容是包含在消息中的。</p>
<p>使用这个实例，您可以发送内容大小不限的 HTML 内容。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名 SendEmail.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.*;</span><br><span class="line"><span class="keyword">import</span> javax.activation.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendEmail</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>{</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                    HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">      <span class="comment">// 收件人的电子邮件 ID</span></span><br><span class="line">      String to = <span class="string">"abcd@gmail.com"</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 发件人的电子邮件 ID</span></span><br><span class="line">      String from = <span class="string">"web@gmail.com"</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 假设您是从本地主机发送电子邮件</span></span><br><span class="line">      String host = <span class="string">"localhost"</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 获取系统的属性</span></span><br><span class="line">      Properties properties = System.getProperties();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 设置邮件服务器</span></span><br><span class="line">      properties.setProperty(<span class="string">"mail.smtp.host"</span>, host);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 获取默认的 Session 对象</span></span><br><span class="line">      Session session = Session.getDefaultInstance(properties);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 设置响应内容类型</span></span><br><span class="line">      response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">      PrintWriter out = response.getWriter();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span>{</span><br><span class="line">         <span class="comment">// 创建一个默认的 MimeMessage 对象</span></span><br><span class="line">         MimeMessage message = <span class="keyword">new</span> MimeMessage(session);</span><br><span class="line">         <span class="comment">// 设置 From: header field of the header.</span></span><br><span class="line">         message.setFrom(<span class="keyword">new</span> InternetAddress(from));</span><br><span class="line">         <span class="comment">// 设置 To: header field of the header.</span></span><br><span class="line">         message.addRecipient(Message.RecipientType.TO,</span><br><span class="line">                                  <span class="keyword">new</span> InternetAddress(to));</span><br><span class="line">         <span class="comment">// 设置 Subject: header field</span></span><br><span class="line">         message.setSubject(<span class="string">"This is the Subject Line!"</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 设置实际的 HTML 消息，内容大小不限</span></span><br><span class="line">         message.setContent(<span class="string">"&lt;h1&gt;This is actual message&lt;/h1&gt;"</span>,</span><br><span class="line">                            <span class="string">"text/html"</span> );</span><br><span class="line">         <span class="comment">// 发送消息</span></span><br><span class="line">         Transport.send(message);</span><br><span class="line">         String title = <span class="string">"发送电子邮件"</span>;</span><br><span class="line">         String res = <span class="string">"成功发送消息..."</span>;</span><br><span class="line">         String docType = <span class="string">"&lt;!DOCTYPE html&gt; \n"</span>;</span><br><span class="line">         out.println(docType +</span><br><span class="line">         <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">         <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">         <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">         <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">         <span class="string">"&lt;p align=\"center\"&gt;"</span> + res + <span class="string">"&lt;/p&gt;\n"</span> +</span><br><span class="line">         <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">      }<span class="keyword">catch</span> (MessagingException mex) {</span><br><span class="line">         mex.printStackTrace();</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>编译并运行上面的 Servlet ，在给定的电子邮件 ID 上发送 HTML 消息。</p>
<h3 id="🍁在电子邮件中发送附件"><a href="#🍁在电子邮件中发送附件" class="headerlink" title="🍁在电子邮件中发送附件"></a>🍁在电子邮件中发送附件</h3><p>下面的实例将从您的计算机上发送一封带有附件的电子邮件。这里假设您的<strong>本地主机</strong>已连接到互联网，并支持发送电子邮件。同时确保 Java Email API 包和 JAF 包的所有的 jar 文件在 CLASSPATH 中都是可用的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名 SendEmail.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.*;</span><br><span class="line"><span class="keyword">import</span> javax.activation.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendEmail</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>{</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                    HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">      <span class="comment">// 收件人的电子邮件 ID</span></span><br><span class="line">      String to = <span class="string">"abcd@gmail.com"</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 发件人的电子邮件 ID</span></span><br><span class="line">      String from = <span class="string">"web@gmail.com"</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 假设您是从本地主机发送电子邮件</span></span><br><span class="line">      String host = <span class="string">"localhost"</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 获取系统的属性</span></span><br><span class="line">      Properties properties = System.getProperties();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 设置邮件服务器</span></span><br><span class="line">      properties.setProperty(<span class="string">"mail.smtp.host"</span>, host);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 获取默认的 Session 对象</span></span><br><span class="line">      Session session = Session.getDefaultInstance(properties);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 设置响应内容类型</span></span><br><span class="line">      response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">      PrintWriter out = response.getWriter();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span>{</span><br><span class="line">         <span class="comment">// 创建一个默认的 MimeMessage 对象</span></span><br><span class="line">         MimeMessage message = <span class="keyword">new</span> MimeMessage(session);</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 设置 From: header field of the header.</span></span><br><span class="line">         message.setFrom(<span class="keyword">new</span> InternetAddress(from));</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 设置 To: header field of the header.</span></span><br><span class="line">         message.addRecipient(Message.RecipientType.TO,</span><br><span class="line">                                  <span class="keyword">new</span> InternetAddress(to));</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 设置 Subject: header field</span></span><br><span class="line">         message.setSubject(<span class="string">"This is the Subject Line!"</span>);</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 创建消息部分 </span></span><br><span class="line">         BodyPart messageBodyPart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 填写消息</span></span><br><span class="line">         messageBodyPart.setText(<span class="string">"This is message body"</span>);</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 创建一个多部分消息</span></span><br><span class="line">         Multipart multipart = <span class="keyword">new</span> MimeMultipart();</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 设置文本消息部分</span></span><br><span class="line">         multipart.addBodyPart(messageBodyPart);</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 第二部分是附件</span></span><br><span class="line">         messageBodyPart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">         String filename = <span class="string">"file.txt"</span>;</span><br><span class="line">         DataSource source = <span class="keyword">new</span> FileDataSource(filename);</span><br><span class="line">         messageBodyPart.setDataHandler(<span class="keyword">new</span> DataHandler(source));</span><br><span class="line">         messageBodyPart.setFileName(filename);</span><br><span class="line">         multipart.addBodyPart(messageBodyPart);</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 发送完整的消息部分</span></span><br><span class="line">         message.setContent(multipart );</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 发送消息</span></span><br><span class="line">         Transport.send(message);</span><br><span class="line">         String title = <span class="string">"发送电子邮件"</span>;</span><br><span class="line">         String res = <span class="string">"成功发送电子邮件..."</span>;</span><br><span class="line">         String docType = <span class="string">"&lt;!DOCTYPE html&gt; \n"</span>;</span><br><span class="line">         out.println(docType +</span><br><span class="line">         <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">         <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">         <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">         <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">         <span class="string">"&lt;p align=\"center\"&gt;"</span> + res + <span class="string">"&lt;/p&gt;\n"</span> +</span><br><span class="line">         <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">      }<span class="keyword">catch</span> (MessagingException mex) {</span><br><span class="line">         mex.printStackTrace();</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>编译并运行上面的 Servlet ，在给定的电子邮件 ID 上发送带有文件附件的消息。</p>
<h3 id="🍁用户身份认证部分"><a href="#🍁用户身份认证部分" class="headerlink" title="🍁用户身份认证部分"></a>🍁用户身份认证部分</h3><p>如果需要向电子邮件服务器提供用户 ID 和密码进行身份认证，那么您可以设置如下属性：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">props.setProperty(<span class="string">"mail.user"</span>, <span class="string">"myuser"</span>);</span><br><span class="line">props.setProperty(<span class="string">"mail.password"</span>, <span class="string">"mypwd"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>电子邮件发送机制的其余部分与上面讲解的保持一致。</p>
<h2 id="🌸Servlet包"><a href="#🌸Servlet包" class="headerlink" title="🌸Servlet包"></a>🌸Servlet包</h2><p>涉及到 WEB-INF 子目录的 Web 应用程序结构是所有的 Java web 应用程序的标准，并由 Servlet API 规范指定。给定一个顶级目录名 myapp，目录结构如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">/myapp</span><br><span class="line">    /images</span><br><span class="line">    /WEB-INF</span><br><span class="line">        /classes</span><br><span class="line">        /lib</span><br></pre></td></tr></tbody></table></figure>

<p>WEB-INF 子目录中包含应用程序的部署描述符，名为 web.xml。所有的 HTML 文件都位于顶级目录 <em>myapp</em> 下。对于 admin 用户，您会发现 ROOT 目录是 myApp 的父目录。</p>
<h3 id="🍁创建包中的-Servlet"><a href="#🍁创建包中的-Servlet" class="headerlink" title="🍁创建包中的 Servlet"></a>🍁创建包中的 Servlet</h3><p>WEB-INF/classes 目录包含了所有的 Servlet 类和其他类文件，类文件所在的目录结构与他们的包名称匹配。例如，如果您有一个完全合格的类名称 <strong>com.myorg.MyServlet</strong>，那么这个 Servlet 类必须位于以下目录中：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/myapp/WEB-INF/classes/com/myorg/MyServlet.class</span><br></pre></td></tr></tbody></table></figure>

<p>下面的例子创建包名为 <em>com.myorg</em> 的 MyServlet 类。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 为包命名</span></span><br><span class="line"><span class="keyword">package</span> com.myorg;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入必需的 java 库</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/MyServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> String message;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException</span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">      <span class="comment">// 执行必需的的初始化</span></span><br><span class="line">      message = <span class="string">"Hello World"</span>;</span><br><span class="line">  }</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                    HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">      <span class="comment">// 设置响应内容类型</span></span><br><span class="line">      response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 实际的逻辑是在这里</span></span><br><span class="line">      PrintWriter out = response.getWriter();</span><br><span class="line">      out.println(<span class="string">"&lt;h1&gt;"</span> + message + <span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">      <span class="comment">// 什么也不做</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁编译包中的-Servlet"><a href="#🍁编译包中的-Servlet" class="headerlink" title="🍁编译包中的 Servlet"></a>🍁编译包中的 Servlet</h3><p>编译包中的类与编译其他的类没有什么大的不同。最简单的方法是让您的 java 文件保留完全限定路径，如上面提到的类，将被保留在 com.myorg 中。您还需要在 CLASSPATH 中添加该目录。</p>
<p>假设您的环境已正确设置，进入 <strong><tomcat-installation-directory>/webapps/ROOT/WEB-INF/classes</tomcat-installation-directory></strong> 目录，并编译 MyServlet.java，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ javac MyServlet.java</span><br></pre></td></tr></tbody></table></figure>

<p>如果 Servlet 依赖于其他库，那么您必须在 CLASSPATH 中也要引用那些 JAR 文件。这里我只引用了 servlet-api.jar JAR 文件，因为我在 Hello World 程序中并没有使用任何其他库。</p>
<p>该命令行使用内置的 javac 编译器，它是 Sun Microsystems Java 软件开发工具包（JDK，全称 Java Software Development Kit）附带的。 Microsystems的Java软件开发工具包（JDK）。为了让该命令正常工作，必须包括您在 PATH 环境变量中所使用的 Java SDK 的位置。</p>
<p>如果一切顺利，上述编译会在同一目录下生成 <strong>MyServlet.class</strong> 文件。下一节将解释如何把一个已编译的 Servlet 部署到生产中。</p>
<h3 id="🍁Servlet-打包部署"><a href="#🍁Servlet-打包部署" class="headerlink" title="🍁Servlet 打包部署"></a>🍁Servlet 打包部署</h3><p>默认情况下，Servlet 应用程序位于路径 <tomcat-installation-directory>/webapps/ROOT 下，且类文件放在 <tomcat-installation-directory>/webapps/ROOT/WEB-INF/classes 中。</tomcat-installation-directory></tomcat-installation-directory></p>
<p>如果您有一个完全合格的类名称 <strong>com.myorg.MyServlet</strong>，那么这个 Servlet 类必须位于 WEB-INF/classes/com/myorg/MyServlet.class 中，您需要在位于 <tomcat-installation-directory>/webapps/ROOT/WEB-INF/ 的 web.xml 文件中创建以下条目：</tomcat-installation-directory></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.myorg.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/MyServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>上面的条目要被创建在 web.xml 文件中的 <web-app>…</web-app> 标签内。在该文件中可能已经有各种可用的条目，但不要在意。</p>
<p>到这里，您基本上已经完成了，现在让我们使用 <tomcat-installation-directory>\bin\startup.bat（在 Windows 上）或 <tomcat-installation-directory>/bin/startup.sh（在 Linux/Solaris 等上）启动 tomcat 服务器，最后在浏览器的地址栏中输入 <strong><a href="http://localhost:8080/MyServlet" target="_blank" rel="noopener">http://localhost:8080/MyServlet</a></strong>。</tomcat-installation-directory></tomcat-installation-directory></p>
<h2 id="🌸Servlet-调试"><a href="#🌸Servlet-调试" class="headerlink" title="🌸Servlet 调试"></a>🌸Servlet 调试</h2><p>测试/调试 Servlet 始终是开发使用过程中的难点。Servlet 往往涉及大量的客户端/服务器交互，可能会出现错误但又难以重现。</p>
<p>这里有一些提示和建议，可以帮助您调试。</p>
<h3 id="🍁System-out-println"><a href="#🍁System-out-println" class="headerlink" title="🍁System.out.println()"></a>🍁System.out.println()</h3><p>System.out.println() 是作为一个标记来使用的，用来测试一段特定的代码是否被执行。我们也可以打印出变量的值。此外：</p>
<ul>
<li>由于 System 对象是核心 Java 对象的一部分，它可以在不需要安装任何额外类的情况下被用于任何地方。这包括 Servlet、JSP、RMI、EJB’s、普通的 Beans 和类，以及独立的应用程序。</li>
<li>与在断点处停止不同，写入到 System.out 不会干扰到应用程序的正常执行流程，这使得它在时序是至关重要的时候显得尤为有价值。</li>
</ul>
<p>下面是使用 System.out.println() 的语法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">System.out.println("Debugging message");</span><br></pre></td></tr></tbody></table></figure>

<p>通过上面的语法生成的所有消息将被记录在 Web 服务器日志文件中。</p>
<h3 id="🍁消息日志"><a href="#🍁消息日志" class="headerlink" title="🍁消息日志"></a>🍁消息日志</h3><p>使用适当的日志记录方法来记录所有调试、警告和错误消息，这是非常好的想法，推荐使用 <a href="https://logging.apache.org/log4j/2.0/download.html" target="_blank" rel="noopener">log4J</a> 来记录所有的消息。</p>
<p>Servlet API 还提供了一个简单的输出信息的方式，使用 log() 方法，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 导入必需的 java 库</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLog</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">      HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException,</span></span><br><span class="line"><span class="function">         java.io.IOException </span>{</span><br><span class="line">    </span><br><span class="line">      String par = request.getParameter(<span class="string">"par1"</span>);</span><br><span class="line">      <span class="comment">// 调用两个 ServletContext.log 方法</span></span><br><span class="line">      ServletContext context = getServletContext( );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (par == <span class="keyword">null</span> || par.equals(<span class="string">""</span>))</span><br><span class="line">      <span class="comment">// 通过 Throwable 参数记录版本</span></span><br><span class="line">      context.log(<span class="string">"No message received:"</span>,</span><br><span class="line">          <span class="keyword">new</span> IllegalStateException(<span class="string">"Missing parameter"</span>));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          context.log(<span class="string">"Here is the visitor's message: "</span> + par);</span><br><span class="line">      </span><br><span class="line">      response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">      java.io.PrintWriter out = response.getWriter( );</span><br><span class="line">      String title = <span class="string">"Context Log"</span>;</span><br><span class="line">      String docType = <span class="string">"&lt;!DOCTYPE html&gt; \n"</span>;</span><br><span class="line">      out.println(docType +</span><br><span class="line">        <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">        <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">        <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">        <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">        <span class="string">"&lt;h2 align=\"center\"&gt;Messages sent&lt;/h2&gt;\n"</span> +</span><br><span class="line">        <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">    } <span class="comment">//doGet</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>ServletContext 把它的文本消息记录到 Servlet 容器的日志文件中。对于 Tomcat，这些日志可以在 <tomcat-installation-directory>/logs 目录中找到。</tomcat-installation-directory></p>
<p>这些日志文件确实对新出现的错误或问题的频率给出指示。正因为如此，建议在通常不会发生的异常的 catch 子句中使用 log() 函数。</p>
<h3 id="🍁使用-JDB-调试器"><a href="#🍁使用-JDB-调试器" class="headerlink" title="🍁使用 JDB 调试器"></a>🍁使用 JDB 调试器</h3><p>可以使用调试 applet 或应用程序的 jdb 命令来调试 Servlet。</p>
<p>为了调试一个 Servlet，我们可以调试 sun.servlet.http.HttpServer，然后把它看成是 HttpServer 执行 Servlet 来响应浏览器端的 HTTP 请求。这与调试 applet 小程序非常相似。与调试 applet 不同的是，实际被调试的程序是 sun.applet.AppletViewer。</p>
<p>大多数调试器会自动隐藏如何调试 applet 的细节。同样的，对于 servlet，您必须帮调试器执行以下操作：</p>
<ul>
<li>设置您的调试器的类路径 classpath，以便它可以找到 sun.servlet.http.Http-Server 和相关的类。</li>
<li>设置您的调试器的类路径 classpath，以便它可以找到您的 servlet 和支持的类，通常是在 server_root/servlets 和 server_root/classes 中。</li>
</ul>
<p>您通常不会希望 server_root/servlets 在您的 classpath 中，因为它会禁用 servlet 的重新加载。但是这种包含规则对于调试是非常有用的。它允许您的调试器在 HttpServer 中的自定义 Servlet 加载器加载 Servlet 之前在 Servlet 中设置断点。</p>
<p>如果您已经设置了正确的类路径 classpath，就可以开始调试 sun.servlet.http.HttpServer。可以在您想要调试的 Servlet 代码中设置断点，然后通过 Web 浏览器使用给定的 Servlet（<a href="http://localhost:8080/servlet/ServletToDebug）向" target="_blank" rel="noopener">http://localhost:8080/servlet/ServletToDebug）向</a> HttpServer 发出请求。您会看到程序执行到断点处会停止。</p>
<h3 id="🍁使用注释"><a href="#🍁使用注释" class="headerlink" title="🍁使用注释"></a>🍁使用注释</h3><p>代码中的注释有助于以各种方式进行调试。注释可用于调试过程的很多其他方式中。</p>
<p>该 Servlet 使用 Java 注释和单行注释（//…），多行注释（/* …*/）可用于暂时移除部分 Java 代码。如果 bug 消失，仔细看看您刚才注释的代码并找出问题所在。</p>
<h3 id="🍁客户端和服务器端头信息"><a href="#🍁客户端和服务器端头信息" class="headerlink" title="🍁客户端和服务器端头信息"></a>🍁客户端和服务器端头信息</h3><p>有时，当一个 Servlet 并没有像预期那样时，查看原始的 HTTP 请求和响应是非常有用的。如果您熟悉 HTTP 结构，您可以阅读请求和响应，看看这些头信息究竟是什么。</p>
<h3 id="🍁重要的调试技巧"><a href="#🍁重要的调试技巧" class="headerlink" title="🍁重要的调试技巧"></a>🍁重要的调试技巧</h3><p>下面列出了一些 Servlet 调试的技巧：</p>
<ul>
<li>请注意，server_root/classes 不会重载，而 server_root/servlets 可能会。</li>
<li>要求浏览器显示它所显示的页面的原始内容。这有助于识别格式的问题。它通常是”视图”菜单下的一个选项。</li>
<li>通过强制执行完全重新加载页面来确保浏览器还没有缓存前一个请求的输出。在 Netscape Navigator 中，请使用 Shift-Reload，在 Internet Explorer 中，请使用 Shift-Refresh。</li>
<li>请确认 servlet 的 init() 方法接受一个 ServletConfig 参数，并调用 super.init(config)。</li>
</ul>
<h2 id="🌸servlet国际化"><a href="#🌸servlet国际化" class="headerlink" title="🌸servlet国际化"></a>🌸servlet国际化</h2><p>在我们开始之前，先来看看三个重要术语：</p>
<ul>
<li><strong>国际化（i18n）：</strong>这意味着一个网站提供了不同版本的翻译成访问者的语言或国籍的内容。</li>
<li><strong>本地化（l10n）：</strong>这意味着向网站添加资源，以使其适应特定的地理或文化区域，例如网站翻译成印地文（Hindi）。</li>
<li><strong>区域设置（locale）：</strong>这是一个特殊的文化或地理区域。它通常指语言符号后跟一个下划线和一个国家符号。例如 “en_US” 表示针对 US 的英语区域设置。</li>
</ul>
<p>当建立一个全球性的网站时有一些注意事项。本教程不会讲解这些注意事项的完整细节，但它会通过一个很好的实例向您演示如何通过差异化定位（即区域设置）来让网页以不同语言呈现。</p>
<p>Servlet 可以根据请求者的区域设置拾取相应版本的网站，并根据当地的语言、文化和需求提供相应的网站版本。以下是 request 对象中返回 Locale 对象的方法。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">java.util.Locale request.getLocale()</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁检测区域设置"><a href="#🍁检测区域设置" class="headerlink" title="🍁检测区域设置"></a>🍁检测区域设置</h3><p>下面列出了重要的区域设置方法，您可以使用它们来检测请求者的地理位置、语言和区域设置。下面所有的方法都显示了请求者浏览器中设置的国家名称和语言名称。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>String getCountry()</strong> 该方法以 2 个大写字母形式的 ISO 3166 格式返回该区域设置的国家/地区代码。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>String getDisplayCountry()</strong> 该方法返回适合向用户显示的区域设置的国家的名称。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>String getLanguage()</strong> 该方法以小写字母形式的 ISO 639 格式返回该区域设置的语言代码。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>String getDisplayLanguage()</strong> 该方法返回适合向用户显示的区域设置的语言的名称。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>String getISO3Country()</strong> 该方法返回该区域设置的国家的三个字母缩写。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>String getISO3Language()</strong> 该方法返回该区域设置的语言的三个字母的缩写。</td>
</tr>
</tbody></table>
<h3 id="🍁实例-4"><a href="#🍁实例-4" class="headerlink" title="🍁实例"></a>🍁实例</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetLocale</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>{</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                    HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">      <span class="comment">// 获取客户端的区域设置</span></span><br><span class="line">      Locale locale = request.getLocale();</span><br><span class="line">      String language = locale.getLanguage();</span><br><span class="line">      String country = locale.getCountry();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置响应内容类型</span></span><br><span class="line">      response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">      PrintWriter out = response.getWriter();</span><br><span class="line"></span><br><span class="line">      String title = <span class="string">"检测区域设置"</span>;</span><br><span class="line">      String docType = <span class="string">"&lt;!DOCTYPE html&gt; \n"</span>;</span><br><span class="line">      out.println(docType +</span><br><span class="line">        <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">        <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">        <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">        <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + language + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">        <span class="string">"&lt;h2 align=\"center\"&gt;"</span> + country + <span class="string">"&lt;/h2&gt;\n"</span> +</span><br><span class="line">        <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁语言设置"><a href="#🍁语言设置" class="headerlink" title="🍁语言设置"></a>🍁语言设置</h3><p>Servlet 可以输出以西欧语言（如英语、西班牙语、德语、法语、意大利语、荷兰语等）编写的页面。在这里，为了能正确显示所有的字符，设置 Content-Language 头是非常重要的。</p>
<p>第二点是使用 HTML 实体显示所有的特殊字符，例如，”ñ” 表示 “ñ”，”¡” 表示 “¡”，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisplaySpanish</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>{</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                    HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 设置响应内容类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">    PrintWriter out = response.getWriter();</span><br><span class="line">    <span class="comment">// 设置西班牙语言代码</span></span><br><span class="line">    response.setHeader(<span class="string">"Content-Language"</span>, <span class="string">"es"</span>);</span><br><span class="line"></span><br><span class="line">    String title = <span class="string">"En Espa&amp;ntilde;ol"</span>;</span><br><span class="line">    String docType = <span class="string">"&lt;!DOCTYPE html&gt; \n"</span>;</span><br><span class="line">     out.println(docType +</span><br><span class="line">     <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">     <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">     <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">     <span class="string">"&lt;h1&gt;"</span> + <span class="string">"En Espa&amp;ntilde;ol:"</span> + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">     <span class="string">"&lt;h1&gt;"</span> + <span class="string">"&amp;iexcl;Hola Mundo!"</span> + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">     <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁特定于区域设置的日期"><a href="#🍁特定于区域设置的日期" class="headerlink" title="🍁特定于区域设置的日期"></a>🍁特定于区域设置的日期</h3><p>可以使用 java.text.DateFormat 类及其静态方法 getDateTimeInstance() 来格式化特定于区域设置的日期和时间。下面的实例演示了如何格式化特定于某个给定的区域设置的日期：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateLocale</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>{</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                    HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 设置响应内容类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">    PrintWriter out = response.getWriter();</span><br><span class="line">    <span class="comment">// 获取客户端的区域设置</span></span><br><span class="line">    Locale locale = request.getLocale( );</span><br><span class="line">    String date = DateFormat.getDateTimeInstance(</span><br><span class="line">                                  DateFormat.FULL, </span><br><span class="line">                                  DateFormat.SHORT, </span><br><span class="line">                                  locale).format(<span class="keyword">new</span> Date( ));</span><br><span class="line"></span><br><span class="line">    String title = <span class="string">"特定于区域设置的日期"</span>;</span><br><span class="line">    String docType = <span class="string">"&lt;!DOCTYPE html&gt; \n"</span>;</span><br><span class="line">      out.println(docType +</span><br><span class="line">      <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">      <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">      <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">      <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + date + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">      <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁特定于区域设置的货币"><a href="#🍁特定于区域设置的货币" class="headerlink" title="🍁特定于区域设置的货币"></a>🍁特定于区域设置的货币</h3><p>可以使用 java.text.NumberFormat 类及其静态方法 getCurrencyInstance() 来格式化数字（比如 long 类型或 double 类型）为特定于区域设置的货币。下面的实例演示了如何格式化特定于某个给定的区域设置的货币：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">javaimport java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.text.NumberFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrencyLocale</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>{</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                    HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 设置响应内容类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">    PrintWriter out = response.getWriter();</span><br><span class="line">    <span class="comment">// 获取客户端的区域设置</span></span><br><span class="line">    Locale locale = request.getLocale( );</span><br><span class="line">    NumberFormat nft = NumberFormat.getCurrencyInstance(locale);</span><br><span class="line">    String formattedCurr = nft.format(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line">    String title = <span class="string">"特定于区域设置的货币"</span>;</span><br><span class="line">    String docType = <span class="string">"&lt;!DOCTYPE html&gt; \n"</span>;</span><br><span class="line">      out.println(docType +</span><br><span class="line">      <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">      <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">      <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">      <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + formattedCurr + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">      <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁特特定于区域设置的百分比"><a href="#🍁特特定于区域设置的百分比" class="headerlink" title="🍁特特定于区域设置的百分比"></a>🍁特特定于区域设置的百分比</h3><p>可以使用 java.text.NumberFormat 类及其静态方法 getPercentInstance() 来格式化特定于区域设置的百分比。下面的实例演示了如何格式化特定于某个给定的区域设置的百分比：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.text.NumberFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PercentageLocale</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>{</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                    HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="comment">// 设置响应内容类型</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">    PrintWriter out = response.getWriter();</span><br><span class="line">    <span class="comment">// 获取客户端的区域设置</span></span><br><span class="line">    Locale locale = request.getLocale( );</span><br><span class="line">    NumberFormat nft = NumberFormat.getPercentInstance(locale);</span><br><span class="line">    String formattedPerc = nft.format(<span class="number">0.51</span>);</span><br><span class="line"></span><br><span class="line">    String title = <span class="string">"特定于区域设置的百分比"</span>;</span><br><span class="line">    String docType = <span class="string">"&lt;!DOCTYPE html&gt; \n"</span>;</span><br><span class="line">      out.println(docType +</span><br><span class="line">      <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">      <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">      <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">      <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + formattedPerc + <span class="string">"&lt;/h1&gt;\n"</span> +</span><br><span class="line">      <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>后端</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>学习笔记</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA与JDBC的区别和基本用法</title>
    <url>/The_difference_and_basic_usage_of_JPA_and_JDBC/</url>
    <content><![CDATA[<blockquote>
<p>JPA（Java Persistence API）用于对象持久化的 API，是 Java EE 5.0 平台标准的 ORM 规范，使得应用程序以统一的方式访问持久层。</p>
</blockquote>
<a id="more"></a>

<h1 id="JPA-与-JDBC-的区别和基本用法"><a href="#JPA-与-JDBC-的区别和基本用法" class="headerlink" title="JPA 与 JDBC 的区别和基本用法"></a>JPA 与 JDBC 的区别和基本用法</h1><p><a href="https://www.cnblogs.com/yunche/p/10279324.html" target="_blank" rel="noopener">原文地址</a></p>
<h2 id="JPA-概念"><a href="#JPA-概念" class="headerlink" title="JPA 概念"></a>JPA 概念</h2><p>JPA（Java Persistence API）用于对象持久化的 API，是 Java EE 5.0 平台标准的 ORM 规范，使得应用程序以统一的方式访问持久层。</p>
<h3 id="与-JDBC-的对比"><a href="#与-JDBC-的对比" class="headerlink" title="与 JDBC 的对比"></a>与 JDBC 的对比</h3><p>JDBC 也是一种规范和接口，不过 JDBC 是面向 SQL 的，使用起来比较繁琐。所以就有了 ORM 框架，建立了 Java 对象与数据库表之间的映射关系，可以通过直接操作对象来实现持久化，简化了操作的繁杂度。而 JPA 就是 ORM 框架的规范，值得一提的是 Hibernate 是符合 JPA 规范的，而 MyBatis 却不符合，因为 MyBatis 还是需要写 SQL 的。</p>
<p>JDBC 示意图：</p>
<p><img src="https://www.cnblogs.com/images/cnblogs_com/yunche/1384050/o_jdbc.png" alt="img"></p>
<p>JPA 示意图：</p>
<p><img src="https://www.cnblogs.com/images/cnblogs_com/yunche/1384050/o_JPA.png" alt="img"></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在 IDEA 下创建一个 JPA 项目，并实现基本的 CRUD。</p>
<p>1、创建一个 JavaEE Persistence 项目，具体如下所示</p>
<p><img src="https://www.cnblogs.com/images/cnblogs_com/yunche/1384050/o_1.png" alt="img"></p>
<p>采用 Hibernate 实现 JPA。</p>
<p>2、导入相应的 Maven 依赖</p>
<p><img src="https://www.cnblogs.com/images/cnblogs_com/yunche/1384050/o_2.1.png" alt="img"></p>
<p>添加 Maven 支持。</p>
<p>pom.xml:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>groupId<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jpa-helloworld<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-entitymanager --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-entitymanager<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>3、配置数据库（MySQL 8）相关内容 persistence.xml</p>
<p>注意此文件要位于类路径下，这里放在 resources/META-INF 下。</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">persistence</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/persistence"</span> <span class="attr">version</span>=<span class="string">"2.0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">persistence-unit</span> <span class="attr">name</span>=<span class="string">"jpa-1"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--是 PersistenceProvider 接口的实现类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span>&gt;</span>org.hibernate.jpa.HibernatePersistenceProvider<span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--添加持久化类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>com.yunche.helloworld.Customer<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/jpa?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.archive.autodetection"</span> <span class="attr">value</span>=<span class="string">"class"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--注意这个属性，自动生成的文件前面没有 hibernate，要加上 hibernate --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.hbm2ddl.auto"</span> <span class="attr">value</span>=<span class="string">"update"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 使用 MySQL8Dialect --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span> <span class="attr">value</span>=<span class="string">"org.hibernate.dialect.MySQL8Dialect"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">persistence-unit</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistence</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>4、新建一个持久化对象类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yunche.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: Customer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: yunche</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/01/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Entity</span>(name = <span class="string">"customers"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"last_name"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>并在 persistence.xml 中的 persistence-unit 节点下加入：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!--添加持久化类--&gt;</span><br><span class="line">&lt;!--后来发现：似乎可以不加--&gt;</span><br><span class="line">&lt;class&gt;com.yunche.helloworld.Customer&lt;/class&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>5、Main 类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yunche.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManager;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManagerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityTransaction;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Persistence;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: Main</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: yunche</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/01/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//persistence.xml 中的 persistence-unit</span></span><br><span class="line">        String persistenceUnitName = <span class="string">"jpa-1"</span>;</span><br><span class="line">        <span class="comment">//1、创建 EntityManagerFactory</span></span><br><span class="line">        EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(persistenceUnitName);</span><br><span class="line">        <span class="comment">//2、创建 EntityManager</span></span><br><span class="line">        EntityManager entityManager = entityManagerFactory.createEntityManager();</span><br><span class="line">        <span class="comment">//3、开启事务</span></span><br><span class="line">        EntityTransaction transaction = entityManager.getTransaction();</span><br><span class="line">        transaction.begin();</span><br><span class="line">        <span class="comment">//4、进行持久化操作</span></span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">        customer.setAge(<span class="number">13</span>);</span><br><span class="line">        customer.setLastName(<span class="string">"li"</span>);</span><br><span class="line">        customer.setEmail(<span class="string">"123@qq.com"</span>);</span><br><span class="line"></span><br><span class="line">        entityManager.persist(customer);</span><br><span class="line">        <span class="comment">//5、提交事务</span></span><br><span class="line">        transaction.commit();</span><br><span class="line">        <span class="comment">//6、关闭 EntityManager</span></span><br><span class="line">        entityManager.close();</span><br><span class="line">        <span class="comment">//7、关闭 EntityManagerFactory</span></span><br><span class="line">        entityManagerFactory.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>6、结果</p>
<p><img src="https://www.cnblogs.com/images/cnblogs_com/yunche/1384050/o_output.png" alt="img"></p>
<p><img src="https://www.cnblogs.com/images/cnblogs_com/yunche/1384050/o_result.png" alt="img"></p>
<p>7、注意事项<br>我后来发现了一点问题，关于包 javax.persistence-api 的，我创建项目的时候选中了 persistence 2.0 , IDEA 自动导入了 javax.persistence-api-2.0.jar，而 maven 下的 hibernate-entitymanager 依赖含有 javax.persistence-api-2.2.jar ，所以 jar 包重复了，并且我发现2.0版本的有些方法没有，所以还是将2.0版本的jar包删除，用 2.2 版本的。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>后端</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JPA</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>关于数据库和mybatis的mapper关系</title>
    <url>/Mapper_relation_of_mybatis/</url>
    <content><![CDATA[<blockquote>
<p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。</p>
</blockquote>
<a id="more"></a>

<h1 id="关于数据库mybatis的mapper关系"><a href="#关于数据库mybatis的mapper关系" class="headerlink" title="关于数据库mybatis的mapper关系"></a>关于数据库mybatis的mapper关系</h1><p><a href="https://blog.csdn.net/weixin_42603009/article/details/91981037" target="_blank" rel="noopener">原文地址</a></p>
<p>这里说明一下关于数据库，数据库对应实体各种复杂情况关系映射。<br>最基本的实体：<br>比如：（这里面不涉及复杂map,list,set等）</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUser</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer testUserNo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String testUserName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String testUserSex;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>数据库：<br><img src="https://img-blog.csdnimg.cn/20190614160536245.png" alt="在这里插入图片描述"><br>resultMap最终将数据库查出的结果，映射到pojo（实体）上<br>type是指定映射到哪一个实体；id是相对应的resultMap的id</p>
<p>这里有两种属性，主键属性和普通属性<br>1,主键属性方式（是主键）<br>user_no是主键：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">&lt;id property=<span class="string">"testUserNo"</span> column=<span class="string">"user_no"</span>/&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>2,普通属性（即不是主键）<br>user_name不是主键</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">&lt;result property=<span class="string">"testUserName"</span> column=<span class="string">"user_name"</span>/&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>完整的mapper.xml</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="string">"http://www.mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;!-- namespace是对应的定义方法mapper，会去拿到对应的geTestUsers方法。这样才建立起了输入，返回的对应的关系 --&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.cun.mapper.TestUserMapper"</span>&gt;</span><br><span class="line">&lt;resultMap type=<span class="string">"com.cun.entity.TestUser"</span> id=<span class="string">"TestUser"</span>&gt;</span><br><span class="line">&lt;!-- property是对应的实体属性，column是对应的数据库column项--&gt;</span><br><span class="line">	&lt;id property=<span class="string">"testUserNo"</span> column=<span class="string">"user_no"</span>/&gt; </span><br><span class="line">	&lt;result property=<span class="string">"testUserName"</span> column=<span class="string">"user_name"</span>/&gt;</span><br><span class="line">	&lt;result property=<span class="string">"testUserSex"</span> column=<span class="string">"user_sex"</span>/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">"geTestUsers"</span> resultMap=<span class="string">"TestUser"</span>&gt;</span><br><span class="line">    select * from test_user</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>在我们深入更加复杂情况前，我们需要了解mapper3.0下常用的标签。我们从mapper开始讲起。<br>mapper: 是总标签，所有标签都包含在内。<br>namespace：命名空间。如果采用的是Mapper接口代理的方式开发，Mapper的映射文件中namespace必须为接口的全名，比如这里namespace=“com.cun.mapper.TestUserMapper”。<br><img src="https://img-blog.csdnimg.cn/2019061420233673.png" alt="在这里插入图片描述"><br>最常见的增删改查select，insert，update，delete。</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"Mapper.EmpMapper"</span>&gt;</span><br><span class="line">	<span class="comment">// CURD操作标签</span></span><br><span class="line">	<span class="comment">// 查  parameterType入参类型   resultType返回类型  id是唯一标识符</span></span><br><span class="line">	&lt;select id="" parameterType="" resultType=""&gt; &lt;/select&gt;</span><br><span class="line">	&lt;insert id="" parameterType=""&gt; &lt;/insert&gt;</span><br><span class="line">	&lt;delete id="" parameterType=""&gt; &lt;/delete&gt;</span><br><span class="line">	&lt;update id="" parameterType=""&gt; &lt;/update&gt;</span><br><span class="line">    <span class="comment">// if片段</span></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>每一个其中的内含标签：<br><img src="https://img-blog.csdnimg.cn/20190614212707731.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190614212756788.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190614212942527.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190614213051667.png" alt="在这里插入图片描述"><br>下面逐一介绍其中的Content Model(内容模型)<br>selectKey : 标签表示子查询中主键的提取问题<br>它其中的标记：<br>keyColumn表示查询语句返回结果的列名<br>keyProperty表示将属性设置到某个列中<br>order=”BEFORE表示在插入语句之前执行<br>resultType=”int”表示返回值得类型为int类型<br><img src="https://img-blog.csdnimg.cn/20190614222555214.png" alt="在这里插入图片描述"><br>include：引入定义号的公共sql<br>这里不得不的引入另一个标签sql,因为这两者搭配使用。<br>例子：（通常用于有一段sql文，很长而且重复多次使用，我们把它抽象出来，之后直接引用）</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!--<span class="number">1</span>、首先定义一个sql标签，一定要定义唯一id。（name,age是要查询的字段）--&gt;</span><br><span class="line">&lt;sql id="Base_Column_List" &gt;name,age&lt;/sql&gt;</span><br><span class="line">&lt;!--<span class="number">2</span>、然后通过id引用--&gt;</span><br><span class="line">&lt;select id=<span class="string">"selectAll"</span>&gt;</span><br><span class="line">select </span><br><span class="line">&lt;include refid=<span class="string">"Base_Column_List"</span> /&gt;</span><br><span class="line">	from student</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;!--这个&lt;include refid=<span class="string">"Base_Column_List"</span> /&gt;会自动把上面的代码贴过来。--&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>trim : （这个不常用）<br>prefix：前缀；suffix：后缀<br>prefixOverrides：忽略第一个指定分隔符；suffixOverrides：会略最后一个分隔符。</p>
<p>如果id为null执行的sql语句为:<br>select * from user where name=“xxx” and gender=“xxx”<br>where : 主要是用来简化 sql 语句中 where 条件判断，自动地处理 AND/OR 条件。<br>例子：（并自动地把首个 and / or 给忽略。）</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">"geTestUsers"</span> parameterType=<span class="string">"com.cun.entity.TestUser"</span> resultMap=<span class="string">"TestUser"</span>&gt;</span><br><span class="line">    select user_no,user_name,user_sex </span><br><span class="line">    from test_user </span><br><span class="line">    &lt;where&gt;</span><br><span class="line">        &lt;<span class="keyword">if</span> test=<span class="string">"testUserNo != null"</span>&gt;</span><br><span class="line">            user_no = #{testUserNo}</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;<span class="keyword">if</span> test=<span class="string">"testUserName != null"</span>&gt;</span><br><span class="line">            and user_name = #{testUserName}</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;<span class="keyword">if</span> test=<span class="string">"testUserSex != null"</span>&gt;</span><br><span class="line">            and user_sex = #{testUserSex}</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>set : （主要作用于update语句）时若使用if标签，如果前面的if没有执行，则可能导致有多余逗号的错误。使用set标签可以将动态的配置SET 关键字，和剔除追加到条件末尾的任何不相关的逗号。<br>例子：（这里有一个坑，写完需要加逗号）</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">&lt;update id=<span class="string">"updateByPrimaryKeySelective"</span> parameterType=<span class="string">"RecruitmentConfBanner"</span>&gt;</span><br><span class="line">    UPDATE conf_banner t</span><br><span class="line">    &lt;set&gt; </span><br><span class="line">        &lt;<span class="keyword">if</span> test=<span class="string">"bannerName != null"</span>&gt;</span><br><span class="line">            t.banner_name = #{bannerName},</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;<span class="keyword">if</span> test=<span class="string">"bannerUrl != null"</span>&gt;</span><br><span class="line">            t.banner_url = #{bannerUrl},</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;<span class="keyword">if</span> test=<span class="string">"bannerLogo != null"</span>&gt;</span><br><span class="line">            t.banner_logo = #{bannerLogo},</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">    where t.banner_id = #{bannerId}</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>foreach : 主要用于批量删除或批量插入。<br>它的6个参数说明：<br>collection：要循环的集合<br>index：循环索引；<br>item：集合中的一个元素（item和collection，按foreach循环理解）；<br>open：以什么开始；<br>close：以什么结束；<br>separator：循环内容之间以什么分隔<br>mybatis接受的参数分为：（1）基本类型；（2）对象；（3）List；（4）数组；（5）Map<br>例子：（入参为list，collection为list）</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">&lt;update id=<span class="string">"deleteWorkshopByIds"</span> parameterType=<span class="string">"Integer"</span> &gt;</span><br><span class="line">	update workshop set status =<span class="number">0</span></span><br><span class="line">	where id in</span><br><span class="line">  &lt;foreach collection=<span class="string">"list"</span> index=<span class="string">"i"</span> item=<span class="string">"id"</span> open=<span class="string">"("</span> separator=<span class="string">","</span> close=<span class="string">")"</span>&gt;</span><br><span class="line">  	#{id}</span><br><span class="line">  &lt;/foreach&gt;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>choose : 是按顺序判断其内部when标签中的test条件出否成立，如果有一个成立，则 choose 结束。当 choose 中所有 when 的条件都不满则时，则执行 otherwise 中的sql。<br>例子：</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!--  choose(判断参数) - 按顺序将实体类 User 第一个不为空的属性作为：where条件 --&gt;  </span><br><span class="line">&lt;select id=<span class="string">"getUserList_choose"</span> resultMap=<span class="string">"resultMap_user"</span> parameterType=<span class="string">"com.yiibai.pojo.User"</span>&gt;  </span><br><span class="line">SELECT *  </span><br><span class="line">  FROM User u   </span><br><span class="line">&lt;where&gt;  </span><br><span class="line">    &lt;choose&gt;  </span><br><span class="line">        &lt;when test=<span class="string">"username !=null "</span>&gt;  </span><br><span class="line">            u.<span class="function">username LIKE <span class="title">CONCAT</span><span class="params">(CONCAT(<span class="string">'%'</span>, #{username, jdbcType=VARCHAR})</span>,'%')  </span></span><br><span class="line"><span class="function">        &lt;/when &gt;  </span></span><br><span class="line"><span class="function">        &lt;when test</span>=<span class="string">"sex != null and sex != '' "</span>&gt;  </span><br><span class="line">            AND u.sex = #{sex, jdbcType=INTEGER}  </span><br><span class="line">        &lt;/when &gt;  </span><br><span class="line">        &lt;when test=<span class="string">"birthday != null "</span>&gt;  </span><br><span class="line">            AND u.birthday = #{birthday, jdbcType=DATE}  </span><br><span class="line">        &lt;/when &gt;  </span><br><span class="line">        &lt;otherwise&gt;  </span><br><span class="line">        &lt;/otherwise&gt;  </span><br><span class="line">    &lt;/choose&gt;  </span><br><span class="line">&lt;/where&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>标签<br>if : 这个签前面已经涉及到了。<br>bind : 可以从 OGNL 表达式中创建一个变量并将其绑定到上下文</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">"selectBlogsLike"</span> resultType=<span class="string">"Blog"</span>&gt;</span><br><span class="line">	&lt;bind name=<span class="string">"pattern"</span> value=<span class="string">"'%' + _parameter.getTitle() + '%'"</span> /&gt;</span><br><span class="line">	SELECT * FROM BLOG</span><br><span class="line">	WHERE title LIKE #{pattern}</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>回到原先的话题映射涉及复杂map,list,set等。<br>一对多collection 例子：一个班级相关的学生。StudentEntity是学生实体。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClazzEntity</span> </span>{</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> clazzID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String clazzName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;StudentEntity&gt; studentList;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>例子：</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">&lt;resultMap id=<span class="string">"ClazzResultMap"</span> type=<span class="string">"com.cn.hnust.pojo.ClazzEntity"</span> &gt;</span><br><span class="line">	  &lt;id column=<span class="string">"classID"</span> property=<span class="string">"clazzID"</span> jdbcType=<span class="string">"INTEGER"</span> /&gt;</span><br><span class="line"> 	&lt;result column=<span class="string">"className"</span> property=<span class="string">"clazzName"</span> jdbcType=<span class="string">"VARCHAR"</span> /&gt;</span><br><span class="line">	&lt;collection property=<span class="string">"studentList"</span> column=<span class="string">"classID"</span> javaType=<span class="string">"ArrayList"</span> </span><br><span class="line">            ofType=<span class="string">"com.cn.hnust.pojo.StudentEntity"</span> select=<span class="string">"getStudentByClassID"</span>/&gt;</span><br><span class="line"> &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line"> &lt;resultMap id=<span class="string">"StudentResultMap"</span> type=<span class="string">"com.cn.hnust.pojo.StudentEntity"</span>&gt;  </span><br><span class="line"> 	&lt;id property=<span class="string">"stuID"</span> column=<span class="string">"stuID"</span> /&gt;  </span><br><span class="line">	&lt;result property=<span class="string">"stuName"</span> column=<span class="string">"stuName"</span> /&gt;  </span><br><span class="line">	&lt;result property=<span class="string">"stuAge"</span> column=<span class="string">"stuAge"</span> /&gt;  </span><br><span class="line">	&lt;result property=<span class="string">"stuAddress"</span> column=<span class="string">"stuAddress"</span> /&gt;</span><br><span class="line">  &lt;/resultMap&gt;  </span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">"getClassByID"</span> resultMap=<span class="string">"ClazzResultMap"</span> parameterType=<span class="string">"java.lang.Integer"</span> &gt;</span><br><span class="line">	select classID,className</span><br><span class="line">	from class_t</span><br><span class="line">	where classID = #{clazzID}</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">"getStudentByClassID"</span> resultMap=<span class="string">"StudentResultMap"</span> parameterType=<span class="string">"java.lang.Integer"</span> &gt;</span><br><span class="line">	select stuID,stuName,stuAge,stuAddress,classID</span><br><span class="line"> from student_t</span><br><span class="line">	where classID = #{clazzID}</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>一对多，一对一（association ）：</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">&lt;resultMap type=<span class="string">"Bill"</span> id=<span class="string">"ResultBill"</span>&gt;  </span><br><span class="line">       &lt;id property=<span class="string">"id"</span> column=<span class="string">"id"</span>/&gt;  </span><br><span class="line">       &lt;result property=<span class="string">"dh"</span> column=<span class="string">"dh"</span>  /&gt;          </span><br><span class="line">       &lt;result property=<span class="string">"rq"</span> column=<span class="string">"rq"</span>/&gt;  </span><br><span class="line">       &lt;association property=<span class="string">"author"</span>  javaType=<span class="string">"Author"</span>  &gt;  </span><br><span class="line">          &lt;id  property=<span class="string">"id"</span>  column=<span class="string">"idAutor"</span> /&gt;  </span><br><span class="line">          &lt;result property=<span class="string">"name"</span> column=<span class="string">"authorName"</span> /&gt;  </span><br><span class="line">          &lt;result property=<span class="string">"email"</span> column=<span class="string">"authorEmail"</span>/&gt;  </span><br><span class="line">       &lt;/association&gt;          </span><br><span class="line">       &lt;collection property=<span class="string">"det1"</span>  javaType=<span class="string">"ArrayList"</span> ofType=<span class="string">"BillDet1"</span> &gt;  </span><br><span class="line">          &lt;id property=<span class="string">"id"</span> column=<span class="string">"idDet1"</span>/&gt;  </span><br><span class="line">          &lt;result property=<span class="string">"dh"</span> column=<span class="string">"dhDet1"</span>/&gt;  </span><br><span class="line">          &lt;result property=<span class="string">"wlbm"</span> column=<span class="string">"wlbm"</span>/&gt;  </span><br><span class="line">          &lt;result property=<span class="string">"wlmc"</span> column=<span class="string">"wlmc"</span>/&gt;  </span><br><span class="line">          &lt;result property=<span class="string">"unit"</span> column=<span class="string">"unit"</span>/&gt;  </span><br><span class="line">          &lt;result property=<span class="string">"qty"</span> column=<span class="string">"qty"</span>/&gt;  </span><br><span class="line">       &lt;/collection&gt;  </span><br><span class="line">&lt;/resultMap&gt;  </span><br><span class="line">&lt;resultMap type=<span class="string">"com.sailod.shiro.dto.HtAuthorityMenuDTO"</span> id=<span class="string">"OneMenuAuthority"</span>&gt;  </span><br><span class="line">    &lt;id property=<span class="string">"htAuthorityId"</span> column=<span class="string">"htAuthorityId"</span> javaType=<span class="string">"java.lang.Long"</span> /&gt;  </span><br><span class="line">    &lt;result property=<span class="string">"name"</span> column=<span class="string">"name"</span> javaType=<span class="string">"java.lang.String"</span> /&gt;  </span><br><span class="line">    &lt;result property=<span class="string">"currentUserId"</span> column=<span class="string">"currentUserId"</span> javaType=<span class="string">"java.lang.Long"</span> /&gt;  </span><br><span class="line">    &lt;collection property=<span class="string">"htAuthorityDTO"</span>  ofType=<span class="string">"com.sailod.shiro.dto.HtAuthorityDTO"</span>  </span><br><span class="line">     select=<span class="string">"selectAuthority"</span> column=<span class="string">"{htAuthorityId2 = htAuthorityId ,currentUserId2 = currentUserId}"</span>   &gt;  </span><br><span class="line">     &lt;/collection&gt;  </span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>后端</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
        <tag>mappers</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>windows下如何安装redis</title>
    <url>/How_to_install_redis_under_Windows/</url>
    <content><![CDATA[<h1 id="windows和Linux下Redis的安装和使用-最新"><a href="#windows和Linux下Redis的安装和使用-最新" class="headerlink" title="windows和Linux下Redis的安装和使用(最新)"></a>windows和Linux下Redis的安装和使用(最新)</h1><blockquote>
<p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</p>
<p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>
<p>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p>
</blockquote>
<a id="more"></a>

<h2 id="Windows下安装"><a href="#Windows下安装" class="headerlink" title="Windows下安装"></a>Windows下安装</h2><p>1、到<a href="https://github.com/microsoftarchive/redis/releases" target="_blank" rel="noopener">https://github.com/microsoftarchive/redis/releases</a>,前往下载页面</p>
<p><a href="https://imgchr.com/i/DvHmdS" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/07/DvHmdS.png" alt="DvHmdS.png"></a></p>
<p>2、在下载网页中，找到最后发行的版本（此处是3.2.100）。找到Redis-x64-3.2.100.msi和Redis-x64-3.2.100.zip，点击下载。这里说明一下，第一个是msi微软格式的安装包，第二个是压缩包。</p>
<p><a href="https://imgchr.com/i/DvHeZ8" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/07/DvHeZ8.png" alt="DvHeZ8.png"></a></p>
<p>3、双击刚下载好的msi格式的安装包（Redis-x64-3.2.100.msi）开始安装</p>
<p><a href="https://imgchr.com/i/DvHEsP" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/07/DvHEsP.png" alt="DvHEsP.png"></a></p>
<p>4、选择“同意协议”，点击下一步继续。</p>
<p>5、勾选“添加Redis目录到环境变量PATH中”，这样方便系统自动识别Redis执行文件在哪里。</p>
<p>6、端口号可保持默认的6379，并选择防火墙例外，从而保证外部可以正常访问Redis服务</p>
<p>7、设定最大值为100M。作为实验和学习，100M足够了。</p>
<p>8、击安装后，正式的安装过程开始。稍等一会即可完成。</p>
<p>9、安装完毕后，需要先做一些设定工作，以便服务启动后能正常运行。使用文本编辑器，这里使用Notepad++，打开Redis服务配置文件。<strong>注意：不要找错了，通常为redis.windows-service.conf，而不是redis.windows.conf。后者是以非系统服务方式启动程序使用的配置文件。</strong></p>
<p>10、找到含有requirepass字样的地方，追加一行，输入requirepass 密码。这是访问Redis时所需的密码，一般测试情况下可以不用设定密码。不过，即使是作为本地访问，也建议设定一个密码。</p>
<p><a href="https://imgchr.com/i/DvHVqf" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/07/DvHVqf.png" alt="DvHVqf.png"></a></p>
<p>11、点击“开始”&gt;右击“计算机”&gt;选择“管理”。在左侧栏中依次找到并点击“计算机管理（本地）”&gt;服务和应用程序&gt;服务。再在右侧找到Redis名称的服务，查看启动情况。如未启动，则手动启动之。正常情况下，服务应该正常启动并运行了,如果启动了，就点击重新启动。</p>
<p>12、最后来测试一下Redis是否正常提供服务。进入Redis的目录，cd D:\Redis。输入redis-cli并回车。（redis-cli是客户端程序）如图正常提示进入，并显示正确端口号，则表示服务已经启动。</p>
<p><a href="https://imgchr.com/i/DvHAMt" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/07/DvHAMt.png" alt="DvHAMt.png"></a></p>
<p>13、使用服务前需要先通过密码验证。输入“auth 密码“回车（密码是之前设定的密码）。返回提示OK表示验证通过。</p>
<p>14、实际测试一下读写。输入set mykey1 “I love you all!”并回车，用来保存一个键值。再输入get mykey1，获取刚才保存的键值。</p>
<p><a href="https://imgchr.com/i/DvHnIg" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/07/DvHnIg.png" alt="DvHnIg.png"></a></p>
<p>15、注意事项</p>
<ul>
<li>1.Windows使用的这个Redis是64位版本的，32位操作系统的同学就不要折腾了。</li>
<li>2.<strong>作为服务运行的Redis配置文件，通常为redis.windows-service.conf，而不是redis.windows.conf。小心不要选错了。</strong></li>
</ul>
<p>参考：<a href="https://www.cnblogs.com/liuqingzheng/p/9831331.html" target="_blank" rel="noopener">liuqingzheng</a></p>
<h2 id="Linux源码安装"><a href="#Linux源码安装" class="headerlink" title="Linux源码安装"></a>Linux源码安装</h2><p>下载地址：<a href="http://redis.io/download" target="_blank" rel="noopener">http://redis.io/download</a>,下载稳定最新版本</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> wget http://download.redis.io/releases/redis-6.0.8.tar.gz</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tar xzf redis-6.0.8.tar.gz</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> redis-6.0.8</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make</span></span><br></pre></td></tr></tbody></table></figure>

<p>执行完 <strong>make</strong> 命令后，redis-6.0.8 的 <strong>src</strong> 目录下会出现编译后的 redis 服务程序 redis-server，还有用于测试的客户端程序 redis-cli：</p>
<p>下面启动 redis 服务：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> src</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ./redis-server</span></span><br></pre></td></tr></tbody></table></figure>

<p>注意这种方式启动 redis 使用的是默认配置。也可以通过启动参数告诉 redis 使用指定配置文件使用下面命令启动。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> src</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ./redis-server ../redis.conf</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>redis.conf</strong> 是一个默认的配置文件。我们可以根据需要使用自己的配置文件。</p>
<p>启动 redis 服务进程后，就可以使用测试客户端程序 redis-cli 和 redis 服务交互了。 比如：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> src</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ./redis-cli</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> <span class="built_in">set</span> foo bar</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> get foo</span></span><br><span class="line">"bar"</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="Ubuntu-apt-命令安装"><a href="#Ubuntu-apt-命令安装" class="headerlink" title="Ubuntu apt 命令安装"></a>Ubuntu apt 命令安装</h2><p>在 Ubuntu 系统安装 Redis 可以使用以下命令:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sudo apt update</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo apt install redis-server</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="启动-Redis"><a href="#启动-Redis" class="headerlink" title="启动 Redis"></a>启动 Redis</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> redis-server</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="查看-redis-是否启动？"><a href="#查看-redis-是否启动？" class="headerlink" title="查看 redis 是否启动？"></a>查看 redis 是否启动？</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> redis-cli</span></span><br></pre></td></tr></tbody></table></figure>

<p>以上命令将打开以下终端：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>127.0.0.1 是本机 IP ，6379 是 redis 服务端口。现在我们输入 PING 命令。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></tbody></table></figure>

<p>以上说明我们已经成功安装了redis。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>后端</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLyog连接数据库报错plugin caching_sha2_password could not be loaded</title>
    <url>/SQL_log_connection_database_report/</url>
    <content><![CDATA[<h1 id="SQLyog连接数据库报错plugin-caching-sha2-password-could-not-be-loaded"><a href="#SQLyog连接数据库报错plugin-caching-sha2-password-could-not-be-loaded" class="headerlink" title="SQLyog连接数据库报错plugin caching_sha2_password could not be loaded"></a>SQLyog连接数据库报错plugin caching_sha2_password could not be loaded</h1><a id="more"></a>

<p><a href="https://imgchr.com/i/Dth1yR" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/24/Dth1yR.png" alt="Dth1yR.png"></a></p>
<h2 id="出错原因"><a href="#出错原因" class="headerlink" title="出错原因"></a>出错原因</h2><blockquote>
<p>MySQL新版默认使用caching_sha2_password作为身份验证插件，而旧版是使用mysql_native_password。<br>当连接MySQL时报错“plugin caching_sha2_password could not be loaded”时，可换回旧版插件。</p>
</blockquote>
<h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><ul>
<li>cmd:进入数据库，<code>mysql -uroot -p</code></li>
<li>依次执行<ul>
<li><code>mysql&gt; alter user 'root'@'localhost' identified by 'yours password' password expire never; # 重置root密码，修改密码加密规则</code></li>
<li><code>mysql&gt; alter user 'root'@'localhost' identified with mysql_native_password by 'yours password' # 更新用户密码;</code></li>
<li><code>mysql&gt; flush privileges;  # 刷新权限</code></li>
</ul>
</li>
<li>然后再次连接SQLyog即可成功访问</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>后端</category>
        <category>Debug</category>
      </categories>
      <tags>
        <tag>MySql</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>git教程</title>
    <url>/Git_tutorial/</url>
    <content><![CDATA[<blockquote>
<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p>
<p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
</blockquote>
<a id="more"></a>

<h1 id="Git教程"><a href="#Git教程" class="headerlink" title="Git教程"></a>Git教程</h1><p>注明：学习自<a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰老师</a></p>
<h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><ol>
<li><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><ul>
<li><h5 id="在Linux上安装Git"><a href="#在Linux上安装Git" class="headerlink" title="在Linux上安装Git"></a>在Linux上安装Git</h5><p>首先，你可以试着输入<code>git</code>，看看系统有没有安装Git：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git</span><br><span class="line">The program 'git' is currently not installed. You can install it by typing:</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></tbody></table></figure>

<p>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p>
<p>如果你碰巧用Debian或Ubuntu Linux，通过一条<code>sudo apt-get install git</code>就可以直接完成Git的安装，非常简单。</p>
<p>老一点的Debian或Ubuntu Linux，要把命令改为<code>sudo apt-get install git-core</code>，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫<code>git-core</code>了。由于Git名气实在太大，后来就把GNU Interactive Tools改成<code>gnuit</code>，<code>git-core</code>正式改为<code>git</code>。</p>
<p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：<code>./config</code>，<code>make</code>，<code>sudo make install</code>这几个命令安装就好了。</p>
</li>
<li><h5 id="在Mac-OS-X上安装Git"><a href="#在Mac-OS-X上安装Git" class="headerlink" title="在Mac OS X上安装Git"></a>在Mac OS X上安装Git</h5><p>如果你正在使用Mac做开发，有两种安装Git的方法。</p>
<p>一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/。" target="_blank" rel="noopener">http://brew.sh/。</a></p>
<p>第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</p>
</li>
<li><h5 id="在Windows上安装Git"><a href="#在Windows上安装Git" class="headerlink" title="在Windows上安装Git"></a>在Windows上安装Git</h5><p>在Windows上使用Git，可以从Git官网直接<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载安装程序</a>，然后按默认选项安装即可。</p>
<p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p>
<p>安装完成后，还需要最后一步设置，在命令行输入：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git config --global user.name "Your Name"</span><br><span class="line">$ git config --global user.email "email@example.com"</span><br></pre></td></tr></tbody></table></figure>

<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p>
<p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
</li>
</ul>
</li>
<li><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd</span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></tbody></table></figure>

<p><code>pwd</code>命令用于显示当前目录。在我的Mac上，这个仓库位于<code>/Users/michael/learngit</code>。</p>
<p>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></tbody></table></figure>

<p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p>
<p>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p>
<p>也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。</p>
<h5 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h5><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p>
<p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p>
<p>使用Windows的童鞋要特别注意：</p>
<p>千万不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载<a href="http://notepad-plus-plus.org/" target="_blank" rel="noopener">Notepad++</a>代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可</p>
<p>言归正传，现在我们编写一个<code>readme.txt</code>文件，内容如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></tbody></table></figure>

<p>一定要放到<code>learngit</code>目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p>
<p>和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p>
<p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></tbody></table></figure>

<p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p>
<p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git commit -m "wrote a readme file"</span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></tbody></table></figure>

<p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<p>嫌麻烦不想输入<code>-m "xxx"</code>行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p>
<p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p>
<p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m "add 3 files."</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>现在总结一下今天学的两点内容：</p>
<p>初始化一个Git仓库，使用<code>git init</code>命令。</p>
<p>添加文件到Git仓库，分两步：</p>
<ol>
<li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li>
<li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li>
</ol>
</li>
</ol>
<h2 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h2><ol>
<li><p>版本回退</p>
<ul>
<li><code>HEAD</code>指向的版本就是当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。因此，Git允许我们在版本的历史之间穿梭，还可以写成使用命令<code>git reset --hard commit_id</code>。</li>
<li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>
</li>
<li><p>工作区和暂存区</p>
<ul>
<li><p>工作区：电脑里能看到的目录，前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p>
<p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p>
<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。（所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。）</p>
</li>
<li><p>Git管理的文件分为：工作区，版本库，版本库又分为暂存区stage和暂存区分支master(仓库)</p>
<p>工作区&gt;&gt;&gt;&gt;暂存区&gt;&gt;&gt;&gt;仓库</p>
<p><code>git add</code>把文件从工作区&gt;&gt;&gt;&gt;暂存区，``git commit`把文件从暂存区&gt;&gt;&gt;&gt;仓库，</p>
<p><code>git diff</code>查看工作区和暂存区差异，</p>
<p><code>git diff</code> –cached查看暂存区和仓库差异，</p>
<p><code>git diff HEAD</code>查看工作区和仓库的差异，</p>
<p><code>git add</code>的反向命令<code>git checkout</code>，撤销工作区修改，即把暂存区最新版本转移到工作区，</p>
<p><code>git commit</code>的反向命令``git reset HEAD`，就是把仓库最新版本转移到暂存区。</p>
</li>
</ul>
</li>
<li><p>管理修改</p>
<ul>
<li>理解了Git是如何跟踪修改的，每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中。</li>
</ul>
</li>
<li><p>撤销修改</p>
<ul>
<li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li>
<li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</li>
<li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192" target="_blank" rel="noopener">版本回退</a>一节，不过前提是没有推送到远程库。</li>
</ul>
</li>
<li><p>删除文件</p>
<ul>
<li><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：<code>$ rm test.txt</code></p>
</li>
<li><p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：</p>
<p><img src="C:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200602163313271.png" alt="image-20200602163313271"></p>
</li>
<li><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：<code>$ git rm test.txt</code> <code>rm 'test.txt'</code> 现在，文件就从版本库中被删除了</p>
</li>
<li><p>小提示：先手动删除文件，然后使用<code>git rm &lt;file&gt;</code>和<code>git add&lt;file&gt;</code>效果是一样的。</p>
</li>
<li><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：<code>$ git checkout -- test.txt</code>。<code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。但是，<u><strong>从来没有被添加到版本库就被删除的文件，是无法恢复的！</strong></u></p>
</li>
<li><p>小结：命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p>
</li>
</ul>
</li>
</ol>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><ol>
<li><p>添加远程库</p>
<ul>
<li><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；以<code>github</code>为例子：<code>git remote add origin git@github.com:liudufu/First_Git_Text.git</code></p>
</li>
<li><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p>
</li>
<li><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而<code>SVN</code>在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了</p>
</li>
</ul>
</li>
<li><p>从远程库克隆</p>
<ul>
<li><p>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。例如：<code>git clone git@github.com:michaelliao/gitskills.git</code></p>
</li>
<li><p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。你也许还注意到，<code>GitHub</code>给出的地址不止一个，还可以用<code>https://github.com/michaelliao/gitskills.git</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。</p>
<p>使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放<code>http</code>端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。</p>
</li>
<li><p>Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快。</p>
</li>
</ul>
</li>
</ol>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><ol>
<li><p>简介：分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
</li>
<li><p>创建与合并分支</p>
<ul>
<li><p><code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p>
<p><img src="C:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200603203525643.png" alt="image-20200603203525643"></p>
</li>
<li><p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p>
<p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p>
<p><img src="C:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200603203559448.png" alt="image-20200603203559448"></p>
</li>
<li><p>首先，我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支</p>
<figure class="highlight plain"><figcaption><span>checkout -b dev```</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">`git checkout`命令加上`-b`参数表示创建并切换，相当于以下两条命令：</span><br></pre></td></tr></tbody></table></figure>
<p>$ git branch dev<br>$ git checkout dev<br>Switched to branch ‘dev’</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 把`dev`分支的工作成果合并到`master`分支上：</span><br><span class="line"></span><br><span class="line">  ```git</span><br><span class="line">  $ git merge dev</span><br><span class="line">  Updating d46f35e..b17d20e</span><br><span class="line">  Fast-forward</span><br><span class="line">   readme.txt | 1 +</span><br><span class="line">   1 file changed, 1 insertion(+)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p>
<p>当然，也不是每次合并都能<code>Fast-forward</code></p>
</li>
<li><p>我们注意到切换分支使用<code>git checkout &lt;branch&gt;</code>，而前面讲过的撤销修改则是<code>git checkout -- &lt;file&gt;</code>，同一个命令，有两种作用，确实有点令人迷惑。</p>
<p>实际上，切换分支这个动作，用<code>switch</code>更科学。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支：</p>
<p>创建并切换到新的<code>dev</code>分支，可以使用：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git switch -c dev</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>直接切换到已有的<code>master</code>分支，可以使用：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git switch master</span><br></pre></td></tr></tbody></table></figure>

<p>​    使用新的<code>git switch</code>命令，比<code>git checkout</code>要更容易理解。</p>
</li>
<li><p>小结：查看分支：<code>git branch</code></p>
<p>创建分支：<code>git branch &lt;name&gt;</code></p>
<p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p>
<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p>
<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
</li>
</ul>
</li>
<li><p>解决冲突</p>
<ul>
<li>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</li>
<li>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</li>
<li>用<code>git log --graph</code>命令可以看到分支合并图。</li>
</ul>
</li>
<li><p>分支管理策略</p>
<ul>
<li><p>Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p>
</li>
<li><p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git merge --no-ff -m "merge with no-ff" dev</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。合并后，我们用<code>git log</code>看看分支历史：</p>
<p><img src="C:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200603213003612.png" alt="image-20200603213003612"></p>
</li>
<li><p>在Git中，干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p>
</li>
</ul>
</li>
<li><p>bug分支</p>
<ul>
<li><p>哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch 'master'</span><br><span class="line">Your branch is ahead of 'origin/master' by 6 commits.</span><br><span class="line">  (use "git push" to publish your local commits)</span><br><span class="line"></span><br><span class="line">$ git checkout -b issue-101</span><br><span class="line">Switched to a new branch 'isse-101'</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>bug 修复后把文件add以及commit，切换回master分支，删除<code>issue-101</code>分支：<code>$ git switch master</code> <code>git merge --no-ff -m "merged bug fix 101" issue-101</code></p>
</li>
<li><p>查看刚才的工作现场<code>git stash list</code></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@{0}: WIP on dev: f52c633 add merge</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>
<p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p>
<p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：再用<code>git stash list</code>查看，就看不到任何stash内容了：</p>
<p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git stash apply stash@{0}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>同样的bug，要在dev上修复，我们只需要把<code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到dev分支。注意：我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来。</p>
<p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git cherry-pick 4c805e2</span><br><span class="line">[master 1d4b803] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></tbody></table></figure>

<p>Git自动给dev分支做了一次提交，注意这次提交的commit是<code>1d4b803</code>，它并不同于master的<code>4c805e2</code>，因为这两个commit只是改动相同，但确实是两个不同的commit。用<code>git cherry-pick</code>，我们就不需要在dev分支上手动再把修bug的过程重复一遍。</p>
<p>有些聪明的童鞋会想了，既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要<code>git stash</code>命令保存现场，才能从dev分支切换到master分支。</p>
</li>
<li><p>小结：修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；</p>
<p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动</p>
</li>
</ul>
</li>
<li><p>Feature分支</p>
<ul>
<li><p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>
</li>
</ul>
</li>
<li><p>多人协作</p>
<ul>
<li><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。要查看远程库的信息，用<code>git remote</code>用<code>git remote -v</code>显示更详细的信息：</p>
</li>
<li><p><code>master</code>分支是主分支，因此要时刻与远程同步；<code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>
</li>
<li><p>抓取分支，现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：<code>$ git clone git@github.com:michaelliao/learngit.git</code></p>
</li>
<li><p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：<code>$ git push origin dev</code>,这个时候会推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：如果<code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line">Branch 'dev' set up to track remote branch 'dev' from 'origin'.</span><br></pre></td></tr></tbody></table></figure>

<p>在进行pull,这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的<a href="http://www.liaoxuefeng.com/wiki/896043488029600/900004111093344" target="_blank" rel="noopener">解决冲突</a>完全一样。解决后，提交，再push：</p>
</li>
<li><p>因此，多人协作的工作模式通常是这样：</p>
<ol>
<li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li>
</ol>
<p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>
</li>
<li><p>小结：查看远程库信息，使用<code>git remote -v</code>；</p>
<ul>
<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>
<li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li>
<li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li>
<li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li>
<li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li>
</ul>
</li>
</ul>
</li>
<li><p>Rebase</p>
<ul>
<li><p>多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。</p>
<p>每次合并再push后，分支变成了这样</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* d1be385 (HEAD -&gt; master, origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch 'dev'</span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">| |/  </span><br><span class="line">* |   12a631b merged bug fix 101</span><br><span class="line">|\ \  </span><br><span class="line">| * | 4c805e2 fix bug 101</span><br><span class="line">|/ /  </span><br><span class="line">* |   e1e9c68 merge with no-ff</span><br><span class="line">|\ \  </span><br><span class="line">| |/  </span><br><span class="line">| * f52c633 add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>这个时候，rebase就派上了用场。我们输入命令<code>git rebase</code>试试</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git rebase</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: add comment</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M	hello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Applying: add author</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M	hello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>输出了一大堆操作，到底是啥效果？再用<code>git log</code>看看：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 (origin/master) set exit=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了<code>f005ed4 (origin/master) set exit=1</code>之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于<code>d1be385 init hello</code>，而是基于<code>f005ed4 (origin/master) set exit=1</code>，但最后的提交<code>7e61ed4</code>内容是一致的。</p>
<p>这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p>
<p>最后，通过push操作把本地分支推送到远程：</p>
</li>
<li><p>再用<code>git log</code>看看效果</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master, origin/master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 set exit=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<p>远程分支的提交历史也是一条直线。</p>
</li>
<li><p>小结：</p>
<ul>
<li>rebase操作可以把本地未push的分叉提交历史整理成直线；</li>
<li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><ol>
<li><p>简介：发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。例如：</p>
<p>请把上周一的那个版本打包发布，版本号是v1.2”</p>
<p>“好的，按照tag v1.2查找commit就行！”</p>
<p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p>
</li>
<li><p>创建标签</p>
<ul>
<li>打标签很简单,切换到打标签的分支</li>
</ul>
</li>
</ol>
<pre><code><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">* dev</span><br><span class="line">master</span><br><span class="line">$ git checkout master</span><br></pre></td></tr></tbody></table></figure>

敲`git tag &lt;name&gt;`打一个新的标签

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></tbody></table></figure>

使用`git tag` 查看所有标签

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></tbody></table></figure>

比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？

方法是找到历史提交的commit id，然后打上就可以了

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline --abbrev-commit</span><br><span class="line">12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101</span><br><span class="line">4c805e2 fix bug 101</span><br><span class="line">e1e9c68 merge with no-ff</span><br><span class="line">f52c633 add merge</span><br><span class="line">cf810e4 conflict fixed</span><br><span class="line">5dc6824 &amp; simple</span><br><span class="line">14096d0 AND simple</span><br><span class="line">b17d20e branch test</span><br><span class="line">d46f35e remove test.txt</span><br><span class="line">b84166e add test.txt</span><br><span class="line">519219b git tracks changes</span><br><span class="line">e43a48b understand how stage works</span><br><span class="line">1094adb append GPL</span><br><span class="line">e475afc add distributed</span><br><span class="line">eaadf4e wrote a readme file</span><br></pre></td></tr></tbody></table></figure>

比方说要对`add merge`这次提交打标签，它对应的commit id是`f52c633`，敲入命令：`$ git tag v0.9 f52c633`</code></pre><ul>
<li><p>标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p>
</li>
<li><p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git tag -a v0.1 -m "version 0.1 released" 1094adb</span><br></pre></td></tr></tbody></table></figure>

<p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git show v0.1</span><br><span class="line">tag v0.1</span><br><span class="line">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 22:48:43 2018 +0800</span><br><span class="line"></span><br><span class="line">version 0.1 released</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</strong></p>
</li>
<li><p>小结：</p>
<ul>
<li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li>
<li>命令<code>git tag -a &lt;tagname&gt; -m "blablabla..."</code>可以指定标签信息；</li>
<li>命令<code>git tag</code>可以查看所有标签。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>操作标签</p>
<ul>
<li><p>删除一个标签：<code>git tag -d v0.1</code></p>
</li>
<li><p>因为创建的标签都保存在本地，不会自动推送到远程。所以打错的标签可以在本地安全的删除，如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></tbody></table></figure>

<p>或者，一次性推送全部尚未推送到远程的本地标签：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>如果需要删除已经推送到远程的标签，需要先删除本地标签</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag 'v0.9' (was f52c633)</span><br></pre></td></tr></tbody></table></figure>

<p>然后，从远程删除，命令也是push，但是格式却不同：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></tbody></table></figure>

<p>登录GitHub查看是否删除了标签</p>
</li>
<li><p>小结：</p>
<ul>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h2><ol>
<li><p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：" target="_blank" rel="noopener">https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</a></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git clone git@github.com:michaelliao/bootstrap.git</span><br></pre></td></tr></tbody></table></figure>

<p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<code>git@github.com:twbs/bootstrap.git</code>克隆，因为没有权限，你将不能推送修改。</p>
<p>Bootstrap的官方仓库<code>twbs/bootstrap</code>、你在GitHub上克隆的仓库<code>my/bootstrap</code>，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：</p>
<p><img src="C:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200605203808429.png" alt="image-20200605203808429"></p>
<p>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p>
<p>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p>
<p>如果你没能力修改bootstrap，但又想要试一把pull request，那就Fork一下我的仓库：<a href="https://github.com/michaelliao/learngit，创建一个`your-github-id.txt`的文本文件，写点自己学习Git的心得，然后推送一个pull" target="_blank" rel="noopener">https://github.com/michaelliao/learngit，创建一个`your-github-id.txt`的文本文件，写点自己学习Git的心得，然后推送一个pull</a> request给我，我会视心情而定是否接受。<a href="https://github.com" target="_blank" rel="noopener">liudufu</a>     <a href="https://github.com" target="_blank" rel="noopener">https://github.com</a></p>
</li>
<li><p><strong>小结</strong></p>
<ul>
<li>在GitHub上，可以任意Fork开源仓库；</li>
<li>自己拥有Fork后的仓库的读写权限；</li>
<li>可以推送pull request给官方仓库来贡献代码。</li>
</ul>
</li>
</ol>
<h2 id="使用Gitee"><a href="#使用Gitee" class="headerlink" title="使用Gitee"></a>使用Gitee</h2><ol>
<li><p>和GitHub相比，Gitee也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。</p>
<p>Gitee的免费版本也提供私有库功能，只是有5人的成员上限。</p>
<p>使用Gitee和使用GitHub类似，我们在Gitee上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -&gt; 菜单“修改资料”，然后选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的<code>.ssh/id_rsa.pub</code>文件的内容粘贴进去：</p>
</li>
<li><p>如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到Gitee的远程库上呢？</p>
<p>首先，我们在Gitee上创建一个新的项目项目名称最好与本地库保持一致：</p>
<p>然后，我们在本地库上使用命令<code>git remote add</code>把它和Gitee的远程库关联：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br><span class="line">(git remote add origin git@gitee.com:https://gitee.com/dufu-03-13/git_repo_Text)</span><br></pre></td></tr></tbody></table></figure>

<p>之后，就可以正常地用<code>git push</code>和<code>git pull</code>推送了！</p>
<p>如果在使用命令<code>git remote add</code>时报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br><span class="line">fatal: remote origin already exists.</span><br></pre></td></tr></tbody></table></figure>

<p>这说明本地库已经关联了一个名叫<code>origin</code>的远程库，此时，可以先用<code>git remote -v</code>查看远程库信息：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin	git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin	git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，本地库已经关联了<code>origin</code>的远程库，并且，该远程库指向GitHub。</p>
<p>我们可以删除已有的GitHub远程库：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></tbody></table></figure>

<p>再关联Gitee的远程库（注意路径中需要填写正确的用户名）：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></tbody></table></figure>

<p>此时，我们再查看远程库信息：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin	git@gitee.com:liaoxuefeng/learngit.git (fetch)</span><br><span class="line">origin	git@gitee.com:liaoxuefeng/learngit.git (push)</span><br></pre></td></tr></tbody></table></figure>

<p>现在可以看到，origin已经被关联到Gitee的远程库了。通过<code>git push</code>命令就可以把本地库推送到Gitee上。</p>
<p>git本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。</p>
<p>使用多个远程库时，我们要注意，git给远程库起的默认名称是<code>origin</code>，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。</p>
<p>仍然以<code>learngit</code>本地库为例，我们先删除已关联的名为<code>origin</code>的远程库：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></tbody></table></figure>

<p>然后，先关联GitHub的远程库：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git remote add github git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></tbody></table></figure>

<p>注意，远程库的名称叫<code>github</code>，不叫<code>origin</code>了。</p>
<p>接着，再关联Gitee的远程库：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git remote add gitee git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></tbody></table></figure>

<p>同样注意，远程库的名称叫<code>gitee</code>，不叫<code>origin</code>。</p>
<p>现在，我们用<code>git remote -v</code>查看远程库信息，可以看到两个远程库：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">gitee	git@gitee.com:liaoxuefeng/learngit.git (fetch)</span><br><span class="line">gitee	git@gitee.com:liaoxuefeng/learngit.git (push)</span><br><span class="line">github	git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">github	git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></tbody></table></figure>

<p>如果要推送到GitHub，使用命令：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git push github master</span><br></pre></td></tr></tbody></table></figure>

<p>如果要推送到Gitee，使用命令：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git push -u gitee master</span><br></pre></td></tr></tbody></table></figure>

<p>这样一来，我们的本地库就可以同时与多个远程库互相同步：</p>
</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql基础学习</title>
    <url>/MySQL_basic_learning/</url>
    <content><![CDATA[<blockquote>
<p>MySQL是一个<strong><a href="https://baike.baidu.com/item/关系型数据库管理系统/696511" target="_blank" rel="noopener">关系型数据库管理系统</a>**</strong>，**由瑞典MySQL AB 公司开发，属于 <a href="https://baike.baidu.com/item/Oracle" target="_blank" rel="noopener">Oracle</a> 旗下产品。MySQL 是最流行的<a href="https://baike.baidu.com/item/关系型数据库管理系统/696511" target="_blank" rel="noopener">关系型数据库管理系统</a>之一，在 WEB 应用方面，MySQL是最好的 <a href="https://baike.baidu.com/item/RDBMS/1048260" target="_blank" rel="noopener">RDBMS</a> (Relational Database Management System，关系数据库管理系统) 应用软件之一。</p>
</blockquote>
<a id="more"></a>

<h1 id="MySql基础学习"><a href="#MySql基础学习" class="headerlink" title="MySql基础学习"></a>MySql基础学习</h1><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><h3 id="1-1-现有的数据存储方式有哪些？"><a href="#1-1-现有的数据存储方式有哪些？" class="headerlink" title="1.1 现有的数据存储方式有哪些？"></a>1.1 现有的数据存储方式有哪些？</h3><ul>
<li>Java程序存储数据（变量、对象、数组、集合），数据保存在内存中，属于瞬时状态存储。</li>
<li>文件（File）存储数据，保存在硬盘上，属于持久状态存储。</li>
</ul>
<h3 id="1-2-以上存储方式存在哪些缺点？"><a href="#1-2-以上存储方式存在哪些缺点？" class="headerlink" title="1.2 以上存储方式存在哪些缺点？"></a>1.2 以上存储方式存在哪些缺点？</h3><ul>
<li>没有数据类型的区分。</li>
<li>存储数据量极小。</li>
<li>没有安全访问限制。</li>
<li>没有备份、恢复机制。 </li>
</ul>
<h2 id="二、数据库"><a href="#二、数据库" class="headerlink" title="二、数据库"></a>二、数据库</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p> 数据库是按照数据接口来<strong>组织</strong>、<strong>存储和管理数据的仓库</strong>。是一个长期存储在计算机内的、有组织的、有共享的、统一管理的数据集合。</p>
<h3 id="2-2-数据库的分类"><a href="#2-2-数据库的分类" class="headerlink" title="2.2 数据库的分类"></a>2.2 数据库的分类</h3><ul>
<li>网状结构数据库：美国通用电气公司IDS（Integrated Data Store），以节点形式存储和访问。</li>
<li>层次结构数据库：IBM公司IMS（Information Management System）定向有序的树状结构实现存储和访问。</li>
<li>关系结构数据库：Oracle、DB2、MySQL、SQL Server，以表格（Table）存储，多表间建立关联关系，通过分类、合并、连接、选取等运算实现访问。</li>
<li>非关系型数据库：ElastecSearch、MongoDB、Redis，多数使用哈希表，表中以键值（key-value）的方式实现特定的键和一个指针指向的特定数据。</li>
</ul>
<h2 id="三、数据库管理系统"><a href="#三、数据库管理系统" class="headerlink" title="三、数据库管理系统"></a>三、数据库管理系统</h2><h3 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h3><blockquote>
<p> <strong>数据库管理系统</strong>（DataBase Management System，DBMS）：指一种操作和管理数据库的大型软件，用于建立、使用、和维护数据库，对数据库进行统一管理和控制，以保证数据库的安全性和完整性。用户通过数据库管理系统访问数据库中的数据。</p>
</blockquote>
<h3 id="3-2-常见数据库管理系统"><a href="#3-2-常见数据库管理系统" class="headerlink" title="3.2 常见数据库管理系统"></a>3.2 常见数据库管理系统</h3><ul>
<li>Oracle：被认为是业界目前比较成功的关系型数据库管理系统。Oracle数据库可以运行在UNIX、Windows等主流操作平台，完全支持所有的工业标准，并获得最高级别的ISO标准安全性认证。</li>
<li>DB2：IBM公司的产品，DB2数据库采用多进程多线索体系结构，其功能足以满足大中公司的需求，并可灵活地服务于中小型电子商务解决方案。</li>
<li>SQL Server： Microsoft公司退出的关系型数据库管理系统。具有使用方便可伸缩性好与相关软件集成程度高等优点。</li>
<li>SQLLite：应用在手机端的数据库。</li>
</ul>
<h2 id="四、MySQL"><a href="#四、MySQL" class="headerlink" title="四、MySQL"></a>四、MySQL</h2><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h3><blockquote>
<p> MySQL是一个<strong>关系型数据库管理系统</strong>，由瑞典MySQL AB公司开发，属于Oracle旗下产品。MySQL是最流行的关系型数据库管理系统之一，在WEB应用方面，MySQL是最好RDBM（Relational Database Management System，关系型数据库管理系统）应用软件之一。</p>
</blockquote>
<h3 id="4-2-访问与下载"><a href="#4-2-访问与下载" class="headerlink" title="4.2 访问与下载"></a>4.2 访问与下载</h3><p>官网地址： <a href="https://www.mysql.com/" target="_blank" rel="noopener">https://www.mysql.com/</a></p>
<p>下载地址： <a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a></p>
<p>mysql安装过程请查看<a href="https://blog.csdn.net/weixin_45333934/article/details/105065704" target="_blank" rel="noopener">mysql安装指南</a>。</p>
<h3 id="4-3-卸载"><a href="#4-3-卸载" class="headerlink" title="4.3 卸载"></a>4.3 卸载</h3><ul>
<li>控制台卸载。</li>
<li>找到mysql的安装目录进行删除。</li>
<li>programdata删除mysql。</li>
</ul>
<blockquote>
<ul>
<li>如果卸载后，有未删除的MySQL服务，可采用手动删除。</li>
<li>以管理员身份打开命令行，输入<code>sc delete MySQL57</code>，回车。</li>
</ul>
</blockquote>
<p>如果某个MySQL组件无法删除，可以尝试从注册表搜索信息删除相关文件夹。具体可百度。</p>
<h3 id="4-4-配置环境变量"><a href="#4-4-配置环境变量" class="headerlink" title="4.4 配置环境变量"></a>4.4 配置环境变量</h3><p><strong>Windows</strong></p>
<ul>
<li>创建MYSQL_HOME: <code>C:\Program Files\MySQL\MySQL Server5.7</code></li>
<li>追加PATH: <code>%MYSQL_HOME%\bin;</code></li>
</ul>
<h3 id="4-5-MySQL目录结构"><a href="#4-5-MySQL目录结构" class="headerlink" title="4.5 MySQL目录结构"></a>4.5 MySQL目录结构</h3><p>核心文件介绍：</p>
<table>
<thead>
<tr>
<th>文件夹名称</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>bin</td>
<td>命令文件</td>
</tr>
<tr>
<td>lib</td>
<td>库文件</td>
</tr>
<tr>
<td>include</td>
<td>头文件</td>
</tr>
<tr>
<td>Share</td>
<td>字符集、语言等信息</td>
</tr>
</tbody></table>
<h3 id="4-6-MySQL配置文件"><a href="#4-6-MySQL配置文件" class="headerlink" title="4.6 MySQL配置文件"></a>4.6 MySQL配置文件</h3><blockquote>
<p> 在MySQL安装目录中找到my.ini文件，并打开my.ini文件查看几个常用配置参数。</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>default-character-set</td>
<td>客户端默认字符集</td>
</tr>
<tr>
<td>character-set-server</td>
<td>服务器端默认字符集</td>
</tr>
<tr>
<td>port</td>
<td>客户端和服务器端的端口号</td>
</tr>
<tr>
<td>default-storage-engine</td>
<td>MySQL默认存储引擎INNODB</td>
</tr>
</tbody></table>
<p>通过安装程序安装的MySQL配置文件在C盘的隐藏文件ProgramData中，点进去找到对应的MYSQL目录就能看到my.ini文件了。</p>
<p>客户端默认字符集和服务器端默认字符集必须保持一致，它们在初始的配置文件中都是被注释掉的，那么默认的字符集会跟随你的系统默认字符集。</p>
<h2 id="五、SQL语言"><a href="#五、SQL语言" class="headerlink" title="五、SQL语言"></a>五、SQL语言</h2><h3 id="5-1概念"><a href="#5-1概念" class="headerlink" title="5.1概念"></a>5.1概念</h3><blockquote>
<p>SQL (Structured Query Language)结构化查询语言，用于存取数据、更新、查询和管理关系数据库系统的程序设计语言。</p>
</blockquote>
<ul>
<li>经验:通常执行对数据库的“增删改查”，简称c (create) R (Read) u (Update) D (Delete)。</li>
</ul>
<h3 id="5-2-MySql应用"><a href="#5-2-MySql应用" class="headerlink" title="5.2  MySql应用"></a>5.2  MySql应用</h3><blockquote>
<p>对于数据库的操作，需要在进入MySQL环境下进行指令输入，并在一句指令的末尾使用;结束</p>
</blockquote>
<h3 id="5-3基本命令"><a href="#5-3基本命令" class="headerlink" title="5.3基本命令"></a>5.3基本命令</h3><blockquote>
<p>查看MvSqL中所有数据库</p>
</blockquote>
<p><code>mysqls SHOW DATABASES;#显示当前MySQL中包含的所有数据库</code></p>
<table>
<thead>
<tr>
<th>数据库名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>information_schema</td>
<td>信息数据库</td>
</tr>
<tr>
<td>mysql</td>
<td>核心数据库</td>
</tr>
<tr>
<td>performance_schema</td>
<td>性能优化</td>
</tr>
<tr>
<td>sakila</td>
<td>样板数据库</td>
</tr>
<tr>
<td>sys</td>
<td>系统数据库</td>
</tr>
<tr>
<td>world</td>
<td>国家的编号等</td>
</tr>
</tbody></table>
<blockquote>
<p>创建自定义数据库</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">create database mydb1; # 创建数据库</span><br><span class="line">create database mydb2 character set gbk; # 编码格式为gbk</span><br><span class="line">create database if not exists mydb4;# 如果mudb4不存在就创建他</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>查看数据库创建信息</p>
</blockquote>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span> mydb2; <span class="comment"># 查看数据库创建信息</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>修改数据库</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">alter database mydb2 character set utf8;</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>删除数据库</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">drop database mydb1; # 删除数据库</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>查看当前使用的数据库</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">select database();</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>使用数据库</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">use mydb2;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="六、客户端工具"><a href="#六、客户端工具" class="headerlink" title="六、客户端工具"></a>六、客户端工具</h2><h3 id="6-1-Navicate"><a href="#6-1-Navicate" class="headerlink" title="6.1 Navicate"></a>6.1 Navicate</h3><blockquote>
<p>Navicat是一套快速、可靠并价格相宜的数据库管理工具，专为简化数据库的管理及降低系统管理成本而设。它的设计符合数据库管理员、开发人员及中小企业的需要。Navicat 是以直觉化的图形用户界面而建的，让你可以以安全并且简单的方式创建、组织、访问并共用信息。</p>
</blockquote>
<h3 id="6-2-SQLyog"><a href="#6-2-SQLyog" class="headerlink" title="6.2 SQLyog"></a>6.2 SQLyog</h3><blockquote>
<p>MySQL可能是世界上最流行的开源数据库引擎，但是使用基于文本的工具和配置文件可能很难进行管理。SQLyog提供了完整的图形界面，即使初学者也可以轻松使用MySQL的强大功能。其拥有广泛的预定义工具和查询、友好的视觉界面、类似Excel的查询结果编辑界面等优点。</p>
</blockquote>
<h2 id="七、数据查询【重点】"><a href="#七、数据查询【重点】" class="headerlink" title="七、数据查询【重点】"></a>七、数据查询【重点】</h2><h3 id="7-1-数据库表的基本结构"><a href="#7-1-数据库表的基本结构" class="headerlink" title="7.1 数据库表的基本结构"></a>7.1 数据库表的基本结构</h3><blockquote>
<p>关系数据库是以表格(Table)进行数据存储,表格由“行”和“列”组成</p>
</blockquote>
<ul>
<li>经验：执行查询语句返回的结果是一张虚拟表</li>
</ul>
<h3 id="7-2-基本查询"><a href="#7-2-基本查询" class="headerlink" title="7.2 基本查询"></a>7.2 基本查询</h3><blockquote>
<p>语法:SELECT列名FROM表名</p>
</blockquote>
<table>
<thead>
<tr>
<th>关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SELECT</td>
<td>指定要查询的列</td>
</tr>
<tr>
<td>FROM</td>
<td>指定要查询的表</td>
</tr>
</tbody></table>
<h4 id="7-2-1-查询部分列"><a href="#7-2-1-查询部分列" class="headerlink" title="7.2.1 查询部分列"></a>7.2.1 查询部分列</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 查询员工表中所有员工的编号】你名字、邮箱</span><br><span class="line">select employee_id fist_name, email</span><br><span class="line">from t_employee</span><br></pre></td></tr></tbody></table></figure>

<h4 id="7-2-2查询所有列"><a href="#7-2-2查询所有列" class="headerlink" title="7.2.2查询所有列"></a>7.2.2查询所有列</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 查询所有列</span><br><span class="line"># 1、使用*的方式</span><br><span class="line">SELECT * FROM t_employees;</span><br><span class="line"># 2、使用列名的方式</span><br><span class="line">SELECT 所有列的列名 FROM t_employees;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>注意：生产环境下，优先使用列名查询，*的方式需要转换成全列名。效率低，可读性差</li>
</ul>
<h4 id="7-2-3-对列中的数据进行运算"><a href="#7-2-3-对列中的数据进行运算" class="headerlink" title="7.2.3 对列中的数据进行运算"></a>7.2.3 对列中的数据进行运算</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 查询员工的编号、名字、年薪</span><br><span class="line">SELECT EMPLOYEE_ID,FIRST_NAME,SALARY * 12 FROM t_employees</span><br></pre></td></tr></tbody></table></figure>

<table>
<thead>
<tr>
<th>算数运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>两列做加法运算</td>
</tr>
<tr>
<td>-</td>
<td>两列做减法运算</td>
</tr>
<tr>
<td>*</td>
<td>两列做乘法运算</td>
</tr>
<tr>
<td>/</td>
<td>两列做除法运算</td>
</tr>
</tbody></table>
<ul>
<li>% 是占位符。而并非模运算符</li>
</ul>
<h4 id="7-2-4-列的别名"><a href="#7-2-4-列的别名" class="headerlink" title="7.2.4 列的别名"></a>7.2.4 列的别名</h4><blockquote>
<p>列 as 列名</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SELECT EMPLOYEE_ID '编号',FIRST_NAME AS '姓氏',SALARY * 12 AS '年薪' FROM t_employees;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="7-2-5-查询结果去重"><a href="#7-2-5-查询结果去重" class="headerlink" title="7.2.5 查询结果去重"></a>7.2.5 查询结果去重</h4><blockquote>
<p>distinct 列名</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 查询员工表中有多少个经理</span><br><span class="line">SELECT DISTINCT MANAGER_ID FROM t_employees;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-3-排序查询"><a href="#7-3-排序查询" class="headerlink" title="7.3  排序查询"></a>7.3  排序查询</h3><blockquote>
<p>语法:SELECT 列名 FROM 表名 <code>ORDER BY排序列[排序规则]</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>排序规则</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ASC</td>
<td>对前面排序列做升序排列</td>
</tr>
<tr>
<td>desc</td>
<td>对前面排序列做降序排序</td>
</tr>
</tbody></table>
<h4 id="7-3-1-依据单列排序"><a href="#7-3-1-依据单列排序" class="headerlink" title="7.3.1  依据单列排序"></a>7.3.1  依据单列排序</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 对员工工资进行升序排序</span><br><span class="line">SELECT EMPLOYEE_ID,salary FROM t_employees ORDER BY salary + 0 ASC;</span><br><span class="line"># 对员工工资进行降序排序</span><br><span class="line">SELECT EMPLOYEE_ID,salary FROM t_employees ORDER BY salary + 0 DESC;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="7-3-2-依据多列排序"><a href="#7-3-2-依据多列排序" class="headerlink" title="7.3.2  依据多列排序"></a>7.3.2  依据多列排序</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 按照工资高低进行降序排序，如果工资相等，按照员工编号升序进行排序</span><br><span class="line">SELECT EMPLOYEE_ID,salary FROM t_employees ORDER BY salary + 0 DESC, EMPLOYEE_ID DESC;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-4-条件查询"><a href="#7-4-条件查询" class="headerlink" title="7.4  条件查询"></a>7.4  条件查询</h3><blockquote>
<p>语法:  SELECT 列名 FROM 表名 WHERE  条件</p>
</blockquote>
<table>
<thead>
<tr>
<th>关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>where 条件</td>
<td>在查询结果中，筛选符合查询条件的查询结果，条件为布尔表达式</td>
</tr>
</tbody></table>
<h4 id="7-4-1-等值判断"><a href="#7-4-1-等值判断" class="headerlink" title="7.4.1  等值判断"></a>7.4.1  等值判断</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 查询符合条件的数据</span><br><span class="line">SELECT EMPLOYEE_ID, FIRST_NAME,salary</span><br><span class="line">FROM t_employees</span><br><span class="line">WHERE SALARY = 11000</span><br><span class="line"></span><br><span class="line">SELECT EMPLOYEE_ID, FIRST_NAME,salary</span><br><span class="line">FROM t_employees</span><br><span class="line">WHERE SALARY = 24000</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>注意：与java不同（==），mysql中等值判断使用=</li>
</ul>
<h4 id="7-4-2-逻辑判断（and-、or、-not）"><a href="#7-4-2-逻辑判断（and-、or、-not）" class="headerlink" title="7.4.2  逻辑判断（and 、or、 not）"></a>7.4.2  逻辑判断（and 、or、 not）</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SELECT EMPLOYEE_ID, FIRST_NAME,salary</span><br><span class="line">FROM t_employees</span><br><span class="line">WHERE SALARY = 11000 AND COMMISSION_PCT = 0.30 AND EMPLOYEE_ID = '148';</span><br><span class="line"></span><br><span class="line">SELECT EMPLOYEE_ID, FIRST_NAME,salary</span><br><span class="line">FROM t_employees</span><br><span class="line">WHERE SALARY = 11000 OR COMMISSION_PCT = 0.30;</span><br><span class="line"></span><br><span class="line">SELECT EMPLOYEE_ID, FIRST_NAME,salary</span><br><span class="line">FROM t_employees</span><br><span class="line">WHERE NOT SALARY = 11000;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="7-4-3-不等值判断（-gt-、-lt-、-gt-、-lt-、-lt-gt-、-）"><a href="#7-4-3-不等值判断（-gt-、-lt-、-gt-、-lt-、-lt-gt-、-）" class="headerlink" title="7.4.3  不等值判断（>、 <、>=、<=、<>、!=）"></a>7.4.3  不等值判断（&gt;、 &lt;、&gt;=、&lt;=、&lt;&gt;、!=）</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SELECT EMPLOYEE_ID, FIRST_NAME,salary</span><br><span class="line">FROM t_employees</span><br><span class="line">WHERE SALARY != 11000;</span><br><span class="line"></span><br><span class="line">SELECT EMPLOYEE_ID, FIRST_NAME,salary</span><br><span class="line">FROM t_employees</span><br><span class="line">WHERE SALARY &lt;&gt; 11000;</span><br><span class="line"></span><br><span class="line"># 查询工资区间在[6000, 10000]之间</span><br><span class="line">SELECT EMPLOYEE_ID, FIRST_NAME,salary</span><br><span class="line">FROM t_employees</span><br><span class="line">WHERE SALARY &gt;= 6000 AND salary &lt;= 10000;</span><br></pre></td></tr></tbody></table></figure>



<h4 id="7-4-4-区间判断-between-起始and-终止"><a href="#7-4-4-区间判断-between-起始and-终止" class="headerlink" title="7.4.4  区间判断(between 起始and 终止)"></a>7.4.4  区间判断(between 起始and 终止)</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 查询工资区间在[6000, 10000]之间</span><br><span class="line">SELECT EMPLOYEE_ID, FIRST_NAME,salary</span><br><span class="line">FROM t_employees</span><br><span class="line">WHERE SALARY BETWEEN 6000 AND 10000;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>注意：在区间判断中，小值在前，大值在后，反之，得不到结果</li>
</ul>
<h4 id="7-4-5-null值判断（is-null、is-not-null）"><a href="#7-4-5-null值判断（is-null、is-not-null）" class="headerlink" title="7.4.5 null值判断（is null、is not null）"></a>7.4.5 null值判断（is null、is not null）</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 查询出经理编号为null的员工信息</span><br><span class="line">SELECT employee_id, FIRST_NAME,MANAGER_ID</span><br><span class="line">FROM t_employees</span><br><span class="line">WHERE MANAGER_ID IS NULL;</span><br><span class="line"></span><br><span class="line">SELECT employee_id, FIRST_NAME,MANAGER_ID</span><br><span class="line">FROM t_employees</span><br><span class="line">WHERE MANAGER_ID IS NOT NULL;</span><br></pre></td></tr></tbody></table></figure>



<h4 id="7-4-6-枚举查询（IN（值1，-值2，值3））"><a href="#7-4-6-枚举查询（IN（值1，-值2，值3））" class="headerlink" title="7.4.6  枚举查询（IN（值1， 值2，值3））"></a>7.4.6  枚举查询（IN（值1， 值2，值3））</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 查询部门编号为70,80,90 的员工信息</span><br><span class="line">SELECT EMPLOYEE_ID, FIRST_NAME,SALARY,department_id</span><br><span class="line">FROM t_employees</span><br><span class="line">WHERE department_id = 70 OR department_id = 80 OR department_id = 90;</span><br><span class="line"></span><br><span class="line">SELECT EMPLOYEE_ID, FIRST_NAME,SALARY,department_id</span><br><span class="line">FROM t_employees</span><br><span class="line">WHERE department_id IN (70,80,90);</span><br><span class="line"># in 的效率在大数据面前较低</span><br></pre></td></tr></tbody></table></figure>



<h4 id="7-4-7-模糊查询"><a href="#7-4-7-模糊查询" class="headerlink" title="7.4.7  模糊查询"></a>7.4.7  模糊查询</h4><blockquote>
<ul>
<li>LIKE_（单个任由字符）</li>
</ul>
<p>​       列名 LIKE ‘张__’</p>
<ul>
<li><p>LIKE %(任意长度的任意字符)</p>
<p>列名 LIKE ‘张%’</p>
</li>
</ul>
</blockquote>
<ul>
<li>注意：模糊查询只能和LIKE关键字结合使用</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 查询L开头的三个字的员工信息</span><br><span class="line">SELECT EMPLOYEE_ID, FIRST_NAME, SALARY</span><br><span class="line">FROM t_employees</span><br><span class="line">WHERE FIRST_NAME LIKE 'L__';</span><br><span class="line"># 查询所有以L开头的员工信息</span><br><span class="line">SELECT EMPLOYEE_ID,FIRST_NAME,SALARY</span><br><span class="line">FROM t_employees</span><br><span class="line">WHERE first_name LIKE '张%';</span><br></pre></td></tr></tbody></table></figure>

<h4 id="7-4-8-分支结构查询"><a href="#7-4-8-分支结构查询" class="headerlink" title="7.4.8 分支结构查询"></a>7.4.8 分支结构查询</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CASE</span><br><span class="line">    WHEN 条件1 THEN 结果1</span><br><span class="line">    WHEN 条件2 THEN 结果2</span><br><span class="line">    WHEN 条件3 THEN 结果3</span><br><span class="line">    ELSE 结果</span><br><span class="line">END</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>注意：通过使用case  end进行条件判断，每条数据对应生成一个值</li>
<li>经验：类似java中的switch</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 查询员工信息</span><br><span class="line">SELECT EMPLOYEE_ID, FIRST_NAME, SALARY,department_id,</span><br><span class="line">CASE</span><br><span class="line">	WHEN SALARY &gt;= 10000 THEN 'A'</span><br><span class="line">	WHEN SALARY &gt;= 8000 AND SALARY &lt; 10000 THEN 'B'</span><br><span class="line">	WHEN SALARY &gt;= 6000 AND SALARY &lt; 8000 THEN 'C'</span><br><span class="line">	WHEN SALARY &gt;= 4000 AND SALARY &lt; 6000 THEN 'D'</span><br><span class="line">	ELSE 'E'</span><br><span class="line">END AS "level"</span><br><span class="line">FROM t_employees;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-5-时间查询"><a href="#7-5-时间查询" class="headerlink" title="7.5  时间查询"></a>7.5  时间查询</h3><blockquote>
<p>select     时间函数（[参数列表]）</p>
</blockquote>
<ul>
<li>经验：执行时间函数查询，会自动生成一张虚表</li>
</ul>
<table>
<thead>
<tr>
<th>时间函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SYSDATE</td>
<td>当前系统时间（日月年时分秒）</td>
</tr>
<tr>
<td>CURDATE</td>
<td>获取当前日期</td>
</tr>
<tr>
<td>CURTIME</td>
<td>获取当前时间</td>
</tr>
<tr>
<td>WEEK(DATE)</td>
<td>获取指定日期为一年中的第几周</td>
</tr>
<tr>
<td>YEAR(DATE)</td>
<td>获取指定日期的年份</td>
</tr>
<tr>
<td>HOUR(TIME)</td>
<td>获取指定时间的小时值</td>
</tr>
<tr>
<td>MINUTE(TIME)</td>
<td>获取时间的分钟值</td>
</tr>
<tr>
<td>DATEDIFF(DATE,DATE2)</td>
<td>获取DATE1和DATE2之间相隔的天数</td>
</tr>
<tr>
<td>ADDDATE(DATE,N)</td>
<td>计算DATE加上N天后的日期</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 当前系统的时间</span><br><span class="line">SELECT SYSDATE();</span><br><span class="line"># 当前系统的ri期</span><br><span class="line">SELECT CURDATE();</span><br><span class="line"># 获取系统时间</span><br><span class="line">SELECT CURTIME();</span><br><span class="line"># 获取指定日期为一年中的第几周</span><br><span class="line">SELECT WEEK(SYSDATE());</span><br><span class="line"># 获取指定日期忠厚的年份</span><br><span class="line">SELECT YEAR(SYSDATE());</span><br><span class="line"># 获取小时值</span><br><span class="line">SELECT HOUR(CURTIME());</span><br><span class="line"># 获取分钟值</span><br><span class="line">SELECT MINUTE(CURTIME());</span><br><span class="line"># 指定日期之间的相隔天数</span><br><span class="line">SELECT DATEDIFF('2020-4-1','2019-4-1');</span><br><span class="line"># 计算date日期加上n天后的日期</span><br><span class="line">SELECT	ADDDATE('2020-4-1', 5);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-6-字符串查询"><a href="#7-6-字符串查询" class="headerlink" title="7.6  字符串查询"></a>7.6  字符串查询</h3><blockquote>
<p>语法:    SELECT    字符串函数([参数列表])</p>
</blockquote>
<table>
<thead>
<tr>
<th>字符串函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>concat(str1, …)</td>
<td>将多个字符串拼接</td>
</tr>
<tr>
<td>insert(str, pos, len, newStr)</td>
<td>将str中指定pos位置开始len长度的内容替换为newStr</td>
</tr>
<tr>
<td>lower(str)</td>
<td>将指定字符串转换诶小写</td>
</tr>
<tr>
<td>upper(str)</td>
<td>将指定字符串转换为大写</td>
</tr>
<tr>
<td>substring(str, num, len)</td>
<td>将str字符串指定num位置开始截取len个内容</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 多个字符串拼接</span><br><span class="line">SELECT CONCAT('My', 'S,', 'QAL');</span><br><span class="line">SELECT CONCAT(FIRST_NAME,'-', last_name) FROM t_employees;</span><br><span class="line"># 字符串替换</span><br><span class="line">SELECT INSERT('这是一个数据库',3, 2, 'MySql')</span><br><span class="line"># 字符串转小写</span><br><span class="line">SELECT LOWER('LOWER')</span><br><span class="line"># 字符串转大写</span><br><span class="line">SELECT UPPER('shdiuashdui')</span><br><span class="line"># 指定内容截取</span><br><span class="line">SELECT SUBSTRING('JaavaMySqlStrSub',6,6);</span><br><span class="line"># MySqlS</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-7-聚合函数"><a href="#7-7-聚合函数" class="headerlink" title="7.7  聚合函数"></a>7.7  聚合函数</h3><blockquote>
<p>语法:    SELECT 聚合函数(列名)      FROM    表名;</p>
</blockquote>
<ul>
<li>经验：对多条数据的单列进行统计，返回统计后的一行结果</li>
</ul>
<table>
<thead>
<tr>
<th>聚合函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SUM（）</td>
<td>求所有行中单列结果的总和</td>
</tr>
<tr>
<td>AVG()</td>
<td>平均值</td>
</tr>
<tr>
<td>MAX()</td>
<td>最大值</td>
</tr>
<tr>
<td>MIN()</td>
<td>最小值</td>
</tr>
<tr>
<td>COUNT()</td>
<td>求总行数</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 聚合函数</span><br><span class="line"># 求单列所有数据的和</span><br><span class="line">SELECT SUM(SALARY) FROM t_employees;</span><br><span class="line"># 求单列所有数据的平均值</span><br><span class="line">SELECT AVG(SALARY) FROM t_employees;</span><br><span class="line"># 求单列最大值</span><br><span class="line">SELECT MAX(SALARY + 0) FROM t_employees;</span><br><span class="line"># 求单列最小值</span><br><span class="line">SELECT MIN(salary + 0) FROM t_employees;</span><br><span class="line"># 求总行数 员工总数</span><br><span class="line">SELECT COUNT(EMPLOYEE_ID) FROM t_employees;</span><br><span class="line"># 统计有提成的人数 会自动忽略null值，不进行统计</span><br><span class="line">SELECT COUNT(COMMISSION_PCT) FROM t_employees;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>注意：聚合函数会自动忽略null值，不进行统计</li>
</ul>
<h3 id="7-8-分组查询"><a href="#7-8-分组查询" class="headerlink" title="7.8  分组查询"></a>7.8  分组查询</h3><blockquote>
<p>语法：<code>SELECT 列名 FROM 表名 WHERE 条件 GROUP BY 分组依据(列);</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GROUP BY</td>
<td>分组依据，必须在WHERE之后生效</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 查询各个部门的额总人数</span><br><span class="line">SELECT department_id, COUNT(employee_id)</span><br><span class="line">FROM t_employees</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"># 查询各个部门的平局工资</span><br><span class="line">SELECT department_id, AVG(salary)</span><br><span class="line">FROM t_employees</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"># 查询各个部门、各个岗位的总人数</span><br><span class="line">SELECT department_id,job_id, COUNT(employee_id)</span><br><span class="line">FROM t_employees</span><br><span class="line">GROUP BY department_id, job_id;</span><br><span class="line"># 常见问题：查询各个部门id，总人数、first_name</span><br><span class="line">SELECT department_id,COUNT(employee_id), first_name</span><br><span class="line">FROM t_employees</span><br><span class="line">GROUP BY department_id;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>分组查询中，select显示的列只能是分组依据列，或者聚合函数列，不能出现其他列</li>
</ul>
<h3 id="7-9-分组过滤查询"><a href="#7-9-分组过滤查询" class="headerlink" title="7.9  分组过滤查询"></a>7.9  分组过滤查询</h3><blockquote>
<p>语法：<code>SELECT 列名 FROM 表名 WHERE 条件 GROUNP BY 分组列 HAVING 过滤规则</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>HAVING过滤规则</td>
<td>过滤规则定义对分组后的数据进行过滤</td>
</tr>
</tbody></table>
<p>统计部门的最高工资</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#思路</span><br><span class="line">#1.确定分组依据（DEPARTMENT_ID）</span><br><span class="line">#2.对分组后的数据，过滤出部门编号是60、70、90信息</span><br><span class="line">#3.MAX()函数</span><br><span class="line">SELECT DEPARTMENT_ID,MAX(SALARY) </span><br><span class="line">FROM t_employees GROUP BY DEPARTMENT_ID </span><br><span class="line">HAVING DEPARTMENT_ID IN (60,70,90);</span><br><span class="line">#GROUP确定分组依据DEPARTMENT_ID</span><br><span class="line">#HAVING过滤出60，70，90的部门</span><br><span class="line">#SELECT查看部门编号和MAX函数</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-10-限定查询"><a href="#7-10-限定查询" class="headerlink" title="7.10  限定查询"></a>7.10  限定查询</h3><blockquote>
<p> <strong>语法</strong>：<code>SELECT 列名 FROM 表名 LIMIT 起始行,查询行数</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LIMIT offset_start,row_count</td>
<td>限定查询结果的起始行和总行数</td>
</tr>
</tbody></table>
<h4 id="7-10-1-查询前5行记录"><a href="#7-10-1-查询前5行记录" class="headerlink" title="7.10.1 查询前5行记录"></a>7.10.1 查询前5行记录</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#查询表中前五名员工的所有信息</span><br><span class="line">SELECT * FROM t_employees LIMIT 0,5;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>注意</strong>：<strong>起始行是从0开始</strong>，<strong>代表了第一行</strong>，<strong>第二个参数代表的是从指定行开始查询几行</strong>。</li>
</ul>
<h4 id="7-10-2-查询范围记录"><a href="#7-10-2-查询范围记录" class="headerlink" title="7.10.2 查询范围记录"></a>7.10.2 查询范围记录</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#查询表中从第四行开始，查询10行</span><br><span class="line">SELECT * FROM t_employees LIMIT 3,10;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="7-10-3-LIMIT典型应用"><a href="#7-10-3-LIMIT典型应用" class="headerlink" title="7.10.3 LIMIT典型应用"></a>7.10.3 LIMIT典型应用</h4><p>分页查询：一页显示10条，一共查询三页。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#思路：第一页是从0开始，显示10条</span><br><span class="line">SELECT * FROM t_employees LIMIT 0,10;</span><br><span class="line">#第二页是从10条开始，显示10条</span><br><span class="line">SELECT * FROM t_employees LIMIT 10,10;</span><br><span class="line">#第三页是从20条开始，显示10条</span><br><span class="line">SELECT * FROM t_employees LIMIT 20,10;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>在分页应用场景中，起始行是变化的，但是一页显示的页数是不变的</li>
</ul>
<h3 id="7-11-查询总结"><a href="#7-11-查询总结" class="headerlink" title="7.11  查询总结"></a>7.11  查询总结</h3><h4 id="7-11-1-SQL语句编写顺序"><a href="#7-11-1-SQL语句编写顺序" class="headerlink" title="7.11.1 SQL语句编写顺序"></a>7.11.1 SQL语句编写顺序</h4><blockquote>
<p>COPYSELECT 列名 FROM 表名 WHERE 条件 GROUP BY 分组 HAVING 过滤条件 ORDER BY 排序列(ASC|DESC) LIMIT 起始行,查询行数</p>
</blockquote>
<h4 id="7-11-2-SQL语句执行顺序"><a href="#7-11-2-SQL语句执行顺序" class="headerlink" title="7.11.2 SQL语句执行顺序"></a>7.11.2 SQL语句执行顺序</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">COPY1.FROM:指定数据来源表</span><br><span class="line">2.WHERE:对查询数据第一次过滤</span><br><span class="line">3.GROUP BY:分组</span><br><span class="line">4.HAVING:对分组后的数据第二次过滤</span><br><span class="line">5.SELECT:查询各字段的值</span><br><span class="line">6.ORDER BY:排序</span><br><span class="line">7.LIMIT:限定查询结果</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-12-子查询（作为条件判断）"><a href="#7-12-子查询（作为条件判断）" class="headerlink" title="7.12  子查询（作为条件判断）"></a>7.12  子查询（作为条件判断）</h3><blockquote>
<p><strong>语法</strong>：<code>SELECT 列名 FROM 表名 WHERE 条件(子查询结果)</code></p>
</blockquote>
<h4 id="7-12-1-查询工资大于Bruce的员工信息"><a href="#7-12-1-查询工资大于Bruce的员工信息" class="headerlink" title="7.12.1 查询工资大于Bruce的员工信息"></a>7.12.1 查询工资大于Bruce的员工信息</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#1.先查询到Bruce的工资（一行一列）</span><br><span class="line">SELECT SALARY FROM t_employees WHERE FIRST_NAME = 'Bruce';</span><br><span class="line">#2.查询工资大于Bruce的员工信息</span><br><span class="line">SELECT * FROM t_employees WHERE SALARY &gt; 6000;</span><br><span class="line">#3.将前两句整合</span><br><span class="line">SELECT * FROM t_employees </span><br><span class="line">WHERE SALARY &gt; </span><br><span class="line">(SELECT SALARY FROM t_employees WHERE FIRST_NAME = 'Bruce');</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>注意</strong>：<strong>将子查询</strong>“<strong>一行一列</strong>”<strong>的结果作为外部查询的条件</strong>，<strong>做第二次查询</strong>。</li>
<li><strong>子查询得到一行一列的结果才能作为外部查询的等值判断条件或不等值判断条件</strong></li>
</ul>
<h3 id="7-13-子查询（作为枚举查询的条件）"><a href="#7-13-子查询（作为枚举查询的条件）" class="headerlink" title="7.13 子查询（作为枚举查询的条件）"></a>7.13 子查询（作为枚举查询的条件）</h3><blockquote>
<p> <strong>语法</strong>：<code>SELECT 列名 FROM 表名 WHERE 列名 IN (子查询结果);</code></p>
</blockquote>
<h4 id="7-13-1-查询与名为“KING”同一部门的员工信息"><a href="#7-13-1-查询与名为“KING”同一部门的员工信息" class="headerlink" title="7.13.1 查询与名为“KING”同一部门的员工信息"></a>7.13.1 查询与名为“KING”同一部门的员工信息</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#思路</span><br><span class="line">#1.先查询KING所在的部门编号</span><br><span class="line">SELECT DEPARTMENT_ID FROM t_employees WHERE LAST_NAME = 'King';#80,90</span><br><span class="line">#2.再查询80，90号部门的员工信息</span><br><span class="line">SELECT * FROM t_employees WHERE DEPARTMENT_ID IN(80,90);</span><br><span class="line">#3.SQL:合并</span><br><span class="line">SELECT * FROM t_employees </span><br><span class="line">WHERE DEPARTMENT_ID IN</span><br><span class="line">(SELECT DEPARTMENT_ID FROM t_employees WHERE LAST_NAME = 'King');</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>将子查询</strong>“<strong>多行一列</strong>”<strong>的结果作为外部查询的枚举查询条件</strong>，<strong>做第二次查询</strong>。</li>
</ul>
<h4 id="7-13-2-工资高于60编号部门的员工信息"><a href="#7-13-2-工资高于60编号部门的员工信息" class="headerlink" title="7.13.2 工资高于60编号部门的员工信息"></a>7.13.2 工资高于60编号部门的员工信息</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#1.查询60编号部门所有人的工资（多行单列）</span><br><span class="line">SELECT SALARY FROM t_employees WHERE DEPARTMENT_ID = 60;</span><br><span class="line">#2.查询工资高于60编号部门所有人的工资的员工信息（高于所有）</span><br><span class="line">SELECT * FROM t_employees </span><br><span class="line">WHERE SALARY &gt; </span><br><span class="line">ALL(SELECT SALARY FROM t_employees WHERE DEPARTMENT_ID = 60);</span><br><span class="line">#3.查询工资高于60编号部门的员工信息（高于部分）</span><br><span class="line">SELECT * FROM t_employees </span><br><span class="line">WHERE SALARY &gt; </span><br><span class="line">ANY(SELECT SALARY FROM t_employees WHERE DEPARTMENT_ID = 60);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p><strong>注意</strong>：<strong>当子查询结果集形式为多行单列时可以使用ANY或ALL关键字</strong>。</p>
</li>
<li><p>ALL表示查询高于部门所有员工工资的员工信息；ANY表示查询只需要高于部门中任意一名员工工资的员工信息</p>
</li>
</ul>
<h3 id="7-14-子查询（作为一张表）"><a href="#7-14-子查询（作为一张表）" class="headerlink" title="7.14  子查询（作为一张表）"></a>7.14  子查询（作为一张表）</h3><p>查询到一张多行多列的临时表，这张表也可以作为查询数据源。</p>
<blockquote>
<p> <strong>语法</strong>：<code>SELECT 列名 FROM (子查询的结果集) WHERE 条件;</code></p>
</blockquote>
<h4 id="7-14-1-查询员工表中工资排名前5名的员工信息"><a href="#7-14-1-查询员工表中工资排名前5名的员工信息" class="headerlink" title="7.14.1 查询员工表中工资排名前5名的员工信息"></a>7.14.1 查询员工表中工资排名前5名的员工信息</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#思路：</span><br><span class="line">#1.先对所有员工的薪资进行排序（排序后的临时表）</span><br><span class="line">SELECT EMPLOYEE_ID,FIRST_NAME,SALARY FROM t_employees ORDER BY SALARY DESC;</span><br><span class="line">#2.再查询临时表中前5行员工信息</span><br><span class="line">SELECT EMPLOYEE_ID,FIRST_NAME,SALARY FROM (临时表) LIMIT 0,5;</span><br><span class="line">#3.合并</span><br><span class="line">SELECT * FROM </span><br><span class="line">(SELECT EMPLOYEE_ID,FIRST_NAME,SALARY FROM t_employees ORDER BY SALARY DESC) AS 临时表 LIMIT 0,5;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>将子查询</strong>“<strong>多行多列</strong>“<strong>的结果作为外部查询的一张表</strong>，<strong>做第二次查询</strong>。</li>
<li><strong>注意</strong>：<strong>子查询作为临时表</strong>，<strong>需要为其赋予一个临时表名</strong>。</li>
</ul>
<h3 id="7-15-合并查询"><a href="#7-15-合并查询" class="headerlink" title="7.15  合并查询"></a>7.15  合并查询</h3><blockquote>
<ul>
<li><code>SELECT * FROM 表名1 UNION SELECT * FROM 表名2</code></li>
<li><code>SELECT * FROM 表名1 UNION ALL SELECT * FROM 表名2</code></li>
</ul>
</blockquote>
<ul>
<li>返回的查询结果是将表1的结果和表2的结果做了一个合并。</li>
</ul>
<h4 id="15-1-合并两张表的结果（去除重复记录）"><a href="#15-1-合并两张表的结果（去除重复记录）" class="headerlink" title="15.1 合并两张表的结果（去除重复记录）"></a>15.1 合并两张表的结果（去除重复记录）</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#合并两张表的结果，去除重复记录</span><br><span class="line">SELECT * FROM T1 UNION SELECT * FROM T2;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>注意</strong>：<strong>合并结果的两张表</strong>，<strong>列数必须相同</strong>，<strong>列的数据类型可以不同</strong>。</li>
</ul>
<p>列数必须相同是因为该合并做了一个纵向合并，两个4列多行的结果集表合并后也是一个4列多行的表，但是合并后的列名以第一个结果集表为准。</p>
<h4 id="7-15-2-合并两张表的结果（保留重复记录）"><a href="#7-15-2-合并两张表的结果（保留重复记录）" class="headerlink" title="7.15.2 合并两张表的结果（保留重复记录）"></a>7.15.2 合并两张表的结果（保留重复记录）</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#合并两张表的结果，不去除重复记录（显示所有）</span><br><span class="line">SELECT * FROM T1 UNION ALL SELECT * FROM T2;</span><br></pre></td></tr></tbody></table></figure>

<p>该合并结果会保留两张查询表中重复的记录，而UNION只保留第一个不重复的记录</p>
<p>7.16 表连接查询</p>
<blockquote>
<p>语法：<code>SELECT 列名 FROM 表1 连接方式 表2 ON 连接条件</code></p>
</blockquote>
<h4 id="7-16-1-内连接查询（INNER-JOIN-ON）"><a href="#7-16-1-内连接查询（INNER-JOIN-ON）" class="headerlink" title="7.16.1 内连接查询（INNER JOIN ON）"></a>7.16.1 内连接查询（INNER JOIN ON）</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#1.查询所有员工的职员和职位信息 SQL标准</span><br><span class="line">SELECT * FROM t_employees INNER JOIN t_jobs </span><br><span class="line">ON t_employees.JOB_ID = t_jobs.JOB_ID;</span><br><span class="line">#2.查询所有员工的职员和职位信息 MYSQL</span><br><span class="line">SELECT * FROM t_employees,t_jobs WHERE t_employees.JOB_ID = t_jobs.JOB_ID;</span><br></pre></td></tr></tbody></table></figure>

<p>如果没有指定连接条件，则会造成笛卡尔积的结果，第一张表中的每行数据都会和第二张表进行连接。</p>
<ul>
<li><strong>经验</strong>：<strong>在MySQL中</strong>，<strong>第二种方式也可以作为内连接查询</strong>，<strong>但是不符合SQL标准</strong>。</li>
<li><strong>而第一种属于SQL标准</strong>，<strong>与其他关系型数据库通用</strong>。</li>
</ul>
<h4 id="7-16-2-三表连接查询"><a href="#7-16-2-三表连接查询" class="headerlink" title="7.16.2 三表连接查询"></a>7.16.2 三表连接查询</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#查询所有员工工号、名字、部门名称、部门所在国家ID</span><br><span class="line">SELECT EMPLOYEE_ID,FIRST_NAME,t_departments.DEPARTMENT_NAME,t_locations.COUNTRY_ID </span><br><span class="line">FROM t_employees</span><br><span class="line">INNER JOIN t_departments ON	</span><br><span class="line">t_employees.DEPARTMENT_ID=t_departments.DEPARTMENT_ID</span><br><span class="line">INNER JOIN t_locations ON	</span><br><span class="line">t_departments.LOCATION_ID=t_locations.LOCATION_ID;</span><br></pre></td></tr></tbody></table></figure>

<p>该语句查询出来的结果没有员工编号为178的员工信息，该名员工的部门ID为NULL，不符合连接条件，所以不包含在匹配出的结果集中，你可以自己动手尝试并查看结果。之所以提这个是因为可以与下节的语句区分开来。</p>
<h4 id="7-16-3-左外连接（LEFT-JOIN-ON）"><a href="#7-16-3-左外连接（LEFT-JOIN-ON）" class="headerlink" title="7.16.3 左外连接（LEFT JOIN ON）"></a>7.16.3 左外连接（LEFT JOIN ON）</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#查询所有员工的工号、名字、工资及其对应的部门名称（没有部门的员工也在查询结果中，部门名称以NULL值补充）</span><br><span class="line">SELECT EMPLOYEE_ID,FIRST_NAME,SALARY,DEPARTMENT_NAME </span><br><span class="line">FROM t_employees</span><br><span class="line">LEFT JOIN t_departments </span><br><span class="line">ON t_departments.DEPARTMENT_ID=t_employees.DEPARTMENT_ID;</span><br></pre></td></tr></tbody></table></figure>

<p>该语句查询出来的结果包含没有部门的178号员工，DEPARTMENT_NAME的值被填充为NULL。</p>
<ul>
<li><strong>注意</strong>：<strong>左外连接</strong>，<strong>是以左表作为主表</strong>，<strong>依次向右匹配</strong>，<strong>匹配到则返回结果</strong>；</li>
<li><strong>匹配不到则返回NULL值填充</strong>。</li>
</ul>
<h4 id="7-16-4-右外连接（RIGHT-JOIN-ON）"><a href="#7-16-4-右外连接（RIGHT-JOIN-ON）" class="headerlink" title="7.16.4 右外连接（RIGHT JOIN ON）"></a>7.16.4 右外连接（RIGHT JOIN ON）</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#查询所有部门信息，以及此部门中的所有员工信息（没有员工的部门也在查询结果中，员工信息以NULL值填充）</span><br><span class="line">SELECT EMPLOYEE_ID,FIRST_NAME,SALARY,DEPARTMENT_NAME </span><br><span class="line">FROM t_employees</span><br><span class="line">RIGHT JOIN t_departments </span><br><span class="line">ON t_departments.DEPARTMENT_ID=t_employees.DEPARTMENT_ID;</span><br></pre></td></tr></tbody></table></figure>

<p>该查询结果以部门表作为主表，有些部门没有员工，其员工信息全部为NULL。</p>
<ul>
<li><strong>注意</strong>：<strong>右外连接</strong>，<strong>是以右表为主表</strong>，<strong>依次向左匹配</strong>，<strong>匹配到返回结果</strong>。</li>
<li><strong>匹配不到</strong>，<strong>则返回NULL值填充</strong>。</li>
</ul>
<h2 id="八、DML操作【重点】"><a href="#八、DML操作【重点】" class="headerlink" title="八、DML操作【重点】"></a>八、DML操作【重点】</h2><blockquote>
<p> DDL（Data Manipulation Language）数据库操纵语言，是其中一类SQL语言，其实也就是<strong>增删改</strong>。</p>
</blockquote>
<h3 id="8-1-新增（INSERT）"><a href="#8-1-新增（INSERT）" class="headerlink" title="8.1 新增（INSERT）"></a>8.1 新增（INSERT）</h3><blockquote>
<p> <strong>语法</strong>：<code>INSERT INTO 表名(列1,列2,列3......) VALUES(值1,值2,值3......);</code></p>
</blockquote>
<h4 id="8-1-1-添加一条信息"><a href="#8-1-1-添加一条信息" class="headerlink" title="8.1.1 添加一条信息"></a>8.1.1 添加一条信息</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#添加一条岗位信息</span><br><span class="line">INSERT INTO t_jobs(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) </span><br><span class="line">VALUES('JAVA_LE','Java Lecturer',6000,1200);</span><br><span class="line">#添加一条员工信息</span><br><span class="line">INSERT INTO t_employees(EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID)</span><br><span class="line">VALUES('194','Liu','YUNChe','xxx@qq.com','12345','2020-11-14','JAVA_LE','11000','0.6',null,'50');</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>注意</strong>：<strong>表名后的列名要和VALUE里的值一一对应</strong>（<strong>个数</strong>、<strong>顺序</strong>、<strong>类型</strong>）。</li>
</ul>
<h3 id="8-2-修改（UPDATA）"><a href="#8-2-修改（UPDATA）" class="headerlink" title="8.2 修改（UPDATA）"></a>8.2 修改（UPDATA）</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#修改编号为100的员工工资为25000</span><br><span class="line">UPDATE t_employees SET SALARY = 25000 WHERE EMPLOYEE_ID = '100';</span><br><span class="line">#修改编号为100的员工信息岗位编号为 ST_MAN，工资为3500</span><br><span class="line">UPDATE t_employees SET JOB_ID = 'ST_MAN',SALARY = 3500 WHERE EMPLOYEE_ID = '135';</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>注意</strong>：<strong>SET后多个列名=值</strong>，<strong>绝大多数情况下都要加WHERE条件指定修改</strong>，<strong>否则为整表更新</strong>。</li>
</ul>
<h3 id="8-3-删除（DELETE）"><a href="#8-3-删除（DELETE）" class="headerlink" title="8.3 删除（DELETE）"></a>8.3 删除（DELETE）</h3><p>语法：<code>DELETE FROM 表名 WHERE 条件;</code></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#删除编号为135的员工</span><br><span class="line">DELETE FROM t_employees WHERE EMPLOYEE_ID = '135';</span><br><span class="line">#删除姓Peter,并且名为Hall的员工</span><br><span class="line">DELETE FROM t_employees WHERE EMPLOYEE_ID = '135';</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>注意</strong>：<strong>删除时</strong>，<strong>如果不加条件</strong>，<strong>则默认删除整张表</strong>。</li>
</ul>
<p><font color="cornflowerblue">用DELETE删除整表是不彻底的，它只是删除了内容，并没有改变表的结构。</font></p>
<h3 id="8-4-清空整表数据（TRUNCATE）"><a href="#8-4-清空整表数据（TRUNCATE）" class="headerlink" title="8.4 清空整表数据（TRUNCATE）"></a>8.4 清空整表数据（TRUNCATE）</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">COPYTRUNCATE TABLE 表名;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="8-4-1-清空整张表"><a href="#8-4-1-清空整张表" class="headerlink" title="8.4.1 清空整张表"></a>8.4.1 清空整张表</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">COPY#清空t1整张表</span><br><span class="line">TRUNCATE TABLE t1;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>注意</strong>：<strong>与DELETE不加WHERE删除整表数据不同</strong>，<strong>TRUNCATE是把原表销毁</strong>，<strong>再按原表的格式创建一张新表</strong>。</li>
</ul>
<h2 id="九、数据表操作"><a href="#九、数据表操作" class="headerlink" title="九、数据表操作"></a>九、数据表操作</h2><h3 id="9-1-数据类型"><a href="#9-1-数据类型" class="headerlink" title="9.1 数据类型"></a>9.1 数据类型</h3><blockquote>
<p> <font color="red">MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串（字符）类型。对于我们约束数据的类型有很大的帮助。</font></p>
</blockquote>
<h4 id="9-1-1-数值类型"><a href="#9-1-1-数值类型" class="headerlink" title="9.1.1 数值类型"></a>9.1.1 数值类型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>范围（有符号）</th>
<th>范围（无符号）</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>INT</td>
<td>4字节</td>
<td>(-2147483648,2147483647)</td>
<td>(0,4294967295)</td>
<td>大整数值</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8字节</td>
<td>(-1.797E+308,-2.22E-308)</td>
<td>0,(2.22E-308,1.797E+308)</td>
<td><code>双精度浮点数值</code></td>
</tr>
<tr>
<td><code>DOUBLE(M,D)</code></td>
<td>8字节，M表示长度，D表示小数位数</td>
<td>同上，受M和D的约束；如DOUBLE(5,2) -999.99~999.99</td>
<td>同上，受M和D的约束</td>
<td>双精度浮点数值</td>
</tr>
<tr>
<td>DECIMAL(M,D)</td>
<td>DECIMAL(M,D)</td>
<td>依赖于M和D的值，M最大值为65</td>
<td>依赖于M和D的值，M最大值为65</td>
<td>小数值</td>
</tr>
</tbody></table>
<h4 id="9-1-2-日期类型"><a href="#9-1-2-日期类型" class="headerlink" title="9.1.2 日期类型"></a>9.1.2 日期类型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>范围</th>
<th>格式</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DATE</strong></td>
<td>3</td>
<td>1000-01-01/9999-12-31</td>
<td>YYYY-MM-DD</td>
<td>日期值</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
<td>‘-838:59:59’/‘838:59:59’</td>
<td>HH:MM:SS</td>
<td>时间值或持续时间</td>
</tr>
<tr>
<td>YEAR</td>
<td>1</td>
<td>1901/2155</td>
<td>YYYY</td>
<td>年份值</td>
</tr>
<tr>
<td><strong>DETETIME</strong></td>
<td>8</td>
<td>1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4</td>
<td>1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td>
<td>YYYYMMDD HHMMSS</td>
<td>混合日期和时间值，时间戳</td>
</tr>
</tbody></table>
<h4 id="9-1-3-字符串类型"><a href="#9-1-3-字符串类型" class="headerlink" title="9.1.3 字符串类型"></a>9.1.3 字符串类型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR</td>
<td>0-255 bytes</td>
<td>定长字符串</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>0-65535 bytes</td>
<td>变长字符串</td>
</tr>
<tr>
<td>BLOB（binary large object）</td>
<td>0-65 535 bytes</td>
<td>二进制形式的长文本数据</td>
</tr>
<tr>
<td>TEXT</td>
<td>0-65 535 bytes</td>
<td>长文本数据</td>
</tr>
</tbody></table>
<ul>
<li><font color="orange">CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同，CHAR(N)会将多余的存储位以空格补足，而VARCHAR(N)则会根据实际存储长度进行“压缩”。在存储或检索过程中不进行大小写转换。</font></li>
<li><font color="orange">BLOB是一个二进制大对象，可以容纳可变数量的数据。有4种BLOB类型：TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。它们只是可容纳值的最大长度不同。</font></li>
</ul>
<h3 id="9-2-数据表的创建（CREATE）"><a href="#9-2-数据表的创建（CREATE）" class="headerlink" title="9.2 数据表的创建（CREATE）"></a>9.2 数据表的创建（CREATE）</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    列名 数据类型 [约束],</span><br><span class="line">    列名 数据类型 [约束],</span><br><span class="line">    ......</span><br><span class="line">    列名 数据类型 [约束]#最后一行的末尾不加逗号</span><br><span class="line">)[CHARSET=UTF8]#可根据需要指定表的字符编码集</span><br></pre></td></tr></tbody></table></figure>

<p>括号内的内容为可选。</p>
<h4 id="9-2-1-创建表"><a href="#9-2-1-创建表" class="headerlink" title="9.2.1 创建表"></a>9.2.1 创建表</h4><table>
<thead>
<tr>
<th>列名</th>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>subject_id</td>
<td>INT</td>
<td>课程编号</td>
</tr>
<tr>
<td>subject_name</td>
<td>VARCHAR(20)</td>
<td>课程时间</td>
</tr>
<tr>
<td>subject_hours</td>
<td>INT</td>
<td>课程课长</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#根据上述表格创建数据库，并向表中插入3条测试语句</span><br><span class="line">CREATE TABLE `t_subject` (</span><br><span class="line">  `subject_id` int,</span><br><span class="line">  `subject_name` varchar(20),</span><br><span class="line">  `subject_hours` int(11)</span><br><span class="line">)CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO t_subject(subject_id,subject_name,subject_hours) </span><br><span class="line">VALUES(1,'JAVA',40);</span><br><span class="line">INSERT INTO t_subject(subject_id,subject_name,subject_hours) </span><br><span class="line">VALUES(2,'MYSQL',30);</span><br><span class="line">INSERT INTO t_subject(subject_id,subject_name,subject_hours) VALUES(3,'JAVASCRIPT',20)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="9-3-数据表的修改（ALTER）"><a href="#9-3-数据表的修改（ALTER）" class="headerlink" title="9.3 数据表的修改（ALTER）"></a>9.3 数据表的修改（ALTER）</h3><blockquote>
<p><strong>语法</strong>：<code>ALTER TABLE 表名 操作;</code></p>
</blockquote>
<h4 id="9-3-1-向现有表中添加列"><a href="#9-3-1-向现有表中添加列" class="headerlink" title="9.3.1 向现有表中添加列"></a>9.3.1 向现有表中添加列</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#在课程表基础上添加grade_id列</span><br><span class="line">ALTER TABLE t_subject ADD grade_id INT;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="9-3-2-修改表中的列"><a href="#9-3-2-修改表中的列" class="headerlink" title="9.3.2 修改表中的列"></a>9.3.2 修改表中的列</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#修改课程表中的课程名称长度为10个字符</span><br><span class="line">ALTER TABLE t_subject MODIFY subject_name VARCHAR(10);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>注意</strong>：<strong>修改表中的某列时</strong>，<strong>也要写全列的名字</strong>，<strong>数据类型</strong>，<strong>约束</strong>。</li>
</ul>
<h4 id="9-3-3-删除表中的列"><a href="#9-3-3-删除表中的列" class="headerlink" title="9.3.3 删除表中的列"></a>9.3.3 删除表中的列</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#删除课程表中grade_id列</span><br><span class="line">ALTER TABLE t_subject DROP grade_id;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>注意</strong>：<strong>删除列时</strong>，<strong>每次只能删一列</strong>。</li>
</ul>
<h4 id="9-3-4-修改列名"><a href="#9-3-4-修改列名" class="headerlink" title="9.3.4 修改列名"></a>9.3.4 修改列名</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#修改课程表中subject_hours列为class_hours</span><br><span class="line">ALTER TABLE t_subject CHANGE subject_hours class_hours INT;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>注意</strong>：<strong>修改列名时</strong>，<strong>在给定列新名称时</strong>，<strong>要指定列的类型和约束</strong>。</li>
</ul>
<h4 id="9-3-5-修改表名"><a href="#9-3-5-修改表名" class="headerlink" title="9.3.5 修改表名"></a>9.3.5 修改表名</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#修改课程表的t_subject为t_sub</span><br><span class="line">ALTER TABLE t_subject RENAME t_sub;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="9-4-数据表的删除（DROP）"><a href="#9-4-数据表的删除（DROP）" class="headerlink" title="9.4 数据表的删除（DROP）"></a>9.4 数据表的删除（DROP）</h3><blockquote>
<p> <strong>语法</strong>：<code>DROP TABLE 表名</code></p>
</blockquote>
<h4 id="9-4-1-删除课程表"><a href="#9-4-1-删除课程表" class="headerlink" title="9.4.1 删除课程表"></a>9.4.1 删除课程表</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#删除课程表</span><br><span class="line">DROP TABLE t_sub;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="十、约束"><a href="#十、约束" class="headerlink" title="十、约束"></a>十、约束</h2><blockquote>
<p> 问题：在往已创建表中新增数据时，可不可以新增两行相同列的数据？如果可行，会有什么弊端？</p>
</blockquote>
<p>这是可以的，但重复的数据不仅会浪费空间，而且对查询结果不利，也是多余的。在实际的存储中应尽量保证每条数据的唯一性。</p>
<h3 id="10-1-实体完整性约束"><a href="#10-1-实体完整性约束" class="headerlink" title="10.1 实体完整性约束"></a>10.1 实体完整性约束</h3><blockquote>
<p> 表中的一行数据代表一个实体（entity），实体完整性的作用即是标识每一行数据不重复，实体唯一。</p>
</blockquote>
<h4 id="10-1-1-主键约束"><a href="#10-1-1-主键约束" class="headerlink" title="10.1.1 主键约束"></a>10.1.1 主键约束</h4><blockquote>
<p><strong>关键词</strong>：<code>PRIMARY KEY</code>唯一，标识表中的一行数据，此列的值不可重复，且<strong>不能</strong>为NULL。</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#为表中适用主键的列添加主键约束</span><br><span class="line">CREATE TABLE t_subject(</span><br><span class="line">#课程标号标识了每一个课程的编号唯一，且不能为NULL</span><br><span class="line">subject_id INT PRIMARY KEY,</span><br><span class="line">subject_name VARCHAR(20),</span><br><span class="line">subject_hours INT</span><br><span class="line">)CHARSET=utf8;</span><br><span class="line">INSERT INTO t_subject(subject_id,subject_name,subject_hours) VALUES(1,'JAVA',40);</span><br><span class="line">#报错，主键subject_id不可重复</span><br><span class="line">INSERT INTO t_subject(subject_id,subject_name,subject_hours) VALUES(1,'JAVA',40);</span><br></pre></td></tr></tbody></table></figure>

<p>作为主键的字段一般都是也应该是编号、学号、工号等字段。</p>
<h4 id="10-1-2-唯一约束"><a href="#10-1-2-唯一约束" class="headerlink" title="10.1.2 唯一约束"></a>10.1.2 唯一约束</h4><blockquote>
<p> <strong>关键字</strong>：<code>UNIQUE</code>唯一，标识表中的一行数据，不可重复，<strong>可以</strong>为NULL。</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#为表中列值不允许重复的列添加唯一约束</span><br><span class="line">ALTER TABLE t_subject MODIFY subject_name VARCHAR(20) UNIQUE;</span><br><span class="line"></span><br><span class="line">INSERT INTO t_subject(subject_id,subject_name,subject_hours) VALUES(1,'JAVA',40);</span><br><span class="line">#报错，课程名已存在</span><br><span class="line">INSERT INTO t_subject(subject_id,subject_name,subject_hours) VALUES(2,'JAVA',40);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="10-1-3-自动增长列"><a href="#10-1-3-自动增长列" class="headerlink" title="10.1.3 自动增长列"></a>10.1.3 自动增长列</h4><blockquote>
<p> 关键字：<code>AUTO_INCREAMENT</code>自动增长，给<strong>主键数值列</strong>添加自动增长。从1开始，每次加1。不能单独使用，和主键配合。</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#为表中主键列添加自动增长，避免忘记主键ID序号</span><br><span class="line">ALTER TABLE t_subject MODIFY subject_id INT AUTO_INCREMENT;</span><br><span class="line">#课程ID自动增长为2</span><br><span class="line">INSERT INTO t_subject ( subject_name, subject_hours ) VALUES( 'HTML5', 40 );</span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-2-域完整性约束"><a href="#10-2-域完整性约束" class="headerlink" title="10.2 域完整性约束"></a>10.2 域完整性约束</h3><blockquote>
<p> 该约束限制单元格的数据正确性。</p>
</blockquote>
<h4 id="10-2-1-非空约束"><a href="#10-2-1-非空约束" class="headerlink" title="10.2.1 非空约束"></a>10.2.1 非空约束</h4><blockquote>
<p> 语法：<code>NOT NULL</code>,非空，此列必须有值</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#课程名称虽然添加了唯一约束，但是有NULL值存在的可能，要避免课程名称为NULL。</span><br><span class="line">ALTER TABLE t_subject MODIFY subject_name VARCHAR(20) NOT NULL;</span><br><span class="line">#报错，课程名不能为空</span><br><span class="line">INSERT INTO t_subject(subject_name,subject_hours) VALUES (NULL,40);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="10-2-2-默认值约束"><a href="#10-2-2-默认值约束" class="headerlink" title="10.2.2 默认值约束"></a>10.2.2 默认值约束</h4><blockquote>
<p> <strong>关键字</strong>：<code>DEFAULT 值</code>。为列赋予默认值，当新增数据不指定值时，书写DEFAULT，以指定的默认值进行填充。</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#当存储课程信息时，若课程时长没有指定值，则以默认值进行填充</span><br><span class="line">ALTER TABLE t_subject MODIFY subject_hours INT DEFAULT 40;</span><br><span class="line">#不写默认课程时为40，也可以把值写成DEFAULT</span><br><span class="line">INSERT INTO t_subject(subject_name) VALUES('JAVAWEB');</span><br></pre></td></tr></tbody></table></figure>

<h4 id="10-2-3-引用完整性约束"><a href="#10-2-3-引用完整性约束" class="headerlink" title="10.2.3 引用完整性约束"></a>10.2.3 引用完整性约束</h4><blockquote>
<p><strong>语法</strong>：<code>CONSTRAINT 引用名 FOREIGN KEY (列名) REFERENCES 被引用表名(列名)</code></p>
</blockquote>
<blockquote>
<p> <strong>解释</strong>：FOREIGN KEY<strong>引用外部表某个列的值</strong>，新增数据时，约束此列的值<strong>必须是引用表中存在的值</strong>。</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#创建专业表</span><br><span class="line">CREATE TABLE t_speciality(</span><br><span class="line">	special_id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	special_name VARCHAR(20) UNIQUE NOT NULL</span><br><span class="line">)CHARSET=utf8;</span><br><span class="line">#添加一些专业信息</span><br><span class="line">INSERT INTO t_speciality(special_name) VALUES('HTML5');</span><br><span class="line">INSERT INTO t_speciality(special_name) VALUES('JAVA');</span><br><span class="line">INSERT INTO t_speciality(special_name) VALUES('JAVAWEB');</span><br><span class="line">INSERT INTO t_speciality(special_name) VALUES('数据结构');</span><br><span class="line">#subject_id引用special_id</span><br><span class="line">ALTER TABLE t_subject ADD </span><br><span class="line">CONSTRAINT fk_subject_spacial FOREIGN KEY(special_id) REFERENCES t_speciality(special_id);</span><br><span class="line">#添加数据成功</span><br><span class="line">INSERT INTO t_subject(subject_name,special_id) VALUES('数据结构',4);</span><br><span class="line">#添加失败，主表中不存在5</span><br><span class="line">INSERT INTO t_subject(subject_name,special_id) VALUES('操作系统',5);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>注意</strong>：<strong>当两张表存在引用关系时</strong>，<strong>要执行删除操作</strong>，<strong>一定要先删除从表</strong>（<strong>引用表</strong>），<strong>再删除主表</strong>（<strong>被引用表</strong>）。</li>
</ul>
<h3 id="10-3-约束创建整合"><a href="#10-3-约束创建整合" class="headerlink" title="10.3 约束创建整合"></a>10.3 约束创建整合</h3><p>创建带有约束的表。</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>数据类型</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>grade_id</td>
<td>INT</td>
<td>主键、自动增长</td>
<td>班级编号</td>
</tr>
<tr>
<td>grade_name</td>
<td>VARCHAR(20)</td>
<td>唯一、非空</td>
<td>班级名称</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CREATE TABLE t_grade(</span><br><span class="line">	grade_id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	grade_name VARCHAR(20) UNIQUE NOT NULL</span><br><span class="line">)CHARSET=utf8;</span><br></pre></td></tr></tbody></table></figure>

<table>
<thead>
<tr>
<th>列名</th>
<th>数据类型</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>student_id</td>
<td>VARCHAR(20)</td>
<td>主键</td>
<td>学号</td>
</tr>
<tr>
<td>student_name</td>
<td>VARCHAR(20)</td>
<td>非空</td>
<td>姓名</td>
</tr>
<tr>
<td>sex</td>
<td>CHAR(2)</td>
<td>默认填充“男”</td>
<td>性别</td>
</tr>
<tr>
<td>born_date</td>
<td>DATE</td>
<td>非空</td>
<td>生日</td>
</tr>
<tr>
<td>phone</td>
<td>VARCHAR(11)</td>
<td>无</td>
<td>电脑</td>
</tr>
<tr>
<td>grade_id</td>
<td>INT</td>
<td>非空、外键约束引用班级表的grade_id</td>
<td>班级编号</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CREATE TABLE t_student(</span><br><span class="line">	student_id VARCHAR(20) PRIMARY KEY,</span><br><span class="line">	student_name VARCHAR(20) NOT NULL,</span><br><span class="line">	sex CHAR(2) DEFAULT '男',</span><br><span class="line">	born_date DATE NOT NULL,</span><br><span class="line">	phone VARCHAR(11),</span><br><span class="line">	grade_id INT NOT NULL,</span><br><span class="line">	CONSTRAINT fk_student_grade FOREIGN KEY (grade_id) REFERENCES t_grade(grade_id)</span><br><span class="line">)CHARSET=utf8;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>注意</strong>：<strong>创建关系表时</strong>，<strong>一定要先创建主键</strong>，<strong>再创建从表</strong>。</li>
<li><strong>删除关系表时</strong>，<strong>先删除从表</strong>，<strong>再删除主表</strong>。</li>
</ul>
<h2 id="十一、事务【重点】"><a href="#十一、事务【重点】" class="headerlink" title="十一、事务【重点】"></a>十一、事务【重点】</h2><h3 id="11-1-模拟转账"><a href="#11-1-模拟转账" class="headerlink" title="11.1 模拟转账"></a>11.1 模拟转账</h3><blockquote>
<p> 生活当中转账是转账方账户扣钱，收账方账户加钱。我们用数据库操作来模拟实现转账。</p>
</blockquote>
<h4 id="11-1-1-数据库模拟转账"><a href="#11-1-1-数据库模拟转账" class="headerlink" title="11.1.1 数据库模拟转账"></a>11.1.1 数据库模拟转账</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#A账户转账给B账户1000元</span><br><span class="line">#B账户减1000元</span><br><span class="line"></span><br><span class="line">#新建账户表</span><br><span class="line">CREATE TABLE t_account(</span><br><span class="line">	account_id INT PRIMARY KEY,</span><br><span class="line">	money INT</span><br><span class="line">)CHARSET=utf8;</span><br><span class="line">#插入数据</span><br><span class="line">INSERT INTO t_account(account_id,money) VALUES(1,5000);</span><br><span class="line">INSERT INTO t_account(account_id,money) VALUES(2,5000);</span><br><span class="line">#模拟转账</span><br><span class="line">UPDATE t_account SET money=money-1000 WHERE account_id=1;#转账</span><br><span class="line">UPDATE t_account SET money=money+1000 WHERE account_id=2;#收账</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>上述代码完成了两个账户之间转账的操作</strong>。</li>
</ul>
<h3 id="11-1-2-模拟转账错误"><a href="#11-1-2-模拟转账错误" class="headerlink" title="11.1.2 模拟转账错误"></a>11.1.2 模拟转账错误</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">UPDATE t_account SET money=money-1000 WHERE account_id=1;#转账</span><br><span class="line">#断电，异常，出错...</span><br><span class="line">UPDATE t_account SET money=money+1000 WHERE account_id=2;#收账</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>上述代码在减操作后过程中出现了异常或加钱语句出错</strong>，<strong>会发现减钱成功了而加钱失败了</strong>！</li>
<li><strong>注意</strong>：<strong>每条SQL语句都是一个独立的操作</strong>，<strong>一个操作执行完对数据库是永久性的影响</strong>。</li>
</ul>
<h3 id="11-2-事务的概念"><a href="#11-2-事务的概念" class="headerlink" title="11.2 事务的概念"></a>11.2 事务的概念</h3><blockquote>
<p> 事务是一个原子操作，是一个做小执行单元。可以由一个或多个SQL语句组成，在同一个事务当中，所有的SQL语句都成功执行，整个事务成功，有一个SQL语句执行失败，整个事务执行失败。</p>
</blockquote>
<h3 id="11-3-事务的边界"><a href="#11-3-事务的边界" class="headerlink" title="11.3 事务的边界"></a>11.3 事务的边界</h3><ul>
<li>开始：连接到数据库，执行一条DML语句。上一个事务结束后，又输入了一条DML语句，即事务的开始。</li>
<li>结束：<ol>
<li>提交：<ul>
<li>显式提交：COMMIT；</li>
<li>隐式提交：一条创建、删除的语句，正常退出（客户端退出连接）；</li>
</ul>
</li>
<li>回滚：<ul>
<li>显式回滚：ROLLBACK；</li>
<li>隐式回滚：非正常退出（断电、宕机），执行了创建、删除的语句，但是失败了，会为这个无效的语句执行回滚。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>如11.1.2节中的两条语句就是两个事务，第一条语句执行便是事务的开始，分号便是事务的结束，执行完毕该语句就被提交了；而第二句由于执行失败，该语句的结果就是回滚，回到事务前的样子。</p>
<h3 id="11-4-事务的原理"><a href="#11-4-事务的原理" class="headerlink" title="11.4 事务的原理"></a>11.4 事务的原理</h3><blockquote>
<p> 数据库会为每一个客户端都维护一个空间独立的缓存区（回滚段），一个事务中所有的增删改查语句的执行结果都会缓存在回滚段中，只有当事务中所有SQL语句均正常结束（COMMIT），才会将回滚段中的数据同步到数据库。否则无论因为哪种原因失败，整个事务将回滚（ROLLBACK）。</p>
</blockquote>
<h3 id="11-5-事务的特性（ACID）"><a href="#11-5-事务的特性（ACID）" class="headerlink" title="11.5 事务的特性（ACID）"></a>11.5 事务的特性（ACID）</h3><ul>
<li><p><strong>Atomicity</strong>（<strong>原子性</strong>）</p>
<p>表示一个事务内的所有操作是一个整体，要么全部成功，要么全部失败。</p>
</li>
<li><p><strong>Consistency</strong>（<strong>一致性</strong>）</p>
<p>表示一个事务内有一个操作失败时，所有更改过的数据都必须回滚到修改前状态。</p>
</li>
<li><p><strong>Isolation</strong>（<strong>隔离性</strong>）</p>
<p>事务查看数据库操作时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事物修改它之后的状态，事务不会查看中间状态的数据。</p>
</li>
<li><p><strong>Durability</strong>（<strong>持久性</strong>）</p>
<p>持久性事务完成之后，它对与系统的影响是永久性的。</p>
</li>
</ul>
<h3 id="11-6-事务应用"><a href="#11-6-事务应用" class="headerlink" title="11.6 事务应用"></a>11.6 事务应用</h3><p>应用环境：基于增删改查语句的操作结果（均返回操作后受影响的行数），可通过程序逻辑手动控制事务提交或回滚。</p>
<h4 id="11-6-1-事务完成转账"><a href="#11-6-1-事务完成转账" class="headerlink" title="11.6.1 事务完成转账"></a>11.6.1 事务完成转账</h4><p>手动开启事务，将两个减钱和加钱的操作放到事务中，操作完之后再提交。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#开启事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line">#执行减钱操作（两个账户初始钱都为5000）</span><br><span class="line">UPDATE t_account SET money=money-1000 WHERE account_id = 1;</span><br><span class="line">#执行加钱操作</span><br><span class="line">UPDATE t_account SET money=money+1000 WHERE account_id = 2;</span><br><span class="line">#查看该事务中账户数据</span><br><span class="line">SELECT * FROM t_account;</span><br></pre></td></tr></tbody></table></figure>

<p>以上SQL语句开启了事务，但并未进行提交，此时查看账户中的数据如下：</p>
<table>
<thead>
<tr>
<th>account_id</th>
<th>money</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>4000</td>
</tr>
<tr>
<td>2</td>
<td>6000</td>
</tr>
</tbody></table>
<p>发现数据<strong>已经变了</strong>，但该数据只是事务的中间状态。</p>
<p>然后在你的数据库管理系统中<strong>新建</strong>一个连接，新建连接名随便取一个，然后新建查询。这么做相当于模拟了另外一个客户端：</p>
<p>执行<code>SELECT * FROM t_account</code>;，发现表中的数据并<strong>没有改变</strong>：</p>
<table>
<thead>
<tr>
<th>account_id</th>
<th>money</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>5000</td>
</tr>
<tr>
<td>2</td>
<td>5000</td>
</tr>
</tbody></table>
<p>这是因为在第一个连接中开启了事务，但没有提交；而在another连接中，查询语句也是一个事务（没有显式开启和显式提交），该事务只能查看其它事务修改前后者修改后的状态，此处就是只能查看转账操作提交前的状态，两个账户都是5000，这也是事务的<strong>隔离性</strong>。</p>
<p>回到localhost连接中，提交事务；然后在another连接中再查询一次：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#localhost连接，提交事务</span><br><span class="line">COMMIT;</span><br><span class="line">#another连接，查询表</span><br><span class="line">SELECT * FROM t_account;</span><br></pre></td></tr></tbody></table></figure>

<p>此时的查询结果如下：</p>
<table>
<thead>
<tr>
<th>account_id</th>
<th>money</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>4000</td>
</tr>
<tr>
<td>2</td>
<td>6000</td>
</tr>
</tbody></table>
<p>发现数据已经正式修改完毕。</p>
<p>回滚操作类似，但它是取消掉事务的操作，回到事务前的状态。比如事务开启后，减钱成功，但是加钱失败了（可以用SQL语句某个单词写错来模拟），然后手动执行<code>ROLLBACK</code>，减钱操作就会被撤销。不再演示。</p>
<ul>
<li>此处的演示是手动进行了事物的开启和提交/回滚，在写程序时，这些操作都会在程序中进行控制。</li>
</ul>
<h2 id="十二、权限管理"><a href="#十二、权限管理" class="headerlink" title="十二、权限管理"></a>十二、权限管理</h2><h3 id="12-1-创建用户"><a href="#12-1-创建用户" class="headerlink" title="12.1 创建用户"></a>12.1 创建用户</h3><blockquote>
<p> <strong>语法</strong>：<code>CREATE USER 用户名 IDENTIFIED BY 密码</code></p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#创建一个用户</span><br><span class="line">CREATE USER 'client1' IDENTIFIED BY '123456';</span><br></pre></td></tr></tbody></table></figure>

<p>接下来验证用户是否添加成功，首先新建连接，在用户名和账号那里写上自己创建的用户和密码，测试一下是否连接成功。</p>
<p>然后点“确定”。但是打开该连接之后你会发现此连接中除了一个系统数据库，其他数据库<strong>都不存在</strong>。这是因为client1用户建立的连接没有得到任何授权，也就是没有对数据库的访问操作权限。</p>
<h3 id="12-2-授权"><a href="#12-2-授权" class="headerlink" title="12.2 授权"></a>12.2 授权</h3><blockquote>
<p> <strong>语法</strong>：<code>GRANT ALL ON 数据库.表 TO 用户名;</code></p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#将companydb下的所有表的权限都赋给client</span><br><span class="line">GRANT ALL ON companydb.* TO client1;</span><br></pre></td></tr></tbody></table></figure>

<p>该语句需要在root连接中执行，不能在client1连接中自己给自己授权。</p>
<h3 id="12-3-撤销权限"><a href="#12-3-撤销权限" class="headerlink" title="12.3 撤销权限"></a>12.3 撤销权限</h3><blockquote>
<p> <strong>语法</strong>：<code>REVOKE ALL ON 数据库.表名 FROM 用户名</code></p>
</blockquote>
<ul>
<li><strong>注意</strong>：<strong>撤销权限后</strong>，<strong>账户需要重新连接客户端才会生效</strong>。</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#将client1的companydb的操作权限撤销</span><br><span class="line">GRANT ALL ON companydb.* TO client1;</span><br></pre></td></tr></tbody></table></figure>

<p>虽然刷新之后表不见了，但是依然可以对表进行操作，只有在重新连接数据库的时候权限才会消失。</p>
<h3 id="12-4-删除用户"><a href="#12-4-删除用户" class="headerlink" title="12.4 删除用户"></a>12.4 删除用户</h3><blockquote>
<p> <strong>语法</strong>：<code>DROP USER 用户名</code></p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#删除用户client1</span><br><span class="line">DROP USER 'client1';</span><br></pre></td></tr></tbody></table></figure>

<h2 id="十三、视图"><a href="#十三、视图" class="headerlink" title="十三、视图"></a>十三、视图</h2><h3 id="13-1-概念"><a href="#13-1-概念" class="headerlink" title="13.1 概念"></a>13.1 概念</h3><blockquote>
<p> 视图，虚拟表，从一个表或多个表中查询出来的表，作用和真实表一样，包含一系列带有行和列的数据。视图表中，用户可以使用SELECT语句查询数据，也可以使用INSERT、UPDATE、DELETE修改记录，视图可以使用户操作方便，并保障数据库系统安全。</p>
</blockquote>
<ul>
<li>和临时表很像，但临时表不会被保存，而视图是保存下来的表。</li>
</ul>
<h3 id="13-2-视图特点"><a href="#13-2-视图特点" class="headerlink" title="13.2 视图特点"></a>13.2 视图特点</h3><ul>
<li>优点<ul>
<li>简单化，数据所见即所得。</li>
<li>安全性，用户只能查询或修改他们所能见到的数据。</li>
<li>逻辑独立性，可以屏蔽真实表结构变化带来的影响。</li>
</ul>
</li>
<li>缺点<ul>
<li>性能相对较差，简单的查询也会变得稍显复杂。</li>
<li>修改不方便，特别是复杂的聚合视图基本无法修改。</li>
</ul>
</li>
</ul>
<h3 id="13-3-视图的创建"><a href="#13-3-视图的创建" class="headerlink" title="13.3 视图的创建"></a>13.3 视图的创建</h3><blockquote>
<p> <strong>语法</strong>：<code>CREATE VIEW 视图名 AS 查询数据源表结构语句;</code></p>
</blockquote>
<h3 id="13-3-1-创建视图"><a href="#13-3-1-创建视图" class="headerlink" title="13.3.1 创建视图"></a>13.3.1 创建视图</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#创建t_emp_info的视图，其视图从t_employees表中查询员工编号、姓名、邮箱、工资</span><br><span class="line">CREATE VIEW t_emp_info</span><br><span class="line">AS</span><br><span class="line">SELECT EMPLOYEE_ID,FIRST_NAME,EMAIL,SALARY FROM t_employees;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="13-3-2-使用视图"><a href="#13-3-2-使用视图" class="headerlink" title="13.3.2 使用视图"></a>13.3.2 使用视图</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#查询t_emp_info视图中编号为036的员工信息</span><br><span class="line">SELECT * FROM t_emp_info WHERE EMPLOYEE_ID = 036;</span><br></pre></td></tr></tbody></table></figure>

<p>使用视图可以简化查询的操作，将来视图应用最多的地方也是查询。</p>
<h3 id="13-4-视图的修改"><a href="#13-4-视图的修改" class="headerlink" title="13.4 视图的修改"></a>13.4 视图的修改</h3><blockquote>
<ul>
<li>方式一：<code>CREATE OR REPLACE VIEW 视图名 AS 查询语句</code></li>
<li>方式二：<code>ALTER VIEW 视图名 AS 查询语句</code></li>
</ul>
</blockquote>
<p>方式一是在不明确视图是否存在时使用，如果存在则修改，否则创建；方式二是明确存在时进行修改。无论哪种方式都需要拼接一个完整查询语句。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#方式一，如果视图存在则修改，反之创建。</span><br><span class="line">CREATE OR REPLACE VIEW t_emp_info</span><br><span class="line">AS</span><br><span class="line">SELECT EMPLOYEE_ID,FIRST_NAME,EMAIL,SALARY,JOB_ID FROM t_employees;</span><br><span class="line">#方式二，对已存在的视图进行修改</span><br><span class="line">ALTER VIEW t_emp_info</span><br><span class="line">AS</span><br><span class="line">SELECT EMPLOYEE_ID,FIRST_NAME,EMAIL,SALARY FROM t_employees;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="13-5-视图的删除"><a href="#13-5-视图的删除" class="headerlink" title="13.5 视图的删除"></a>13.5 视图的删除</h3><blockquote>
<p> <strong>语法</strong>：<code>DROP VIEW 视图名</code></p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#删除视图</span><br><span class="line">DROP VIEW t_emp_info;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>注意</strong>：<strong>删除视图不会影响原表</strong>。</li>
</ul>
<h3 id="13-6-视图的注意事项"><a href="#13-6-视图的注意事项" class="headerlink" title="13.6 视图的注意事项"></a>13.6 视图的注意事项</h3><ul>
<li>视图不会独立存储数据，原表发生改变，视图也发生改变。没有优化任何查询性能。</li>
<li>如果视图包含以下结构中的一种，则视图不可更新：<ul>
<li>聚合函数的结果</li>
<li>DISTINCT去重后的结果</li>
<li>GROUP BY分组后的结果</li>
<li>HAVING筛选过滤后的结果</li>
<li>UNION、UNION ALL联合后的结果</li>
</ul>
</li>
</ul>
<h2 id="十四、SQL语言分类"><a href="#十四、SQL语言分类" class="headerlink" title="十四、SQL语言分类"></a>十四、SQL语言分类</h2><ol>
<li><strong>数据查询语言</strong>DQL（Data Query Language）：SELECT、WHERE、ORDER BY、GROUP BY、HAVING；</li>
<li><strong>数据定义语言</strong>DDL（Data Definition Language）：CREATE、ALTER、DROP；</li>
<li><strong>数据操作语言</strong>DML（Data Manipulation Language）：INSERT、UNPATE、DELETE；</li>
<li><strong>事务处理语言</strong>TPL（Transaction Process Language）：COMMIT、ROLLBACK；</li>
<li><strong>数据控制语言</strong>DCL（Data Control Language）：GRANT、REVOKE。</li>
</ol>
<h2 id="十五、综合练习"><a href="#十五、综合练习" class="headerlink" title="十五、综合练习"></a>十五、综合练习</h2><p>某网上购物商城数据库表的结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 创建用户表</span><br><span class="line">CREATE TABLE USER(</span><br><span class="line">	userId INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	username VARCHAR(20) NOT NULL,</span><br><span class="line">	PASSWORD VARCHAR(18) NOT NULL,</span><br><span class="line">	address VARCHAR(100),</span><br><span class="line">	phone VARCHAR(11)</span><br><span class="line">);</span><br><span class="line">SELECT * FROM USER;</span><br><span class="line">INSERT INTO USER(username, PASSWORD, address,phone) VALUES('张三','123','北京昌平','13541489201');</span><br><span class="line">INSERT INTO USER(username, PASSWORD, address,phone) VALUES('李四','678','北京海定','13541489202');</span><br><span class="line">INSERT INTO USER(username, PASSWORD, address,phone) VALUES('王五','123','北京朝阳','13541489203');</span><br><span class="line">INSERT INTO USER(username, PASSWORD, address,phone) VALUES('赵柳','123','北京大兴','13541489204');</span><br><span class="line"># 创建分类表</span><br><span class="line">CREATE TABLE category(</span><br><span class="line">	cid VARCHAR(32) PRIMARY KEY,</span><br><span class="line">	cname VARCHAR(100) NOT NULL  # 分类名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO category VALUES('c001','电器');</span><br><span class="line">INSERT INTO category VALUES('c002','服饰');</span><br><span class="line">INSERT INTO category VALUES('c003','化妆品');</span><br><span class="line">INSERT INTO category VALUES('c004','书籍');</span><br><span class="line"></span><br><span class="line"># 商品表</span><br><span class="line">CREATE TABLE `products`(</span><br><span class="line">	`pid` VARCHAR(32) PRIMARY KEY,</span><br><span class="line">	`name` VARCHAR(40),</span><br><span class="line">	`price` DOUBLE(7,2),</span><br><span class="line">	category_id VARCHAR(32),</span><br><span class="line">	CONSTRAINT fk_products_category_id FOREIGN KEY (category_id) REFERENCES category(cid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO products(pid, NAME, price, category_id) VALUES('p001','联想',5000,'c001');</span><br><span class="line">INSERT INTO products(pid, NAME, price, category_id) VALUES('p002','海尔',3000,'c001');</span><br><span class="line">INSERT INTO products(pid, NAME, price, category_id) VALUES('p003','雷神',5000,'c001');</span><br><span class="line">INSERT INTO products(pid, NAME, price, category_id) VALUES('p004','JACK',800,'c001');</span><br><span class="line">INSERT INTO products(pid, NAME, price, category_id) VALUES('p005','真维斯',200,'c002');</span><br><span class="line">INSERT INTO products(pid, NAME, price, category_id) VALUES('p006','花花公子',440,'c002');</span><br><span class="line">INSERT INTO products(pid, NAME, price, category_id) VALUES('p007','劲霸',2000,'c002');</span><br><span class="line">INSERT INTO products(pid, NAME, price, category_id) VALUES('p008','香奈儿',800,'c003');</span><br><span class="line">INSERT INTO products(pid, NAME, price, category_id) VALUES('p009','相宜本草 ',200,'c003');</span><br><span class="line">INSERT INTO products(pid, NAME, price, category_id) VALUES('p0010','梅明子',200,NULL);</span><br><span class="line"># 订单表</span><br><span class="line">CREATE TABLE `orders` (</span><br><span class="line">	`oid` VARCHAR(32) PRIMARY KEY,</span><br><span class="line">	`totalprice` DOUBLE(12,2), # 总计</span><br><span class="line">	`userId` INT,</span><br><span class="line">	CONSTRAINT fk_orders_userId FOREIGN KEY(userId) REFERENCES USER(userId) # 外键</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO orders VALUES('o6100',18000.50,1);</span><br><span class="line">INSERT INTO orders VALUES('o6101',7200.35,1);</span><br><span class="line">INSERT INTO orders VALUES('o6102',600.00,2);</span><br><span class="line">INSERT INTO orders VALUES('o6103',1300.26,4);</span><br><span class="line">SELECT * FROM orders;</span><br><span class="line"># 订单详情表</span><br><span class="line">CREATE TABLE orderitem(</span><br><span class="line">	oid VARCHAR(32), # 订单id</span><br><span class="line">	pid VARCHAR(32), # 商品id</span><br><span class="line">	num INT, # 购买商品数量</span><br><span class="line">	PRIMARY KEY(oid, pid), # 主键</span><br><span class="line">	CONSTRAINT fk_orderitem_oid FOREIGN KEY(oid) REFERENCES orders(oid),</span><br><span class="line">	CONSTRAINT fk_orderitem_pid FOREIGN KEY(pid) REFERENCES products(pid)</span><br><span class="line">);</span><br><span class="line"># 订单详情表添加信息</span><br><span class="line">INSERT INTO orderitem VALUES('o6100','p001',1),('o6100','p002',1),('o6101','p003',1);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="15-1-综合练习1-【多表查询】"><a href="#15-1-综合练习1-【多表查询】" class="headerlink" title="15.1 综合练习1-【多表查询】"></a>15.1 综合练习1-【多表查询】</h3><ol>
<li><p>查询所有用户的订单</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 查询所有用户的订单</span><br><span class="line"># 用户	订单表</span><br><span class="line">SELECT * FROM USER INNER JOIN orders ON orders.`userId` = user.`userId`;</span><br></pre></td></tr></tbody></table></figure>



</li>
</ol>
<ol start="2">
<li><p>查询用户id为1的所有订单详情</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 查询用户id为1的所有订单详情</span><br><span class="line"># 用户	 订单 	订单详情表</span><br><span class="line">SELECT * FROM USER</span><br><span class="line">INNER JOIN orders</span><br><span class="line">ON orders.`userId` = user.`userId`</span><br><span class="line">INNER JOIN orderitem</span><br><span class="line">ON orders.`oid` = orderitem.`oid`</span><br><span class="line">WHERE user.`userId` = 1;</span><br></pre></td></tr></tbody></table></figure>



</li>
</ol>
<h3 id="15-2-综合练习2-【子查询】"><a href="#15-2-综合练习2-【子查询】" class="headerlink" title="15.2  综合练习2-【子查询】"></a>15.2  综合练习2-【子查询】</h3><ol>
<li><p>查看用户为张三的订单</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 查看用户为张三的订单</span><br><span class="line"># 子查询单行单列</span><br><span class="line">SELECT userId FROM USER WHERE username='张三';</span><br><span class="line">SELECT * FROM orders WHERE userId=(SELECT userId FROM USER WHERE username='张三');</span><br></pre></td></tr></tbody></table></figure>



</li>
</ol>
<ol start="2">
<li><p>查询出订单的价格大于800的所有用户的信息</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 查询出订单的价格大于800的所有用户的信息</span><br><span class="line"># 子查询	多行单列	枚举查询</span><br><span class="line">SELECT DISTINCT userId FROM orders WHERE totalprice &gt; 800;</span><br><span class="line">SELECT * FROM USER WHERE userId IN (SELECT DISTINCT userId FROM orders WHERE totalprice &gt; 800);</span><br></pre></td></tr></tbody></table></figure>



</li>
</ol>
<h3 id="15-3-综合练习3-【分页查询】"><a href="#15-3-综合练习3-【分页查询】" class="headerlink" title="15.3  综合练习3-【分页查询】"></a>15.3  综合练习3-【分页查询】</h3><ol>
<li><p>查询所有订单信息，每页显示5条数据</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 查询所有订单信息，每页显示5条数据</span><br><span class="line"># 查询第一页</span><br><span class="line">SELECT * FROM orders LIMIT 0, 5;</span><br><span class="line"># 查询第二页</span><br><span class="line">SELECT * FROM orders LIMIT 5, 5;</span><br></pre></td></tr></tbody></table></figure>





</li>
</ol>
<h2 id="至此，MySql的基础学习已经告一段落，继续加油吧，在计算机这篇星辰大海中继续遨游。！"><a href="#至此，MySql的基础学习已经告一段落，继续加油吧，在计算机这篇星辰大海中继续遨游。！" class="headerlink" title="至此，MySql的基础学习已经告一段落，继续加油吧，在计算机这篇星辰大海中继续遨游。！"></a>至此，MySql的基础学习已经告一段落，继续加油吧，在计算机这篇星辰大海中继续遨游。！</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>后端</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MySql</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>设计_面试题.03.01.三合一</title>
    <url>/Three_in_one/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>三合一。描述如何只用一个数组来实现三个栈。</p>
<p>你应该实现push(stackNum, value)、pop(stackNum)、isEmpty(stackNum)、peek(stackNum)方法。stackNum表示栈下标，value表示压入的值。</p>
<p>构造函数会传入一个stackSize参数，代表每个栈的大小。</p>
<p>示例1:</p>
<a id="more"></a>

<p> 输入：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">["TripleInOne", "push", "push", "pop", "pop", "pop", "isEmpty"]</span><br><span class="line">[[1], [0, 1], [0, 2], [0], [0], [0], [0]]</span><br></pre></td></tr></tbody></table></figure>

<p> 输出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[null, null, null, 1, -1, -1, true]</span><br><span class="line">说明：当栈为空时`pop, peek`返回-1，当栈满时`push`不压入元素。</span><br></pre></td></tr></tbody></table></figure>

<p>示例2:</p>
<p> 输入：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">["TripleInOne", "push", "push", "push", "pop", "pop", "pop", "peek"]</span><br><span class="line">[[2], [0, 1], [0, 2], [0, 3], [0], [0], [0], [0]]</span><br><span class="line"> 输出：</span><br><span class="line">[null, null, null, null, 2, 1, -1, -1]</span><br></pre></td></tr></tbody></table></figure>



<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始直接懵逼，看了别人的才懂题意</p>
<ol>
<li><p>首先开始创建类时构造函数里面创入的大小是栈的大小 ( stackSize )</p>
</li>
<li><p>其次不管是push还是pop还是peek或者isEmpty 的参数 (stackNum)</p>
<ul>
<li>stackNum输入的值,代表的是哪个栈!!!!</li>
<li>这个题叫三合一就是说 三个栈代表全部放在一个数组里面</li>
<li>例如: 参数stackNum 为 0 时就代表第一个栈</li>
<li>参数stackNum 为 1 时就代表第二个栈</li>
<li>参数stackNum 为 2 时就代表第三个栈</li>
</ul>
</li>
<li><p>由于是一个数组相当于3个栈,所以创建的时候就 乘 3</p>
</li>
</ol>
<p><img src="https://pic.leetcode-cn.com/1600592347-fAjxIk-image.png" alt=""></p>
<p><img src="https://pic.leetcode-cn.com/1600592358-oHsaSG-image.png" alt=""></p>
<ol start="4">
<li><p>每次push的时候 需要先判断头指针是否小于数组的长度</p>
<ul>
<li>如果小于需要添加值,而且需要把top节点加3</li>
<li>例如: 添加栈0 2, 添加栈0 8, 添加栈0 7</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/1600592511-jiDDdY-image.png" alt=""></p>
<p><img src="https://pic.leetcode-cn.com/1600592610-evbIQM-image.png" alt=""></p>
<p>此时top[0] = 0 减3之后就是 -3 所以它是空的返回-1</p>
</li>
<li><p>每次peek的时候, 先判断是否为空 空直接返回-1, 不为空话就把top – 3 的下标给它就可以了,此时不是抛出所以不需要改变原来的top的值</p>
</li>
</ol>
<p>参考代码： </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TripleInOne</span> </span>{</span><br><span class="line">	<span class="comment">//定义数组栈</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] stack;</span><br><span class="line">	<span class="comment">//定义一个头指针的数组</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] stackTop;</span><br><span class="line">	<span class="comment">//定义栈的长度</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> stackSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TripleInOne</span><span class="params">(<span class="keyword">int</span> stackSize)</span> </span>{</span><br><span class="line">    	<span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line">    	<span class="comment">//初始化三合一的栈</span></span><br><span class="line">    	stack = <span class="keyword">new</span> <span class="keyword">int</span>[stackSize * <span class="number">3</span>];</span><br><span class="line">    	<span class="comment">//初始化三个栈的头结点</span></span><br><span class="line">    	stackTop = <span class="keyword">new</span> <span class="keyword">int</span>[] {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>};</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> stackNum, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">    	<span class="comment">//push首先需要判断栈是否满了，</span></span><br><span class="line">    	<span class="keyword">int</span> curStackTop = stackTop[stackNum];</span><br><span class="line">    	<span class="keyword">if</span>(curStackTop &lt; stackSize * <span class="number">3</span>) {</span><br><span class="line">    		<span class="comment">//赋值</span></span><br><span class="line">    		stack[curStackTop] = value;</span><br><span class="line">    		<span class="comment">//头结点 + 3</span></span><br><span class="line">    		stackTop[stackNum] += <span class="number">3</span>;</span><br><span class="line">    	}<span class="keyword">else</span> {<span class="comment">//栈满了</span></span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	}</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>{</span><br><span class="line">    	<span class="comment">//栈顶出栈首先需要判断栈是否为空</span></span><br><span class="line">    	<span class="keyword">if</span>(isEmpty(stackNum)) {</span><br><span class="line">    		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    	}</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//原本因为每次进栈后栈顶元素的下标的都会加3，出栈需要先减三</span></span><br><span class="line">    	stackTop[stackNum] -= <span class="number">3</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">return</span> stack[stackTop[stackNum]];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>{</span><br><span class="line">    	<span class="comment">//同理，判断是否为空</span></span><br><span class="line">    	<span class="keyword">if</span>(isEmpty(stackNum)) {</span><br><span class="line">    		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    	}</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//因为是peek，所以不用改变栈顶指针的值</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">return</span> stack[stackTop[stackNum] - <span class="number">3</span>];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>{</span><br><span class="line">    	<span class="comment">//判断这个栈是否为空，因为每次进栈后栈顶元素的下标的都会加3，所以判空时需要先减三判断是否小于90</span></span><br><span class="line">    	<span class="keyword">return</span> stackTop[stackNum] - <span class="number">3</span> &lt; <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥算法国赛真题总结</title>
    <url>/A_summary_of_the_National_Games/</url>
    <content><![CDATA[<p>🌸记录蓝桥杯javaB组历届决赛真题解题算法总结与对比</p>
<a id="more"></a>

<h2 id="🌸解题方法汇总（java-B组决赛）"><a href="#🌸解题方法汇总（java-B组决赛）" class="headerlink" title="🌸解题方法汇总（java B组决赛）"></a>🌸解题方法汇总（java B组决赛）</h2><table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>第四届</td>
<td>暴力枚举</td>
<td>暴力枚举</td>
<td>快速排序</td>
<td>BFS、双向BFS、八数码问题、康托展开等</td>
<td>动态规划、模拟</td>
<td>-1</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>第五届</td>
<td>暴力枚举</td>
<td>全排列+剪枝（或者直接暴力但是代码剪枝量很大）</td>
<td>读题、细心、逻辑模拟</td>
<td>康托展开式（不会则直接暴力全排，但是分不高，可能一半都没有而且超时）、阶乘</td>
<td>行列式、矩阵乘法、模拟、扩展欧几里得</td>
<td>-1</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>第六届</td>
<td>脑筋转弯+暴力计算</td>
<td>全排列+判断</td>
<td>自己的方法是<strong>“猜”“试出来”</strong></td>
<td>深度优先搜索</td>
<td>-1</td>
<td>-1</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>第七届</td>
<td>画图找出规律后使用递归模拟过程</td>
<td>全排列</td>
<td>代码分析，考你能不能读懂代码</td>
<td>回溯+剪枝</td>
<td>暴力搜索（超时）；DFS+剪枝回溯（60）；动态规划（80）；数据结构（100）</td>
<td>-1</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>第八届</td>
<td>直接暴力循环</td>
<td>使用另一个数组进行模拟细胞增殖的过程或者使用深度优先模拟</td>
<td>读代码找规律（看自己的细心程度吧）</td>
<td>直接模拟计算的过程，注意使用数据范围较大的Long，而且需要熟练使用Long、Integer等类的API</td>
<td>博弈问题、深度优先、剪枝，回溯、模拟</td>
<td>-1</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>第九届</td>
<td>海伦公式</td>
<td>全排列、剪枝判断</td>
<td>全排列、回溯</td>
<td>并查集、连通分量、递归</td>
<td>构造树或者递归优化</td>
<td>-1</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>第十届模拟</td>
<td>暴力+熟悉除模运算的实质</td>
<td>暴力或者深搜求子串</td>
<td>暴力（时间长）、找规律分析题，将除模转换成次方</td>
<td>暴力深搜（耗时加分低）、找规律理解最大公约数的含义</td>
<td>并查集、联通分量找环</td>
<td>-1（暴力只能30）</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>第十届</td>
<td>暴力</td>
<td>素数筛、记忆化深搜或者dp</td>
<td>找规律</td>
<td>素因子分解、找规律</td>
<td>深搜+判重</td>
<td>dp+贪心</td>
<td>暴力或者dp</td>
<td>-1（找规律）</td>
<td>线段树、主席树、树状数组</td>
<td>-1</td>
</tr>
</tbody></table>
<ul>
<li><a href="">javaB组历届决赛真题汇总</a></li>
<li><a href="">javaB组历届省赛赛真题汇总</a></li>
</ul>
<h2 id="🌸康托展开"><a href="#🌸康托展开" class="headerlink" title="🌸康托展开"></a>🌸康托展开</h2><p><strong>康托展开</strong>是一个全排列到一个<a href="https://baike.baidu.com/item/自然数" target="_blank" rel="noopener">自然数</a>的<a href="https://baike.baidu.com/item/双射" target="_blank" rel="noopener">双射</a>，常用于构建<a href="https://baike.baidu.com/item/哈希表" target="_blank" rel="noopener">哈希表</a>时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。</p>
<p><strong>通俗简介：</strong></p>
<p>康托展开可以求解一个排列的序号，比如：12345 序号为 1 ，12354序号为2，按字典序增加编号递增，依次类推。<br>康托逆展开可以求解一个序号它对应的排列是什么。</p>
<p>先给出康托展开的公式：</p>
<p>$X = a_n(n - 1)!+ a_{n-1}(n-2)!+….+a_1\cdot0!$</p>
<p>先对这个公式里变量进行解释，大家不理解这个公式没关系，慢慢往后看，很简单的。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9nc3MzLmJkc3RhdGljLmNvbS83UG8zZFNhZ194STRraEdrcG9XSzFIRjZoaHkvYmFpa2UvcyUzRDEyL3NpZ249N2NlMGY3ZmFkODA3MzVmYTk1ZjA0YWJiOWM1MTQ4ZmEvMGRmM2Q3Y2E3YmNiMGE0NjI1ZTdkZWQ4Njc2M2Y2MjQ2YTYwYWYwZS5qcGc?x-oss-process=image/format,png" alt="img"> 的意思是从右往左数第 i 位这个数是这个数前未出现的数，第<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9nc3MzLmJkc3RhdGljLmNvbS83UG8zZFNhZ194STRraEdrcG9XSzFIRjZoaHkvYmFpa2UvcyUzRDEyL3NpZ249N2NlMGY3ZmFkODA3MzVmYTk1ZjA0YWJiOWM1MTQ4ZmEvMGRmM2Q3Y2E3YmNiMGE0NjI1ZTdkZWQ4Njc2M2Y2MjQ2YTYwYWYwZS5qcGc?x-oss-process=image/format,png" alt="img"> 大。举个例子就明白这个公式了：</p>
<p>注意：计算的时候 12345 序列应视为第0个序列，后面会解释为什么。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">百度百科的例子</span><br><span class="line">在（1,2,3，4，5）5个数的排列组合中，计算 34152的康托展开值。</span><br><span class="line">首位是3，则小于3的数有两个，为1和2，，则首位小于3的所有排列组合为</span><br><span class="line">第二位是4，由于第一位小于4，1、2、3中一定会有1个充当第一位，所以排在4之下的只剩2个，所以其实计算的是在第二位之后小于4的个数。因此。</span><br><span class="line">第三位是1，则在其之后小于1的数有0个，所以。</span><br><span class="line">第四位是5，则在其之后小于5的数有1个，为2，所以。</span><br><span class="line">最后一位就不用计算啦，因为在它之后已经没有数了，所以固定为0</span><br><span class="line">根据公式：</span><br><span class="line">X = 2 x 4! + 2 x 3! + 0 x 2! + 1 x 1! + 0 x 0！</span><br><span class="line">　　所以比34152小的组合有61个，即34152是排第62。</span><br></pre></td></tr></tbody></table></figure>

<p>拿52413举例子：</p>
<p>1、首先看第一个数 5，不管第一位是什么数，后面都有四位数，那么这四位数全排列的方式有 4！种，而如果第一位是 1 或 2 或 3 或 4 都会比5开头的字典序要小，所以可以令1，2，3，4分别作为开头，这样的话就会有 4 * 4！种排法要比 52413这种排法的字典序要小。</p>
<p>那么第一个数是1，2，3，4时候的字典序的个数数完了是 4 * 4！ 种，且这些字典序都要比52413的字典序要小。</p>
<p>还有其他的排列方式比52413的字典序要小的吗？</p>
<p>2、那么就可以固定第一位5，找下一位2，这时5已经用过了，所以从剩下的 1，2，3，4 里挑选比2小的数，一共1个，后面还剩三位，也就是3！种排列方式，那么这时候比 52413 字典序要小的又有 1 * 3！种，也就是当5在第一位，1在第二位的时候。</p>
<p>3、再看第三位4，这时5，2都用了，所以从剩下的 1，3，4三个数中找比4小的数的个数，有两个比4小原理同上，所以这时候也可以有 2 * 2!种排列方式的字典序小于 52413</p>
<p>4、再看第四位1，这时候会有 0 * 1！种</p>
<p>5、再看第五位3，这时候会有0 * 0！种</p>
<p>综上所述：<br>对于序列： 52413 该序列展开后为： 4 * 4! + 1 * 3! + 2 * 2! + 0 * 1! + 0 * 0! ，计算结果是： 106<br>由于是从0开始计数的，所以最后 52413 的编号为 107</p>
<p>为什么从0开始计数？<br>可以这样看：我现在让你求12345的康托展开值，也就是：0<em>4！+ 0</em>3！+ 0<em>2！+ 0</em>1！+0*0！ = 0 所以明白了吧~~<br>康托公式最小字典序的编号就是0。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/***** 这里以字符串进行展示  字符串可泛化性好 ******/</span></span><br><span class="line"> </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*******打出1-n的阶乘表*******/</span></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jie_cheng</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 0的阶乘为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) f[i] = f[i - <span class="number">1</span>] * i;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**************康托展开****************/</span></span><br><span class="line">string str;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kangtuo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;  <span class="comment">//注意，因为 12345 是算作0开始计算的，最后结果要把12345看作是第一个</span></span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++){</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;<span class="comment">//用来计数的</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++){</span><br><span class="line">            <span class="keyword">if</span>(str[i] &gt; str[j]) tmp++;</span><br><span class="line">            <span class="comment">//计算str[i]是第几大的数，或者说计算有几个比他小的数</span></span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        ans += tmp * f[len - i - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    jie_cheng(<span class="number">10</span>);</span><br><span class="line">    string str = <span class="string">"52413"</span>;</span><br><span class="line">    cout&lt;&lt;kangtuo()&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸康托逆展开"><a href="#🌸康托逆展开" class="headerlink" title="🌸康托逆展开"></a>🌸康托逆展开</h2><p>直接开栗子：</p>
<p>如果初始序列是12345（第一个），让你求第107个序列是什么。（按字典序递增）</p>
<p>这样计算：</p>
<p>先把107减1，因为康托展开里的初始序列编号为0<br>然后计算下后缀积：<br> 1    2    3   4   5<br> 5！ 4！ 3！ 2！1！ 0！<br>120  24   6   2   1   1</p>
<p>106 / 4! = 4 ······ 10 有4个比它小的所以因该是5  从（1，2，3，4，5）里选<br>10  / 3! = 1 ······ 4  有1个比它小的所以因该是2  从（1， 2， 3， 4）里选<br> 4   / 2! = 2 ······ 0  有2个比它小的所以因该是4  从（1， 3， 4）里选<br> 0   / 1! = 0 ······ 0  有0个比它小的所以因该是1  从（1，3）里选<br> 0   / 0! = 0 ······ 0  有0个比它小的所以因该是3  从（3）里选</p>
<p>所以编号107的是 52413</p>
<h3 id="康托逆展开代码："><a href="#康托逆展开代码：" class="headerlink" title="康托逆展开代码："></a>康托逆展开代码：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/***** 这里以字符串进行展示  字符串可泛化性好 ******/</span></span><br><span class="line"> </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*******打出1-n的阶乘表*******/</span></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> x, num;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jie_cheng</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 0的阶乘为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) f[i] = f[i - <span class="number">1</span>] * i;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**************康托逆展开**************/</span></span><br><span class="line"> </span><br><span class="line">vector&lt;<span class="keyword">char</span>&gt; vec; <span class="comment">//存需要排列的字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rev_kangtuo</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="comment">//输出序号为 k 的字符序列</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n = vec.size(), len = <span class="number">0</span>;</span><br><span class="line">    string ans = <span class="string">""</span>;</span><br><span class="line">    k--; <span class="comment">// 算的时候是按 12345 是第0位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">        <span class="keyword">int</span> t = k / f[n - i]; <span class="comment">// 第 i 位需要 第 t + 1 大的数</span></span><br><span class="line">        k %= f[n - i];        <span class="comment">//剩下的几位需要提供的排列数</span></span><br><span class="line">        ans += vec[t] ; <span class="comment">//  vec[t] 就是第 t + 1 大的数</span></span><br><span class="line">        vec.erase(vec.begin() + t); </span><br><span class="line"><span class="comment">//用过就删了，不用vector用暴力也可以，就是说枚举，然后一个一个的比较大小，并记录有几个没用过的字符且字典序比它小</span></span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/***************************************/</span></span><br><span class="line"><span class="comment">// 假设展开后不超过10位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    jie_cheng(<span class="number">10</span>); <span class="comment">// 预处里好阶乘</span></span><br><span class="line">    scanf(<span class="string">"%d"</span>, &amp;x); <span class="comment">// 输入需要逆展开的数字</span></span><br><span class="line">    <span class="comment">/************康托逆展开***********/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    {</span><br><span class="line">    	<span class="keyword">if</span>(x / f[i] == <span class="number">0</span>) <span class="comment">// 求出 x 逆展开所需的最小的位数，方便下面的初始化</span></span><br><span class="line">    	{</span><br><span class="line">    		num = i;</span><br><span class="line">    		<span class="keyword">break</span>;</span><br><span class="line">    	}</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) vec.push_back(i + <span class="string">'0'</span>); <span class="comment">//输入的位数只要不小于num就可以</span></span><br><span class="line">    rev_kangtuo(x);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸吉姆拉尔森公式"><a href="#🌸吉姆拉尔森公式" class="headerlink" title="🌸吉姆拉尔森公式"></a>🌸吉姆拉尔森公式</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">whatday</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span>(m == <span class="number">1</span>) {</span><br><span class="line">		y--;</span><br><span class="line">		m = <span class="number">13</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(m == <span class="number">2</span>) {</span><br><span class="line">		y--;</span><br><span class="line">		m = <span class="number">14</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> (d + <span class="number">2</span> * m + <span class="number">3</span> * (m + <span class="number">1</span>) / <span class="number">5</span> + y + y / <span class="number">4</span> - y / <span class="number">100</span> + y / <span class="number">400</span>) % <span class="number">7</span> + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸海伦公式"><a href="#🌸海伦公式" class="headerlink" title="🌸海伦公式"></a>🌸海伦公式</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">三角形三边长a, b, c</span><br><span class="line">p = (a + b + c) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">area = Math.sqrt(p * (p - a) * (p - b) * (p - c))</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸素数"><a href="#🌸素数" class="headerlink" title="🌸素数"></a>🌸素数</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用API</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">n_prime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">	BigInteger in = <span class="keyword">new</span> BigInteger(<span class="string">"2"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">		in = in.nextProbablePrime();</span><br><span class="line">	}</span><br><span class="line">	System.out.println(in);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常规方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">n_prime1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">	List&lt;Long&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">2</span>; list.size() &lt; n; i++) {</span><br><span class="line">		<span class="keyword">if</span>(prime(i)) {</span><br><span class="line">			list.add(i);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	System.out.println(list.get(n - <span class="number">1</span>));</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">prime</span><span class="params">(<span class="keyword">long</span> n)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span>(n &lt; <span class="number">2</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">2</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= n;i += <span class="number">2</span>) {</span><br><span class="line">		<span class="keyword">if</span>(n % i == <span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">n_prime2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">		arr[i] = <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) {<span class="comment">//可以只用根号n之前的数字去筛选</span></span><br><span class="line">		<span class="keyword">if</span>(arr[i] == <span class="number">1</span>) { <span class="comment">//不加判断也是可以的，增加复杂度了，我们只需要在我们所认为的“素数”中筛选就可以了， 每个合数必有质因子</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i * i; j &lt;= n; j += i) { <span class="comment">//比如j = i * k(k &lt; i),那么j肯定被k筛掉了</span></span><br><span class="line">				arr[j] = <span class="number">0</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">		<span class="keyword">if</span>(arr[i] == <span class="number">1</span>) {</span><br><span class="line">			<span class="keyword">if</span>(k == <span class="number">100002</span>) {</span><br><span class="line">				System.out.println(<span class="string">"-&gt;"</span>+i);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			}</span><br><span class="line">			k++;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸日期类（SimpleDateFormat-Date"><a href="#🌸日期类（SimpleDateFormat-Date" class="headerlink" title="🌸日期类（SimpleDateFormat +Date)"></a>🌸日期类（SimpleDateFormat +Date)</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-mm-dd"</span>);</span><br><span class="line">        Date date1 = format.parse(<span class="string">"1921-7-23"</span>);</span><br><span class="line">        Date date2 = format.parse(<span class="string">"2020- 7-1"</span>);</span><br><span class="line">        <span class="keyword">int</span> a = (<span class="keyword">int</span>)((date2.getTime() - date1.getTime()) / <span class="number">1000</span> * <span class="number">60</span>);<span class="comment">//相隔多少分钟</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//直接使用 Date</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">36138</span> * <span class="number">24</span> * <span class="number">60L</span>;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.out.println(<span class="number">36138</span> * <span class="number">24</span> * <span class="number">60</span>);</span><br><span class="line">        <span class="comment">// long型变量在定义的时候，如果不加“L”,则默认为int型变量</span></span><br><span class="line">        Date date1 = <span class="keyword">new</span> Date(<span class="number">21</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 1921</span></span><br><span class="line">        Date date2 = <span class="keyword">new</span> Date(<span class="number">120</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 2020</span></span><br><span class="line">        <span class="keyword">long</span> time = date2.getTime() - date1.getTime();</span><br><span class="line">        System.out.println(time / (<span class="number">60000</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h3 id="🍁"><a href="#🍁" class="headerlink" title="🍁"></a>🍁</h3><h4 id="🍂"><a href="#🍂" class="headerlink" title="🍂"></a>🍂</h4><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>蓝桥杯国赛真题</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥算法省赛真题总结</title>
    <url>/Summary_of_provincial_competition/</url>
    <content><![CDATA[<p>🌸<strong>记录蓝桥杯javaB组省赛题目解题方法总结对比</strong></p>
<a id="more"></a>

<h2 id="🌸解题方法汇总（java-B组省赛）"><a href="#🌸解题方法汇总（java-B组省赛）" class="headerlink" title="🌸解题方法汇总（java B组省赛）"></a>🌸解题方法汇总（java B组省赛）</h2><table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>第四届</td>
<td>日期(API)、吉姆拉尔森公式</td>
<td>暴力枚举</td>
<td>暴力深搜</td>
<td>递归、大数类</td>
<td>逻辑模拟</td>
<td>逻辑模拟</td>
<td>暴力查找(类集框架)</td>
<td>模拟过程</td>
<td>全排列、逻辑判断、逻辑枚举的条件判断，枚举所有情况</td>
<td>题意理解，思维的巧妙运用</td>
</tr>
<tr>
<td>第五届</td>
<td>数学逻辑</td>
<td>数学逻辑</td>
<td>字符串、暴力模拟</td>
<td>数学、奇偶数</td>
<td>数学逻辑</td>
<td>暴力枚举</td>
<td>全排列、逻辑检查</td>
<td>模拟过程</td>
<td>深度优先、过程模拟搜索、记忆化递归</td>
<td>-1</td>
</tr>
<tr>
<td>第六届</td>
<td>简单数学计算</td>
<td>暴力枚举</td>
<td>暴力枚举</td>
<td>模拟过程发现小技巧</td>
<td>全排列</td>
<td>数学规律</td>
<td>递归</td>
<td>模拟过程</td>
<td>递归、动态规划、矩阵快速幂</td>
<td>递归最多一万层</td>
</tr>
<tr>
<td>第七届</td>
<td>数学规律</td>
<td>暴力枚举</td>
<td>暴力全排列</td>
<td>组合，规律</td>
<td>递归、组合</td>
<td>暴力、全排列</td>
<td>组合、深搜、图、联通分量</td>
<td>首先暴力、暴力优化（四层到两层）哈希</td>
<td>递归模拟过程、细节很重要</td>
<td>-1</td>
</tr>
<tr>
<td>第八届</td>
<td>Excel、耐心敲代码计算、暴力计算器、</td>
<td>全排列</td>
<td>二维数组找规律</td>
<td>-1</td>
<td>过程模拟分析</td>
<td>动态规划</td>
<td>API、日期的细心判断（主要是细心找到每一个满足的条件）</td>
<td>动态规划、扩展欧几里得、完全背包</td>
<td>数学规律、模拟过程</td>
<td>暴力、前缀和优化、取模运算</td>
</tr>
<tr>
<td>第九届</td>
<td>日期、计算器（注意加一天）</td>
<td>暴力计算、勾股定理</td>
<td>大数类、数很大输入到文件</td>
<td>动态规划、递归、二分</td>
<td>随机快速排序、递归</td>
<td>暴力、优化（二分）、（双指针）</td>
<td>画图、画过程模拟、找出数学规律、等差数列求和、绝对值的消去</td>
<td>面向对象的思维模拟、类的自定义排序、思维逻辑的严密性</td>
<td>暴力深搜、DFS查找联通分量的个数</td>
<td>-1（乘法逆元）</td>
</tr>
<tr>
<td>第十届</td>
<td>综合分析、求最大值</td>
<td>暴力求子串、Set集合</td>
<td>暴力求值、有坑（只需要关注数的后四位，不然数字太大存不了）</td>
<td>暴力分解、条件判断</td>
<td>求最短路径、广度优先、深度优先、节点判断</td>
<td>暴力破解</td>
<td>模拟过程、注意合理运用变量和数组，利用二维数组和多个一维数组可以代替复杂的数据结构</td>
<td>逻辑分析与严密性、字符串正则以及API的使用</td>
<td>逻辑思维的分析与严密性、需要去考虑繁杂的所有可能的情况然后写出结果</td>
<td>-1</td>
</tr>
<tr>
<td>第十一届</td>
<td>手工计算、代码计算时注意减法时的边界不能减到负数</td>
<td>日期、计算器、日期类</td>
<td>数学求最值、求算数不等式相等时的边界情况</td>
<td>-1（找规律，用代码去模拟题目要求程序计算的过程）</td>
<td>动态规划、找出存放规律与状态的转移方程</td>
<td>暴力取模、优化（位运算&gt;&gt;取代 / ）(即n = n&gt;&gt; 1 相当于 n = n / 2)</td>
<td>熟练使用API、StringBuilder以及字符串的判断、总的来说就是暴力模拟</td>
<td>深度优先搜索、动态规划</td>
<td>暴力拼接（双重for）、优化（二维数组、位数取取余等）</td>
<td>-1</td>
</tr>
<tr>
<td>第十二届</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="🌸黄金分割数与斐波那契数列的关系"><a href="#🌸黄金分割数与斐波那契数列的关系" class="headerlink" title="🌸黄金分割数与斐波那契数列的关系"></a>🌸黄金分割数与斐波那契数列的关系</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">比较简单的一种是用连分数：</span><br><span class="line">                                   1</span><br><span class="line">    黄金数 = ------------------------------</span><br><span class="line">                                     1</span><br><span class="line">                    1 + ---------------------</span><br><span class="line">                                        1</span><br><span class="line">                           1 + -------------</span><br><span class="line">                                          1</span><br><span class="line">                                 1 + -------</span><br><span class="line">                                       1 + ...</span><br><span class="line">                         </span><br><span class="line">    这个连分数计算的“层数”越多，它的值越接近黄金分割数。</span><br><span class="line">    请你利用这一特性，求出黄金分割数的足够精确值，要求四舍五入到小数点后100位。</span><br><span class="line">    小数点后3位的值为：0.618</span><br><span class="line">    小数点后4位的值为：0.6180</span><br><span class="line">    小数点后5位的值为：0.61803</span><br><span class="line">    小数点后7位的值为：0.6180340</span><br></pre></td></tr></tbody></table></figure>

<p>可以分析得出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">第二层      1/2    后两位</span><br><span class="line">第三层      2/3    后三位</span><br><span class="line">第四层      3/5	后四位</span><br><span class="line">第五层      5/8	后五位</span><br><span class="line">.....</span><br><span class="line">以此类推</span><br><span class="line">即后100位为稳定的100多位的斐波那契数相除，则可以得出代码</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">          </span><br><span class="line">        BigInteger a = BigInteger.ONE;</span><br><span class="line">        BigInteger b = BigInteger.ONE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; <span class="number">500</span>; i++) {</span><br><span class="line">        	BigInteger t = b;</span><br><span class="line">        	b = a.add(b);</span><br><span class="line">        	a = t;</span><br><span class="line">        }</span><br><span class="line">        BigDecimal divide = <span class="keyword">new</span> BigDecimal(a, <span class="number">110</span>).divide(<span class="keyword">new</span> BigDecimal(b, <span class="number">110</span>), BigDecimal.ROUND_HALF_DOWN);</span><br><span class="line">        System.out.println(divide.toPlainString().substring(<span class="number">0</span>, <span class="number">103</span>));</span><br><span class="line">	</span><br><span class="line">	}</span><br><span class="line">    <span class="comment">//求斐波那契</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> BigDecimal <span class="title">fb</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">        BigDecimal a = BigDecimal.ONE;</span><br><span class="line">        BigDecimal b = BigDecimal.ONE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            BigDecimal t = b;</span><br><span class="line">            b = a.add(b);</span><br><span class="line">            a=t;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸圆周率与连分数"><a href="#🌸圆周率与连分数" class="headerlink" title="🌸圆周率与连分数"></a>🌸圆周率与连分数</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> 4                               1</span><br><span class="line">----   = 1 +  ------------------------------</span><br><span class="line"> N(圆周率)                            9</span><br><span class="line">                 1 + ---------------------</span><br><span class="line">                                       25</span><br><span class="line">                        2 + -----------------</span><br><span class="line">                                         </span><br><span class="line">                              2 + .............</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">111</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">10000</span>; n&gt;=<span class="number">0</span>; n--){</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">        x = <span class="number">2</span> + (i*i / x);</span><br><span class="line">    }</span><br><span class="line">   </span><br><span class="line">    System.out.println(String.format(<span class="string">"%.4f"</span>, <span class="number">4</span>/ (x - <span class="number">1</span>)));</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸吉姆拉尔森公式"><a href="#🌸吉姆拉尔森公式" class="headerlink" title="🌸吉姆拉尔森公式"></a>🌸吉姆拉尔森公式</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">whatday</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span>(m == <span class="number">1</span>) {</span><br><span class="line">		y--;</span><br><span class="line">		m = <span class="number">13</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(m == <span class="number">2</span>) {</span><br><span class="line">		y--;</span><br><span class="line">		m = <span class="number">14</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> (d + <span class="number">2</span> * m + <span class="number">3</span> * (m + <span class="number">1</span>) / <span class="number">5</span> + y + y / <span class="number">4</span> - y / <span class="number">100</span> + y / <span class="number">400</span>) % <span class="number">7</span> + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸复数幂（复数的阶乘）-了解打印流的使用文本"><a href="#🌸复数幂（复数的阶乘）-了解打印流的使用文本" class="headerlink" title="🌸复数幂（复数的阶乘）(了解打印流的使用文本)"></a>🌸复数幂（复数的阶乘）(了解打印流的使用文本)</h2><p>复数计算的规律  尝试用 (a+bi)<em>(c+di) = (a</em>c - b<em>d) + (a</em>d + b*c)i </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>{</span><br><span class="line">		<span class="comment">//System.out.println(getNum(new BigInteger("2"), new BigInteger("3"), new BigInteger("2"), new BigInteger("3")));</span></span><br><span class="line">		</span><br><span class="line">		BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"2"</span>);</span><br><span class="line">		BigInteger b = <span class="keyword">new</span> BigInteger(<span class="string">"3"</span>);</span><br><span class="line">		BigInteger c = <span class="keyword">new</span> BigInteger(<span class="string">"2"</span>);</span><br><span class="line">		BigInteger d = <span class="keyword">new</span> BigInteger(<span class="string">"3"</span>);</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">		BigInteger shi;</span><br><span class="line">		BigInteger xu;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(n &lt; <span class="number">123456</span>) {</span><br><span class="line">			shi = a.multiply(c).subtract((b.multiply(d)));</span><br><span class="line">			xu = a.multiply(d).add(b.multiply(c));</span><br><span class="line">			n++;</span><br><span class="line">			a = shi;</span><br><span class="line">			b = xu;</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(b.compareTo(<span class="keyword">new</span> BigInteger(<span class="string">"0"</span>)) == <span class="number">1</span>) {</span><br><span class="line">			System.out.println(a + <span class="string">"+"</span> + b + <span class="string">"i"</span>);</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(b.compareTo(<span class="keyword">new</span> BigInteger(<span class="string">"0"</span>)) == <span class="number">0</span>) {</span><br><span class="line">			System.out.println(a + <span class="string">""</span>);</span><br><span class="line">		}<span class="keyword">else</span> {</span><br><span class="line">			System.out.println(a + <span class="string">""</span> + b + <span class="string">"i"</span>);</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		PrintStream out = System.out;</span><br><span class="line">		PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> File(<span class="string">"ans.txt"</span>));</span><br><span class="line">		System.setOut(ps);;<span class="comment">//输出在ans.txt</span></span><br><span class="line">		System.out.println(a.toString() +b.toString() + <span class="string">"i"</span>);</span><br><span class="line">		System.setOut(out);</span><br><span class="line">		System.out.println(a.toString() + b.toString() + <span class="string">"i"</span>);</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸扔鸡蛋问题（摔手机）（面试题）（动态规划）"><a href="#🌸扔鸡蛋问题（摔手机）（面试题）（动态规划）" class="headerlink" title="🌸扔鸡蛋问题（摔手机）（面试题）（动态规划）"></a>🌸扔鸡蛋问题（摔手机）（面试题）（动态规划）</h2><p>你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。</p>
<p>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</p>
<p>你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。</p>
<p>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。</p>
<p>你的目标是确切地知道 F 的值是多少。</p>
<p>无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 鸡蛋解法力扣 </span>{</span><br><span class="line">    <span class="keyword">static</span> Integer[][] memo = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">        memo = <span class="keyword">new</span> Integer[K+<span class="number">1</span>][N+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp(K,N);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *当前K个鸡蛋共有N层楼状态时 返回这个状态下确定 F的值的最小移动次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">        <span class="comment">//base case 层数N等于0时不需要扔鸡蛋,当鸡蛋数K为1时，只能每层逐个尝试剩下所有楼层</span></span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>)<span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加一个备忘录 消除之前算过的重叠子问题</span></span><br><span class="line">        <span class="keyword">if</span>(memo[k][n]!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[k][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tmp = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//第一种 从第1层楼到第n层楼每层楼开始逐个尝试作为切入点 (会超时)</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++){</span><br><span class="line">             <span class="comment">//当选择在第i层楼扔了鸡蛋之后 可能出现鸡蛋碎了和鸡蛋没碎两种情况：</span></span><br><span class="line">             <span class="comment">//当鸡蛋碎了 问题状态转嫁为求k-1个鸡蛋 搜索的楼层区间变为1~i-1共i-1层楼时求解</span></span><br><span class="line">             <span class="keyword">int</span> eggBreak=dp(k-<span class="number">1</span>,i-<span class="number">1</span>);</span><br><span class="line">             <span class="comment">//当鸡蛋没碎 问题状态转嫁为鸡蛋的个数K不变 搜索楼层区间变为i+1~N共N-i层楼时求解</span></span><br><span class="line">             <span class="keyword">int</span> eggUnBreak=dp(k,n-i);</span><br><span class="line">             <span class="comment">//最终以i层为切入点求解的答案 为两种状态的最坏情况 并加上i层时操作1 并更新最小值</span></span><br><span class="line">             tmp = Math.min(tmp,Math.max(eggBreak,eggUnBreak)+<span class="number">1</span>);</span><br><span class="line">         }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种 利用二分查找的方式直接找到对应点(AC通过)</span></span><br><span class="line">        <span class="comment">//第一种线性逐个尝试切入点 然后求每个切入点两种状态的较大值 再求这些最大值之中的最小值 其实就是求这两条单调递增和单调递减直线的交点 相当于求上半部V形山谷值 二分查找来快速寻找这个点</span></span><br><span class="line"><span class="comment">//        int lo=1,hi =n;</span></span><br><span class="line"><span class="comment">//        while(lo&lt;=hi){</span></span><br><span class="line"><span class="comment">//            int mid =(lo+hi)/2;</span></span><br><span class="line"><span class="comment">//            int eggBreak = dp(k-1,mid-1);</span></span><br><span class="line"><span class="comment">//            int eggUnBreak = dp(k,n-mid);</span></span><br><span class="line"><span class="comment">//            if(eggBreak&gt;eggUnBreak){</span></span><br><span class="line"><span class="comment">//                hi = mid-1;</span></span><br><span class="line"><span class="comment">//                tmp = Math.min(tmp,eggBreak+1);</span></span><br><span class="line"><span class="comment">//            }else{</span></span><br><span class="line"><span class="comment">//                lo = mid+1;</span></span><br><span class="line"><span class="comment">//                tmp = Math.min(tmp,eggUnBreak+1);</span></span><br><span class="line"><span class="comment">//            }</span></span><br><span class="line">    <span class="comment">//    }</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加到备忘录里</span></span><br><span class="line">        memo[k][n]=tmp;</span><br><span class="line">        <span class="comment">//返回当前k个鸡蛋n层楼时求解的子问题的结果</span></span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(dp(<span class="number">3</span>,<span class="number">1000</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>x星球的居民脾气不太好，但好在他们生气的时候唯一的异常举动是：摔手机。</p>
<p>各大厂商也就纷纷推出各种耐摔型手机。x星球的质监局规定了手机必须经过耐摔测试，并且评定出一个耐摔指数来，之后才允许上市流通。</p>
<p>x星球有很多高耸入云的高塔，刚好可以用来做耐摔测试。塔的每一层高度都是一样的，与地球上稍有不同的是，他们的第一层不是地面，而是相当于我们的2楼。</p>
<p>如果手机从第7层扔下去没摔坏，但第8层摔坏了，则手机耐摔指数=7。</p>
<p>特别地，如果手机从第1层扔下去就坏了，则耐摔指数=0。</p>
<p>如果到了塔的最高层第n层扔没摔坏，则耐摔指数=n</p>
<p>为了减少测试次数，从每个厂家抽样3部手机参加测试。</p>
<p>某次测试的塔高为1000层，如果我们总是采用最佳策略，在最坏的运气下最多需要测试多少次才能确定手机的耐摔指数呢？</p>
<p>请填写这个最多测试次数。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>{</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10000</span>;j++)</span><br><span class="line">                memo[i][j] = <span class="number">99999999</span>;<span class="comment">//找最小,初始化INF</span></span><br><span class="line">        System.out.println(f(<span class="number">3</span>,<span class="number">1000</span>));</span><br><span class="line">        <span class="comment">//f(k,n)  当前的鸡蛋数  k</span></span><br><span class="line">        <span class="comment">//        需要测试的楼层数  n</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="comment">//当鸡蛋数只有1时，只能线性扫描所有的楼层 n 有多少层就得扔多少次 注意题目条件是运气差。</span></span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="comment">//当楼层数0是 没法扔鸡蛋</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(memo[k][n]!=<span class="number">99999999</span>)  <span class="comment">//避免重复计算</span></span><br><span class="line">            <span class="keyword">return</span> memo[k][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">99999999</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) {  <span class="comment">//穷举所有的可能选择</span></span><br><span class="line">            <span class="comment">//当选择在第i层楼扔了鸡蛋之后 可能出现鸡蛋碎了和鸡蛋没碎两种情况：</span></span><br><span class="line">            <span class="comment">//当鸡蛋碎了 问题状态转嫁为求k-1个鸡蛋 搜索的楼层区间变为1~i-1共i-1层楼时求解</span></span><br><span class="line">            <span class="keyword">int</span> eggBreak=f(k-<span class="number">1</span>,i-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//当鸡蛋没碎 问题状态转嫁为鸡蛋的个数K不变 搜索楼层区间变为i+1~N共N-i层楼时求解</span></span><br><span class="line">            <span class="keyword">int</span> eggUnBreak=f(k,n-i);</span><br><span class="line">            <span class="comment">//最终以i层为切入点求解的答案 为两种状态的最坏情况 并加上i层时操作1 并更新最小值</span></span><br><span class="line"></span><br><span class="line">            result= Math.min(result,</span><br><span class="line">                    Math.max(</span><br><span class="line">                            eggBreak,eggUnBreak</span><br><span class="line">                    )+<span class="number">1</span>    <span class="comment">//1表示在i层时要扔一次</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        memo[k][n]=result;</span><br><span class="line">        <span class="keyword">return</span> memo[k][n];</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸日期类（SimpleDateFormat-Date"><a href="#🌸日期类（SimpleDateFormat-Date" class="headerlink" title="🌸日期类（SimpleDateFormat +Date)"></a>🌸日期类（SimpleDateFormat +Date)</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-mm-dd"</span>);</span><br><span class="line">        Date date1 = format.parse(<span class="string">"1921-7-23"</span>);</span><br><span class="line">        Date date2 = format.parse(<span class="string">"2020- 7-1"</span>);</span><br><span class="line">        <span class="keyword">int</span> a = (<span class="keyword">int</span>)((date2.getTime() - date1.getTime()) / <span class="number">1000</span> * <span class="number">60</span>);<span class="comment">//相隔多少分钟</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//直接使用 Date</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">36138</span> * <span class="number">24</span> * <span class="number">60L</span>;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.out.println(<span class="number">36138</span> * <span class="number">24</span> * <span class="number">60</span>);</span><br><span class="line">        <span class="comment">// long型变量在定义的时候，如果不加“L”,则默认为int型变量</span></span><br><span class="line">        Date date1 = <span class="keyword">new</span> Date(<span class="number">21</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 1921</span></span><br><span class="line">        Date date2 = <span class="keyword">new</span> Date(<span class="number">120</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 2020</span></span><br><span class="line">        <span class="keyword">long</span> time = date2.getTime() - date1.getTime();</span><br><span class="line">        System.out.println(time / (<span class="number">60000</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h3 id="🍁"><a href="#🍁" class="headerlink" title="🍁"></a>🍁</h3><h4 id="🍂-fff"><a href="#🍂-fff" class="headerlink" title="🍂 fff"></a>🍂 fff</h4><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>蓝桥杯javaB组省赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode股票问题系列通解</title>
    <url>/general_solutions_to_stock_problems/</url>
    <content><![CDATA[<h3 id="🍁说明"><a href="#🍁说明" class="headerlink" title="🍁说明"></a>🍁说明</h3><p>原文出处：<a href="https://leetcode-cn.com/circle/article/qiAgHn/" target="_blank" rel="noopener">股票问题</a></p>
<h2 id="🌸前言"><a href="#🌸前言" class="headerlink" title="🌸前言"></a>🌸前言</h2><p>股票问题一共有六道题，链接如下：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121.买卖股票的最佳时机</a></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122.买卖股票的最佳时机 II</a></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">124.买卖股票的最佳时机 IV</a></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">125.最佳买卖股票时机含冷冻期</a></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">126.买卖股票的最佳时机含手续费</a></li>
</ul>
<a id="more"></a>

<p>每个问题都有优质的题解，但是大多数题解没有建立起这些问题之间的联系，也没有给出股票问题系列的通解。这篇文章给出适用于全部股票问题的通解，以及对于每个特定问题的特解。</p>
<h2 id="🍁通用情况"><a href="#🍁通用情况" class="headerlink" title="🍁通用情况"></a>🍁通用情况</h2><p>这个想法基于如下问题：<strong>给定一个表示每天股票价格的数组，什么因素决定了可以获得的最大收益？</strong></p>
<p>相信大多数人可以很快给出答案，例如「在哪些天进行交易以及允许多少次交易」。这些因素当然重要，在问题描述中也有这些因素。然而还有一个隐藏但是关键的因素决定了最大收益，下文将阐述这一点。</p>
<p>首先介绍一些符号：</p>
<ul>
<li>用 <code>n</code> 表示股票价格数组的长度；<br>用 <code>i</code> 表示第 i 天（i 的取值范围是 0 到 n - 1）；<br>用 <code>k</code> 表示允许的最大交易次数；<br>用 <code>T[i][k]</code> 表示在第 <code>i</code> 天结束时，最多进行 <code>k</code> 次交易的情况下可以获得的最大收益。</li>
</ul>
<p>基准情况是显而易见的：<code>T[-1][k] = T[i][0] = 0</code>，表示没有进行股票交易时没有收益（注意第一天对应 <code>i = 0</code>，因此 <code>i = -1</code> 表示没有股票交易）。现在如果可以将 <code>T[i][k]</code> 关联到子问题，例如 <code>T[i - 1][k]、T[i][k - 1]、T[i - 1][k - 1]</code> 等子问题，就能得到状态转移方程，并对这个问题求解。如何得到状态转移方程呢？</p>
<p>最直接的办法是看第 <code>i</code> 天可能的操作。有多少个选项？答案是三个：<strong>买入、卖出、休息</strong>。应该选择哪个操作？答案是：并不知道哪个操作是最好的，但是可以通过计算得到选择每个操作可以得到的最大收益。假设没有别的限制条件，则可以尝试每一种操作，并选择可以最大化收益的一种操作。但是，题目中确实有限制条件，规定不能同时进行多次交易，因此如果决定在第 <code>i</code> 天<strong>买入</strong>，在买入之前必须持有 0 份股票，如果决定在第 <code>i</code> 天<strong>卖出</strong>，在卖出之前必须恰好持有 1 份股票。持有股票的数量是上文提及到的隐藏因素，该因素影响第 i 天可以进行的操作，进而影响最大收益。</p>
<p>因此对 <code>T[i][k]</code> 的定义需要分成两项：</p>
<ul>
<li><code>T[i][k][0]</code> 表示在第 <code>i</code> 天结束时，<strong>最多</strong>进行 <code>k</code> 次交易且在进行操作后持有 0 份股票的情况下可以获得的最大收益；</li>
<li><code>T[i][k][1]</code> 表示在第 <code>i</code> 天结束时，<strong>最多</strong>进行 <code>k</code> 次交易且在进行操作后持有 1 份股票的情况下可以获得的最大收益。</li>
</ul>
<p>使用新的状态表示之后，可以得到基准情况和状态转移方程。</p>
<p>基准情况：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">T[-1][k][0] = 0, T[-1][k][1] = -Infinity</span><br><span class="line">T[i][0][0] = 0, T[i][0][1] = -Infinity</span><br></pre></td></tr></tbody></table></figure>

<p>状态转移方程：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] + prices[i])</span><br><span class="line">T[i][k][1] = max(T[i - 1][k][1], T[i - 1][k - 1][0] - prices[i])</span><br></pre></td></tr></tbody></table></figure>

<p>基准情况中，<code>T[-1][k][0] = T[i][0][0] = 0</code> 的含义和上文相同，<code>T[-1][k][1] = T[i][0][1] = -Infinity</code> 的含义是在没有进行股票交易时不允许持有股票。</p>
<p>对于状态转移方程中的 <code>T[i][k][0]</code>，第 <code>i</code> 天进行的操作只能是休息或卖出，因为在第 <code>i</code> 天结束时持有的股票数量是 0。<code>T[i - 1][k][0]</code> 是休息操作可以得到的最大收益，<code>T[i - 1][k][1] + prices[i]</code> 是卖出操作可以得到的最大收益。注意到允许的最大交易次数是不变的，因为每次交易包含两次成对的操作，买入和卖出。只有买入操作会改变允许的最大交易次数。</p>
<p>对于状态转移方程中的 <code>T[i][k][1]</code>，第 <code>i</code> 天进行的操作只能是休息或买入，因为在第 <code>i</code> 天结束时持有的股票数量是 1。<code>T[i - 1][k][1]</code> 是休息操作可以得到的最大收益，<code>T[i - 1][k - 1][0] - prices[i]</code> 是买入操作可以得到的最大收益。注意到允许的最大交易次数减少了一次，因为每次买入操作会使用一次交易。</p>
<p>为了得到最后一天结束时的最大收益，可以遍历股票价格数组，根据状态转移方程计算 <code>T[i][k][0]</code> 和 <code>T[i][k][1]</code> 的值。最终答案是 <code>T[n - 1][k][0]</code>，因为结束时持有 0 份股票的收益一定大于持有 1 份股票的收益。</p>
<h2 id="🍁应用于特殊情况"><a href="#🍁应用于特殊情况" class="headerlink" title="🍁应用于特殊情况"></a>🍁应用于特殊情况</h2><p>上述六个股票问题是根据 <code>k</code> 的值进行分类的，其中 <code>k</code> 是允许的最大交易次数。最后两个问题有附加限制，包括「冷冻期」和「手续费」。通解可以应用于每个股票问题。</p>
<h4 id="情况一：k-1"><a href="#情况一：k-1" class="headerlink" title="情况一：k = 1"></a><strong>情况一：k = 1</strong></h4><p>情况一对应的题目是<strong>「121. 买卖股票的最佳时机」</strong>。</p>
<p>对于情况一，每天有两个未知变量：<code>T[i][1][0]</code> 和 <code>T[i][1][1]</code>，状态转移方程如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">T[i][1][0] = max(T[i - 1][1][0], T[i - 1][1][1] + prices[i])</span><br><span class="line">T[i][1][1] = max(T[i - 1][1][1], T[i - 1][0][0] - prices[i]) = max(T[i - 1][1][1], -prices[i])</span><br></pre></td></tr></tbody></table></figure>



<p>第二个状态转移方程利用了 <code>T[i][0][0] = 0</code>。</p>
<p>根据上述状态转移方程，可以写出时间复杂度为 O(n)和空间复杂度为 O(n) 的解法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> length = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果注意到第 <code>i</code> 天的最大收益只和第 <code>i - 1</code> 天的最大收益相关，空间复杂度可以降到 O(1)。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> profit0 = <span class="number">0</span>, profit1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> length = prices.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) {</span><br><span class="line">            profit0 = Math.max(profit0, profit1 + prices[i]);</span><br><span class="line">            profit1 = Math.max(profit1, -prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> profit0;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在对上述解法进行分析。对于循环中的部分，<code>profit1</code> 实际上只是表示到第 <code>i</code> 天的股票价格的相反数中的最大值，或者等价地表示到第 <code>i</code> 天的股票价格的最小值。对于 <code>profit0</code>，只需要决定卖出和休息中的哪项操作可以得到更高的收益。如果进行卖出操作，则买入股票的价格为 <code>profit1</code>，即第 i 天之前（不含第 <code>i</code> 天）的最低股票价格。这正是现实中为了获得最大收益会做的事情。但是这种做法不是唯一适用于这种情况的解决方案。读者可能在 这里 找到别的好的解决方案。</p>
<h4 id="情况二：k-为正无穷"><a href="#情况二：k-为正无穷" class="headerlink" title="情况二：k 为正无穷"></a><strong>情况二：k 为正无穷</strong></h4><p>情况二对应的题目是<strong>「122. 买卖股票的最佳时机 II」。</strong></p>
<p>如果 k 为正无穷，则 <code>k</code> 和 k - 1 可以看成是相同的，因此有 <code>T[i - 1][k - 1][0] = T[i - 1][k][0]</code> 和 <code>T[i - 1][k - 1][1] = T[i - 1][k][1]</code>。每天仍有两个未知变量：<code>T[i][k][0]</code> 和 <code>T[i][k][1]</code>，其中 <code>~k~</code> 为正无穷，状态转移方程如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] + prices[i])</span><br><span class="line">T[i][k][1] = max(T[i - 1][k][1], T[i - 1][k - 1][0] - prices[i]) = max(T[i - 1][k][1], T[i - 1][k][0] - prices[i])</span><br></pre></td></tr></tbody></table></figure>

<p>第二个状态转移方程利用了 <code>T[i - 1][k - 1][0] = T[i - 1][k][0]</code>。</p>
<p>根据上述状态转移方程，可以写出时间复杂度为 O(n) 和空间复杂度为 O(n) 的解法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> length = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果注意到第 <code>i</code> 天的最大收益只和第 <code>i - 1</code> 天的最大收益相关，空间复杂度可以降到 O(1)。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> profit0 = <span class="number">0</span>, profit1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> length = prices.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) {</span><br><span class="line">            <span class="keyword">int</span> newProfit0 = Math.max(profit0, profit1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> newProfit1 = Math.max(profit1, profit0 - prices[i]);</span><br><span class="line">            profit0 = newProfit0;</span><br><span class="line">            profit1 = newProfit1;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> profit0;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个解法提供了获得最大收益的贪心策略：可能的情况下，在每个局部最小值买入股票，然后在之后遇到的第一个局部最大值卖出股票。这个做法等价于找到股票价格数组中的递增子数组，对于每个递增子数组，在开始位置买入并在结束位置卖出。可以看到，这和累计收益是相同的，只要这样的操作的收益为正。</p>
<h4 id="情况三：k-2"><a href="#情况三：k-2" class="headerlink" title="情况三：k = 2"></a>情况三：k = 2</h4><p>情况三对应的题目是<strong>「123. 买卖股票的最佳时机 III」</strong>。</p>
<p>情况三和情况一相似，区别之处是，对于情况三，每天有四个未知变量：<code>T[i][1][0]、T[i][1][1]、T[i][2][0]、T[i][2][1]</code>，状态转移方程如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">T[i][2][0] = max(T[i - 1][2][0], T[i - 1][2][1] + prices[i])</span><br><span class="line">T[i][2][1] = max(T[i - 1][2][1], T[i - 1][1][0] - prices[i])</span><br><span class="line">T[i][1][0] = max(T[i - 1][1][0], T[i - 1][1][1] + prices[i])</span><br><span class="line">T[i][1][1] = max(T[i - 1][1][1], T[i - 1][0][0] - prices[i]) = max(T[i - 1][1][1], -prices[i])</span><br></pre></td></tr></tbody></table></figure>



<p>第四个状态转移方程利用了 <code>T[i][0][0] = 0</code>。</p>
<p>根据上述状态转移方程，可以写出时间复杂度为 O(n)和空间复杂度为 O(n)的解法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> length = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length][<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) {</span><br><span class="line">            dp[i][<span class="number">2</span>][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果注意到第 <code>i</code> 天的最大收益只和第 <code>i - 1</code> 天的最大收益相关，空间复杂度可以降到 O(1)。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> profitOne0 = <span class="number">0</span>, profitOne1 = -prices[<span class="number">0</span>], profitTwo0 = <span class="number">0</span>, profitTwo1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> length = prices.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) {</span><br><span class="line">            profitTwo0 = Math.max(profitTwo0, profitTwo1 + prices[i]);</span><br><span class="line">            profitTwo1 = Math.max(profitTwo1, profitOne0 - prices[i]);</span><br><span class="line">            profitOne0 = Math.max(profitOne0, profitOne1 + prices[i]);</span><br><span class="line">            profitOne1 = Math.max(profitOne1, -prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> profitTwo0;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="情况四：k-为任意值"><a href="#情况四：k-为任意值" class="headerlink" title="情况四：k 为任意值"></a>情况四：k 为任意值</h4><p>情况四对应的题目是<strong>「188. 买卖股票的最佳时机 IV」。</strong></p>
<p>情况四是最通用的情况，对于每一天需要使用不同的 <code>k</code> 值更新所有的最大收益，对应持有 0 份股票或 1 份股票。如果 <code>k</code> 超过一个临界值，最大收益就不再取决于允许的最大交易次数，而是取决于股票价格数组的长度，因此可以进行优化。那么这个临界值是什么呢？</p>
<p>一个有收益的交易至少需要两天（在前一天买入，在后一天卖出，前提是买入价格低于卖出价格）。如果股票价格数组的长度为 n，则有收益的交易的数量最多为 n / 2（整数除法）。因此 k 的临界值是 <code>n / 2</code>。如果给定的 k 不小于临界值，即 <code>k &gt;= n / 2</code>，则可以将 k 扩展为正无穷，此时问题等价于情况二。</p>
<p>根据状态转移方程，可以写出时间复杂度为 O(nk) 和空间复杂度为 O(nk) 的解法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> length = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= length / <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> maxProfit(prices);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length][k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) {</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &gt; <span class="number">0</span>; j--) {</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>][k][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> length = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果注意到第 <code>i</code> 天的最大收益只和第 <code>i - 1</code> 天的最大收益相关，空间复杂度可以降到 O(k)。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> length = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= length / <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> maxProfit(prices);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &gt; <span class="number">0</span>; j--) {</span><br><span class="line">                dp[j][<span class="number">0</span>] = Math.max(dp[j][<span class="number">0</span>], dp[j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[j][<span class="number">1</span>] = Math.max(dp[j][<span class="number">1</span>], dp[j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[k][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> profit0 = <span class="number">0</span>, profit1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> length = prices.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) {</span><br><span class="line">            <span class="keyword">int</span> newProfit0 = Math.max(profit0, profit1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> newProfit1 = Math.max(profit1, profit0 - prices[i]);</span><br><span class="line">            profit0 = newProfit0;</span><br><span class="line">            profit1 = newProfit1;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> profit0;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果不根据 <code>k</code> 的值进行优化，在 <code>k</code> 的值很大的时候会超出时间限制。</p>
<p>该解法与 <a href="https://discuss.leetcode.com/topic/8984/a-concise-dp-solution-in-java" target="_blank" rel="noopener">这里</a> 的解法相似。对交易次数的循环使用反向循环是为了避免使用临时变量。</p>
<h4 id="情况五：k-为正无穷但有冷却时间"><a href="#情况五：k-为正无穷但有冷却时间" class="headerlink" title="情况五：k 为正无穷但有冷却时间"></a>情况五：k 为正无穷但有冷却时间</h4><p>情况五对应的题目是<strong>「309. 最佳买卖股票时机含冷冻期」。</strong></p>
<p>由于具有相同的 <code>k</code> 值，因此情况五和情况二非常相似，不同之处在于情况五有「冷却时间」的限制，因此需要对状态转移方程进行一些修改。</p>
<p>情况二的状态转移方程如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] + prices[i])</span><br><span class="line">T[i][k][1] = max(T[i - 1][k][1], T[i - 1][k][0] - prices[i])</span><br></pre></td></tr></tbody></table></figure>

<p>但是在有「冷却时间」的情况下，如果在第 <code>i - 1</code> 天卖出了股票，就不能在第 i 天买入股票。因此，如果要在第 i 天买入股票，第二个状态转移方程中就不能使用 <code>T[i - 1][k][0]</code>，而应该使用 <code>T[i - 2][k][0]</code>。状态转移方程中的别的项保持不变，新的状态转移方程如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] + prices[i])</span><br><span class="line">T[i][k][1] = max(T[i - 1][k][1], T[i - 2][k][0] - prices[i])</span><br></pre></td></tr></tbody></table></figure>

<p>根据上述状态转移方程，可以写出时间复杂度为 O(n) 和空间复杂度为 O(n)的解法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> length = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>][<span class="number">0</span>] : <span class="number">0</span>) - prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果注意到第 <code>i</code> 天的最大收益只和第 <code>i - 1</code> 天和第 <code>i - 2</code> 天的最大收益相关，空间复杂度可以降到 O(1)。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> prevProfit0 = <span class="number">0</span>, profit0 = <span class="number">0</span>, profit1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> length = prices.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) {</span><br><span class="line">            <span class="keyword">int</span> nextProfit0 = Math.max(profit0, profit1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> nextProfit1 = Math.max(profit1, prevProfit0 - prices[i]);</span><br><span class="line">            prevProfit0 = profit0;</span><br><span class="line">            profit0 = nextProfit0;</span><br><span class="line">            profit1 = nextProfit1;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> profit0;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><a href="https://leetcode.com/dietpepsi" target="_blank" rel="noopener">dietpepsi</a> 在 <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75927/share-my-thinking-process" target="_blank" rel="noopener">这里</a> 分享了一个很好的解法，并加入了思考过程，该解法和上面的解法是相同的。</p>
<h4 id="情况六：k-为正无穷但有手续费"><a href="#情况六：k-为正无穷但有手续费" class="headerlink" title="情况六：k 为正无穷但有手续费"></a>情况六：k 为正无穷但有手续费</h4><p>情况六对应的题目是<strong>「714. 买卖股票的最佳时机含手续费」。</strong></p>
<p>由于具有相同的 <code>k</code> 值，因此情况六和情况二非常相似，不同之处在于情况六有「手续费」，因此需要对状态转移方程进行一些修改。</p>
<p>情况二的状态转移方程如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] + prices[i])</span><br><span class="line">T[i][k][1] = max(T[i - 1][k][1], T[i - 1][k][0] - prices[i])</span><br></pre></td></tr></tbody></table></figure>

<p>由于需要对每次交易付手续费，因此在每次买入或卖出股票之后的收益需要扣除手续费，新的状态转移方程有两种表示方法。</p>
<p>第一种表示方法，在每次买入股票时扣除手续费：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] + prices[i])</span><br><span class="line">T[i][k][1] = max(T[i - 1][k][1], T[i - 1][k][0] - prices[i] - fee)</span><br></pre></td></tr></tbody></table></figure>

<p>第二种表示方法，在每次卖出股票时扣除手续费：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] + prices[i] - fee)</span><br><span class="line">T[i][k][1] = max(T[i - 1][k][1], T[i - 1][k][0] - prices[i])</span><br></pre></td></tr></tbody></table></figure>

<p>根据上述状态转移方程，可以写出时间复杂度为 O(n) 和空间复杂度为 O(n)的解法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> length = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>] - fee;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i] - fee);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果注意到第 <code>i</code> 天的最大收益只和第 <code>i - 1</code> 天的最大收益相关，空间复杂度可以降到 O(1)。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> profit0 = <span class="number">0</span>, profit1 = -prices[<span class="number">0</span>] - fee;</span><br><span class="line">        <span class="keyword">int</span> length = prices.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) {</span><br><span class="line">            <span class="keyword">int</span> newProfit0 = Math.max(profit0, profit1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> newProfit1 = Math.max(profit1, profit0 - prices[i] - fee);</span><br><span class="line">            profit0 = newProfit0;</span><br><span class="line">            profit1 = newProfit1;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> profit0;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> profit0 = <span class="number">0</span>, profit1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> length = prices.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) {</span><br><span class="line">            <span class="keyword">int</span> newProfit0 = Math.max(profit0, profit1 + prices[i] - fee);</span><br><span class="line">            <span class="keyword">int</span> newProfit1 = Math.max(profit1, profit0 - prices[i]);</span><br><span class="line">            profit0 = newProfit0;</span><br><span class="line">            profit1 = newProfit1;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> profit0;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁三、总结"><a href="#🍁三、总结" class="headerlink" title="🍁三、总结"></a>🍁三、总结</h3><p>总而言之，股票问题最通用的情况由三个特征决定：当前的天数 <code>i</code>、允许的最大交易次数 <code>k</code> 以及每天结束时持有的股票数。这篇文章阐述了最大利润的状态转移方程和终止条件，由此可以得到时间复杂度为 O(nk) 和空间复杂度为 O(k) 的解法。该解法可以应用于六个问题，对于最后两个问题，需要将状态转移方程进行一些修改。这里推荐 <a href="https://leetcode.com/peterleetcode/" target="_blank" rel="noopener">peterleetcode</a> 的 <a href="https://discuss.leetcode.com/topic/4766/a-clean-dp-solution-which-generalizes-to-k-transactions" target="_blank" rel="noopener">解法</a>，该解法可以推广到任意的 <code>k</code> 值，感兴趣的读者可以进行阅读。</p>
<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>股票问题</tag>
        <tag>动态规划的优化</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划_leetcode.121.买卖股票的最佳时期</title>
    <url>/The_best_time_to_buy_and_sell_stocks/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<a id="more"></a>

<p>示例 1:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></tbody></table></figure>


<p>示例 2:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0</span><br></pre></td></tr></tbody></table></figure>

<h2 id="解法一：暴力解法"><a href="#解法一：暴力解法" class="headerlink" title="解法一：暴力解法"></a>解法一：暴力解法</h2><blockquote>
<p>暴力求解，不解释。</p>
<p>枚举所有发生一次交易的股价差</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> len = prices.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有可能不发生交易，因此结果集的初始值设置为 0</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举所有发生一次交易的股价差</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) {</span><br><span class="line">            res = Math.max(res, prices[j] - prices[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h2><p>题目只问最大利润，没有问这几天具体哪一天买、哪一天卖，因此可以考虑使用 动态规划 的方法来解决。</p>
<p>买卖股票有约束，根据题目意思，有以下两个约束条件：</p>
<ul>
<li>条件 1：你不能在买入股票前卖出股票；</li>
<li>条件 2：最多只允许完成一笔交易。</li>
</ul>
<p>因此 <strong>当天是否持股</strong> 是一个很重要的因素，而当前是否持股和昨天是否持股有关系，为此我们需要把 <strong>是否持股</strong> 设计到状态数组中。</p>
<p><strong>状态定义：</strong></p>
<p><code>dp[i] [j]</code>：下标为 <code>i</code> 这一天结束的时候，手上持股状态为 j 时，我们持有的现金数。</p>
<ul>
<li>j = 0，表示当前不持股；</li>
<li>j = 1，表示当前持股。</li>
</ul>
<p><strong>注意</strong>：这个状态具有前缀性质，下标为 i 的这一天的计算结果包含了区间 [0, i] 所有的信息，因此最后输出 dp[len - 1] [0]。</p>
<p><strong>说明：</strong></p>
<ul>
<li>使用「现金数」这个说法主要是为了体现 买入股票手上的现金数减少，卖出股票手上的现金数增加 这个事实；</li>
<li>「现金数」等价于题目中说的「利润」，即先买入这只股票，后买入这只股票的差价；</li>
<li>因此在刚开始的时候，我们的手上肯定是有一定现金数能够买入这只股票，即刚开始的时候现金数肯定不为 00，但是写代码的时候可以设置为 0。极端情况下（股价数组为 [5, 4, 3, 2, 1]），此时不发生交易是最好的（这一点是补充说明，限于我的表达，希望不要给大家造成迷惑）。</li>
</ul>
<p><strong>推导状态转移方程：</strong></p>
<p>dp[i] [0]：规定了今天不持股，有以下两种情况：</p>
<ul>
<li><p>昨天不持股，今天什么都不做；</p>
</li>
<li><p>昨天持股，今天卖出股票（现金数增加），<br>dp[i] [1]：规定了今天持股，有以下两种情况：</p>
</li>
<li><p>昨天持股，今天什么都不做（现金数增加）；</p>
</li>
<li><p>昨天不持股，今天买入股票（注意：只允许交易一次，因此手上的现金数就是当天的股价的相反数）。<br>状态转移方程请见 参考代码 2。</p>
</li>
</ul>
<p>知识点：</p>
<ul>
<li>多阶段决策问题：动态规划常常用于求解多阶段决策问题；</li>
<li>无后效性：每一天是否持股设计成状态变量的一维。状态设置具体，推导状态转移方程方便</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="comment">// 特殊判断</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][0] 下标为 i 这天结束的时候，不持股，手上拥有的现金数</span></span><br><span class="line">        <span class="comment">// dp[i][1] 下标为 i 这天结束的时候，持股，手上拥有的现金数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化：不持股显然为 0，持股就需要减去第 1 天（下标为 0）的股价</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第 2 天开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="解法三：-滚动数组优化"><a href="#解法三：-滚动数组优化" class="headerlink" title="解法三： 滚动数组优化"></a>解法三： 滚动数组优化</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>java</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) {</span><br><span class="line">            dp[i % <span class="number">2</span>][<span class="number">0</span>] = Math.max(dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>], dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i % <span class="number">2</span>][<span class="number">1</span>] = Math.max(dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[(len - <span class="number">1</span>) &amp; <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>% 2</code> 还可以写成 <code>&amp; 1</code>，这里为了保证可读性，选用 <code>% 2</code>。</p>
<h2 id="解法四：-空间优化"><a href="#解法四：-空间优化" class="headerlink" title="解法四： 空间优化"></a>解法四： 空间优化</h2><p>空间优化只看状态转移方程。</p>
<p>状态转移方程里下标为 i 的行只参考下标为 i - 1 的行（即只参考上一行），并且：</p>
<ul>
<li>下标为 i 的行并且状态为 0 的行参考了上一行状态为 0 和 1 的行；</li>
<li>下标为 i 的行并且状态为 1 的行只参考了上一行状态为 1 的行。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) {</span><br><span class="line">            dp[<span class="number">0</span>] = Math.max(dp[<span class="number">0</span>], dp[<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[<span class="number">1</span>] = Math.max(dp[<span class="number">1</span>], -prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>暴力解法</tag>
        <tag>滚动数组</tag>
        <tag>常数优化</tag>
      </tags>
  </entry>
  <entry>
    <title>高级树_LeetCode.327_区间和的个数</title>
    <url>/The_number_of_interval_sums/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给定一个整数数组 nums，返回区间和在 [lower, upper] 之间的个数，包含 lower 和 upper。<br>区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。</p>
<p>说明:<br>最直观的算法复杂度是 O(n2) ，请在此基础上优化你的算法。</p>
<a id="more"></a>

<p>示例:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [-2,5,-1], lower = -2, upper = 2,</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 3个区间分别是: [0,0], [2,2], [0,2]，它们表示的和分别为: -2, -1, 2。</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸解法一：归并排序"><a href="#🌸解法一：归并排序" class="headerlink" title="🌸解法一：归并排序"></a>🌸解法一：归并排序</h2><p>设前缀和数组为 $\textit{preSum}$，则问题等价于求所有的下标对(<em>i</em>,<em>j</em>)，满足</p>
<p><em>preSum</em>[<em>j</em>]−<em>preSum</em>[<em>i</em>]∈[<em>lower</em>,<em>upper</em>]</p>
<p><code>我们先考虑如下的问题</code>：给定两个<strong>升序排列</strong>的数组 n1,<em>n</em>2，试找出所有的下标对 (i,j)，满足<em>n</em>2[<em>j</em>]−<em>n</em>1[<em>i</em>]∈[<em>lower</em>,<em>upper</em>]</p>
<p>在已知两个数组均为升序的情况下，这一问题是相对简单的：我们在 n2中维护两个指针 l,r。起初，它们都指向 n 2 的起始位置。随后，我们考察 n 1 的第一个元素。首先，不断地将指针 l 向右移动，直到$$ n_2[l] \ge n_1[0] + \textit{lower}$$为止，此时， ll 及其右边的元素均大于或等于 $n_1[0] + \textit{lower}$；随后，再不断地将指针 r 向右移动，直到 $n_2[r] &gt; n_1[0] + \textit{upper}$为止，则 r左边的元素均小于或等于 $n_1[0] + \textit{upper}$,故区间 [l,r) 中的所有下标 j，都满足<em>n</em>2[<em>j</em>]−<em>n</em>1[0]∈[<em>lower</em>,<em>upper</em>]</p>
<p>接下来，我们考察 n 1 的第二个元素。由于n1 是递增的，不难发现 l,r 只可能向右移动。因此，我们不断地进行上述过程，并对于 n 1中的每一个下标，都记录相应的区间 [l,r) 的大小。最终，我们就统计得到了满足条件的下标对 (i,j) 的数量。</p>
<p>在解决这一问题后，原问题就迎刃而解了：我们采用归并排序的方式，能够得到左右两个数组排序后的形式，以及对应的下标对数量。对于原数组而言，若要找出全部的下标对数量，只需要再额外找出左端点在左侧数组，同时右端点在右侧数组的下标对数量，而这正是我们此前讨论的问题。</p>
<p>代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRangeSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span>[] sum = <span class="keyword">new</span> <span class="keyword">long</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) {</span><br><span class="line">            s += nums[i];</span><br><span class="line">            sum[i + <span class="number">1</span>] = s;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> countRangeSumRecursive(sum, lower, upper, <span class="number">0</span>, sum.length - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRangeSumRecursive</span><span class="params">(<span class="keyword">long</span>[] sum, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (left == right) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> n1 = countRangeSumRecursive(sum, lower, upper, left, mid);</span><br><span class="line">            <span class="keyword">int</span> n2 = countRangeSumRecursive(sum, lower, upper, mid + <span class="number">1</span>, right);</span><br><span class="line">            <span class="keyword">int</span> ret = n1 + n2;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首先统计下标对的数量</span></span><br><span class="line">            <span class="keyword">int</span> i = left;</span><br><span class="line">            <span class="keyword">int</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= mid) {</span><br><span class="line">                <span class="keyword">while</span> (l &lt;= right &amp;&amp; sum[l] - sum[i] &lt; lower) {</span><br><span class="line">                    l++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">while</span> (r &lt;= right &amp;&amp; sum[r] - sum[i] &lt;= upper) {</span><br><span class="line">                    r++;</span><br><span class="line">                }</span><br><span class="line">                ret += r - l;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 随后合并两个排序数组</span></span><br><span class="line">            <span class="keyword">int</span>[] sorted = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> p1 = left, p2 = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt;= mid || p2 &lt;= right) {</span><br><span class="line">                <span class="keyword">if</span> (p1 &gt; mid) {</span><br><span class="line">                    sorted[p++] = (<span class="keyword">int</span>) sum[p2++];</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (p2 &gt; right) {</span><br><span class="line">                    sorted[p++] = (<span class="keyword">int</span>) sum[p1++];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">if</span> (sum[p1] &lt; sum[p2]) {</span><br><span class="line">                        sorted[p++] = (<span class="keyword">int</span>) sum[p1++];</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        sorted[p++] = (<span class="keyword">int</span>) sum[p2++];</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sorted.length; j++) {</span><br><span class="line">                sum[left + j] = sorted[j];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸解法二：线段树"><a href="#🌸解法二：线段树" class="headerlink" title="🌸解法二：线段树"></a>🌸解法二：线段树</h2><p>依然考虑前缀和数组$ \textit{preSum}$</p>
<p>对于每个下标 j，以 j 为右端点的下标对的数量，就等于数组 $\textit{preSum}$[0..j-1] 中的所有整数，出现在区间$ [\textit{preSum}[j]-\textit{upper}, \textit{preSum}[j]-\textit{lower}]$ 的次数。故很容易想到基于线段树的解法。</p>
<p>我们从左到右扫描前缀和数组。每遇到一个数$ \textit{preSum}[j]$，我们就在线段树中查询区间$ [\textit{preSum}[j]-\textit{upper}, \textit{preSum}[j]-\textit{lower}]$内的整数数量，随后，将 $\textit{preSum}[j]$ 插入到线段树当中。</p>
<p>注意到整数的范围可能很大，故需要利用哈希表将所有可能出现的整数，映射到连续的整数区间内。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRangeSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span>[] preSum = <span class="keyword">new</span> <span class="keyword">long</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) {</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            preSum[i + <span class="number">1</span>] = sum;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        Set&lt;Long&gt; allNumbers = <span class="keyword">new</span> TreeSet&lt;Long&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> x : preSum) {</span><br><span class="line">            allNumbers.add(x);</span><br><span class="line">            allNumbers.add(x - lower);</span><br><span class="line">            allNumbers.add(x - upper);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 利用哈希表进行离散化</span></span><br><span class="line">        Map&lt;Long, Integer&gt; values = <span class="keyword">new</span> HashMap&lt;Long, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> x : allNumbers) {</span><br><span class="line">            values.put(x, idx);</span><br><span class="line">            idx++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        SegNode root = build(<span class="number">0</span>, values.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> x : preSum) {</span><br><span class="line">            <span class="keyword">int</span> left = values.get(x - upper), right = values.get(x - lower);</span><br><span class="line">            ret += count(root, left, right);</span><br><span class="line">            insert(root, values.get(x));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SegNode <span class="title">build</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">        SegNode node = <span class="keyword">new</span> SegNode(left, right);</span><br><span class="line">        <span class="keyword">if</span> (left == right) {</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        node.lchild = build(left, mid);</span><br><span class="line">        node.rchild = build(mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(SegNode root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (left &gt; root.hi || right &lt; root.lo) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= root.lo &amp;&amp; root.hi &lt;= right) {</span><br><span class="line">            <span class="keyword">return</span> root.add;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count(root.lchild, left, right) + count(root.rchild, left, right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(SegNode root, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        root.add++;</span><br><span class="line">        <span class="keyword">if</span> (root.lo == root.hi) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> mid = (root.lo + root.hi) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (val &lt;= mid) {</span><br><span class="line">            insert(root.lchild, val);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            insert(root.rchild, val);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegNode</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> lo, hi, add;</span><br><span class="line">    SegNode lchild, rchild;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SegNode</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">        lo = left;</span><br><span class="line">        hi = right;</span><br><span class="line">        add = <span class="number">0</span>;</span><br><span class="line">        lchild = <span class="keyword">null</span>;</span><br><span class="line">        rchild = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸解法三：动态增加节点的线段树"><a href="#🌸解法三：动态增加节点的线段树" class="headerlink" title="🌸解法三：动态增加节点的线段树"></a>🌸解法三：动态增加节点的线段树</h2><p>与方法二类似，但我们可以不实用哈希表进行映射，而是只在线段树的插入操作过程中动态地增加树中的节点。而当我们进行查询操作时，如果到达一个空节点，那么说明对应的区间中暂时还没有值，就可以直接返回 0。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRangeSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span>[] preSum = <span class="keyword">new</span> <span class="keyword">long</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) {</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            preSum[i + <span class="number">1</span>] = sum;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> lbound = Long.MAX_VALUE, rbound = Long.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> x : preSum) {</span><br><span class="line">            lbound = Math.min(Math.min(lbound, x), Math.min(x - lower, x - upper));</span><br><span class="line">            rbound = Math.max(Math.max(rbound, x), Math.max(x - lower, x - upper));</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        SegNode root = <span class="keyword">new</span> SegNode(lbound, rbound);</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> x : preSum) {</span><br><span class="line">            ret += count(root, x - upper, x - lower);</span><br><span class="line">            insert(root, x);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(SegNode root, <span class="keyword">long</span> left, <span class="keyword">long</span> right)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (left &gt; root.hi || right &lt; root.lo) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= root.lo &amp;&amp; root.hi &lt;= right) {</span><br><span class="line">            <span class="keyword">return</span> root.add;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count(root.lchild, left, right) + count(root.rchild, left, right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(SegNode root, <span class="keyword">long</span> val)</span> </span>{</span><br><span class="line">        root.add++;</span><br><span class="line">        <span class="keyword">if</span> (root.lo == root.hi) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">long</span> mid = (root.lo + root.hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (val &lt;= mid) {</span><br><span class="line">            <span class="keyword">if</span> (root.lchild == <span class="keyword">null</span>) {</span><br><span class="line">                root.lchild = <span class="keyword">new</span> SegNode(root.lo, mid);</span><br><span class="line">            }</span><br><span class="line">            insert(root.lchild, val);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (root.rchild == <span class="keyword">null</span>) {</span><br><span class="line">                root.rchild = <span class="keyword">new</span> SegNode(mid + <span class="number">1</span>, root.hi);</span><br><span class="line">            }</span><br><span class="line">            insert(root.rchild, val);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegNode</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> lo, hi;</span><br><span class="line">    <span class="keyword">int</span> add;</span><br><span class="line">    SegNode lchild, rchild;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SegNode</span><span class="params">(<span class="keyword">long</span> left, <span class="keyword">long</span> right)</span> </span>{</span><br><span class="line">        lo = left;</span><br><span class="line">        hi = right;</span><br><span class="line">        add = <span class="number">0</span>;</span><br><span class="line">        lchild = <span class="keyword">null</span>;</span><br><span class="line">        rchild = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸解法四：树状数组"><a href="#🌸解法四：树状数组" class="headerlink" title="🌸解法四：树状数组"></a>🌸解法四：树状数组</h2><p>树状数组与线段树基于类似的思想，不过树状数组支持的基本查询为求出 $[0, \textit{val}]$ 之间的整数数量。为了查询区间$ [\textit{preSum}[j]-\textit{upper}, \textit{preSum}[j]-\textit{lower}]$内的整数数量，需要执行两次查询，即分别查询 $[0, \textit{preSum}[j]-\textit{upper}-1]$ 区间的整数数量 L 和$[0,\textit{preSum}[j]-\textit{lower}]$ 区间的整数数量 R，答案即为两者作差 R-L。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRangeSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span>[] preSum = <span class="keyword">new</span> <span class="keyword">long</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) {</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            preSum[i + <span class="number">1</span>] = sum;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        Set&lt;Long&gt; allNumbers = <span class="keyword">new</span> TreeSet&lt;Long&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> x : preSum) {</span><br><span class="line">            allNumbers.add(x);</span><br><span class="line">            allNumbers.add(x - lower);</span><br><span class="line">            allNumbers.add(x - upper);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 利用哈希表进行离散化</span></span><br><span class="line">        Map&lt;Long, Integer&gt; values = <span class="keyword">new</span> HashMap&lt;Long, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> x: allNumbers) {</span><br><span class="line">            values.put(x, idx);</span><br><span class="line">            idx++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        BIT bit = <span class="keyword">new</span> BIT(values.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; preSum.length; i++) {</span><br><span class="line">            <span class="keyword">int</span> left = values.get(preSum[i] - upper), right = values.get(preSum[i] - lower);</span><br><span class="line">            ret += bit.query(right + <span class="number">1</span>) - bit.query(left);</span><br><span class="line">            bit.update(values.get(preSum[i]) + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] tree;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BIT</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.tree = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n) {</span><br><span class="line">            tree[x] += d;</span><br><span class="line">            x += lowbit(x);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) {</span><br><span class="line">            ans += tree[x];</span><br><span class="line">            x -= lowbit(x);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸解法五：平衡二叉搜索树"><a href="#🌸解法五：平衡二叉搜索树" class="headerlink" title="🌸解法五：平衡二叉搜索树"></a>🌸解法五：平衡二叉搜索树</h2><p>考虑一棵平衡二叉搜索树。若其节点数量为 N，则深度为 O(log N)。二叉搜索树能够在 O(logN) 的时间内，对任意给定的值 $\textit{val}$,查询树中所有小于或等于该值的数量。</p>
<p>因此，我们可以从左到右扫描前缀和数组。对于$ \textit{preSum}[j]$ 而言，首先进行两次查询，得到区间 $[\textit{preSum}[j]-\textit{upper}, \textit{preSum}[j]-\textit{lower}]$内的整数数量；随后再将 $\textit{preSum}[j]$ 插入到平衡树中。</p>
<p>平衡二叉搜索树有多种不同的实现，最经典的为 AVL 树与红黑树。此外，在算法竞赛中，还包括 Treap、SBT 等数据结构。</p>
<p>下面给出基于 Treap 的实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRangeSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span>[] preSum = <span class="keyword">new</span> <span class="keyword">long</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) {</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            preSum[i + <span class="number">1</span>] = sum;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        BalancedTree treap = <span class="keyword">new</span> BalancedTree();</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> x : preSum) {</span><br><span class="line">            <span class="keyword">long</span> numLeft = treap.lowerBound(x - upper);</span><br><span class="line">            <span class="keyword">int</span> rankLeft = (numLeft == Long.MAX_VALUE ? (<span class="keyword">int</span>) (treap.getSize() + <span class="number">1</span>) : treap.rank(numLeft)[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">long</span> numRight = treap.upperBound(x - lower);</span><br><span class="line">            <span class="keyword">int</span> rankRight = (numRight == Long.MAX_VALUE ? (<span class="keyword">int</span>) treap.getSize() : treap.rank(numRight)[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">            ret += rankRight - rankLeft + <span class="number">1</span>;</span><br><span class="line">            treap.insert(x);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BalancedTree</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BalancedNode</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> val;</span><br><span class="line">        <span class="keyword">long</span> seed;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        BalancedNode left;</span><br><span class="line">        BalancedNode right;</span><br><span class="line"></span><br><span class="line">        BalancedNode(<span class="keyword">long</span> val, <span class="keyword">long</span> seed) {</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.seed = seed;</span><br><span class="line">            <span class="keyword">this</span>.count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.size = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function">BalancedNode <span class="title">leftRotate</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">int</span> prevSize = size;</span><br><span class="line">            <span class="keyword">int</span> currSize = (left != <span class="keyword">null</span> ? left.size : <span class="number">0</span>) + (right.left != <span class="keyword">null</span> ? right.left.size : <span class="number">0</span>) + count;</span><br><span class="line">            BalancedNode root = right;</span><br><span class="line">            right = root.left;</span><br><span class="line">            root.left = <span class="keyword">this</span>;</span><br><span class="line">            root.size = prevSize;</span><br><span class="line">            size = currSize;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function">BalancedNode <span class="title">rightRotate</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">int</span> prevSize = size;</span><br><span class="line">            <span class="keyword">int</span> currSize = (right != <span class="keyword">null</span> ? right.size : <span class="number">0</span>) + (left.right != <span class="keyword">null</span> ? left.right.size : <span class="number">0</span>) + count;</span><br><span class="line">            BalancedNode root = left;</span><br><span class="line">            left = root.right;</span><br><span class="line">            root.right = <span class="keyword">this</span>;</span><br><span class="line">            root.size = prevSize;</span><br><span class="line">            size = currSize;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BalancedNode root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Random rand;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BalancedTree</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.rand = <span class="keyword">new</span> Random();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> x)</span> </span>{</span><br><span class="line">        ++size;</span><br><span class="line">        root = insert(root, x);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lowerBound</span><span class="params">(<span class="keyword">long</span> x)</span> </span>{</span><br><span class="line">        BalancedNode node = root;</span><br><span class="line">        <span class="keyword">long</span> ans = Long.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (x == node.val) {</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (x &lt; node.val) {</span><br><span class="line">                ans = node.val;</span><br><span class="line">                node = node.left;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                node = node.right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">upperBound</span><span class="params">(<span class="keyword">long</span> x)</span> </span>{</span><br><span class="line">        BalancedNode node = root;</span><br><span class="line">        <span class="keyword">long</span> ans = Long.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (x &lt; node.val) {</span><br><span class="line">                ans = node.val;</span><br><span class="line">                node = node.left;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                node = node.right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] rank(<span class="keyword">long</span> x) {</span><br><span class="line">        BalancedNode node = root;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (x &lt; node.val) {</span><br><span class="line">                node = node.left;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                ans += (node.left != <span class="keyword">null</span> ? node.left.size : <span class="number">0</span>) + node.count;</span><br><span class="line">                <span class="keyword">if</span> (x == node.val) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{ans - node.count + <span class="number">1</span>, ans};</span><br><span class="line">                }</span><br><span class="line">                node = node.right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{Integer.MIN_VALUE, Integer.MAX_VALUE};</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> BalancedNode <span class="title">insert</span><span class="params">(BalancedNode node, <span class="keyword">long</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BalancedNode(x, rand.nextInt());</span><br><span class="line">        }</span><br><span class="line">        ++node.size;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; node.val) {</span><br><span class="line">            node.left = insert(node.left, x);</span><br><span class="line">            <span class="keyword">if</span> (node.left.seed &gt; node.seed) {</span><br><span class="line">                node = node.rightRotate();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; node.val) {</span><br><span class="line">            node.right = insert(node.right, x);</span><br><span class="line">            <span class="keyword">if</span> (node.right.seed &gt; node.seed) {</span><br><span class="line">                node = node.leftRotate();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            ++node.count;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸解法一说明：为什么可以归并"><a href="#🌸解法一说明：为什么可以归并" class="headerlink" title="🌸解法一说明：为什么可以归并"></a>🌸解法一说明：为什么可以归并</h2><p>看完后我明白如果数组是有序的，那么可以容易的求出区间数量，那么为什么对数组排序前后所求的区间数量不会改变呢，下面我来说明一下（官方并没有实际说明这一点）</p>
<p><strong>初始归并：</strong><br>此时只会有0或1个元素，不涉及左右两段的情况，是可以的</p>
<p><strong>合并归并：</strong>此时是有左右两段的，左右两段是分别有序的，<strong>对前缀和数组排序并不会修改数组中元素的值，只是改变了元素是位置，如对left ~ right=3~5位置的前缀和排序，排序后前缀和3 ~ 5位置的数还是原来3 ~ 5位置的数，只是排列变化了</strong></p>
<p>设想一个一般的情况，现在是某一层的递归，左，右两段区间left ~ mid, mid+1 ~ right的符合要求的区间数量已经通过countRangeSumRecursive计算了出来，整个left ~ right区间中可能的符合要求的区间情况是两端点在left ~ mid中；两端点在mid+1 ~ right；一个端点在left~ mid中，一个端点在mid+1~ right中，所以现在只要求出第三种情况的区间数量就可以了<br>通过上面的说明，left ~ mid,mid+1~ right区间中的数还是原来区间中的数，只是顺序变成了有序，而有序是容易计算符合要求的区间数量的，一个图说明为什么第三种情况排序前后符合数量的区间数量是不变的</p>
<h2 id="🌸指路：如何学习本题的算法和数据结构"><a href="#🌸指路：如何学习本题的算法和数据结构" class="headerlink" title="🌸指路：如何学习本题的算法和数据结构"></a>🌸指路：如何学习本题的算法和数据结构</h2><p>忽略官方题解中的方法一，剩余的四种方法分别使用了线段树、树状数组和平衡树。这些方法都不是面试的考点，甚至在笔试中也很少出现，所以大部分读者应该是完全不知道这些都是啥神奇的数据结构的。所以我觉得这里有必要补充以下两点：</p>
<ul>
<li>这道题需要哪些接口。</li>
<li>上面的这些神奇的数据结构可以提供哪些接口。</li>
</ul>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定数组 A，它的长度为 n，对应的元素以及下标为A[0],A[1],⋯,A[n−1]。</p>
<p>令 S(i,j) 为A[i] 到 A[j] 的和，即</p>
<p>$S(i, j) = \sum_{k=i}^j A[k]$</p>
<p>题目需要求出满足$ \textit{lower} \leq S(i, j) \leq \textit{upper}$ 的二元组 (i, j)(i,j) 的个数。</p>
<p>换成人话就是，问数组 A 有多少个连续的子数组，其元素只和在 $[\textit{lower}, \textit{upper}]$ 的范围内。</p>
<h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>暴力的做法是使用前缀和。令 P 为 A 的前缀和数组，那么</p>
<p>S(i, j) = P[j] - P[i-1]</p>
<p>可以在O(1) 的时间求出。这里我们规定边界 P[-1] = 0。</p>
<p>这样一来，我们枚举所有的二元组 (i, j)，算出S(i,j) 并判断其是否在范围内即可。时间复杂度为$ O(n^2)$。</p>
<p>那么怎么进行优化呢？我们考虑从小到大枚举 j，由于</p>
<p>$\textit{lower} \leq P[j] - P[i-1] \leq \textit{upper}$</p>
<p>我们可以得到 P[i-1] 应该满足的不等式</p>
<p>$P[j] - \textit{upper} \leq P[i-1] \leq P[j] - \textit{lower}$</p>
<p>因此本质上，我们需要一个数据结构支持下面的两个操作：</p>
<p>操作 1「查询」：给定一个范围 $[\textit{left}, \textit{right}]$，查询数据结构中在该范围内的元素个数。对应到本题中，我们给定的范围就是$ \big[P[j] - \textit{upper}, P[j] - \textit{lower}\big]$；</p>
<p>操作 2「更新」：给定一个元素 xx，我们需要把它添加到数据结构中。对应到本题中，我们给定的元素就是 P[j]。</p>
<p>如果有了这样一个数据结构，我们就可以很方便地做出本题：</p>
<p>我们首先将 00 放入数据结构中，随后我们从小到大枚举 j，查询 $\big[P[j] - \textit{upper}, P[j] - \textit{lower}\big]$ 范围内的元素个数并计入答案。在查询完成之后，我们将P[j] 添加进数据结构，就可以进行下一次枚举。</p>
<h3 id="频数数组"><a href="#频数数组" class="headerlink" title="频数数组"></a>频数数组</h3><p>很多数据结构都是基于「频数数组」。</p>
<p>给定数组 t 以及它的下标范围 [L, R][L,R]，t[x] 就表示元素 x 在数据结构中的出现次数。基于此，上述的两个操作可以变为：</p>
<p>操作 1「查询」：给定一个范围$ [\textit{left}, \textit{right}]$，查询$ t[\textit{left}]$到 $t[\textit{right}]$ 的和；</p>
<p>操作 2「更新」：给定一个元素 x，将 t[x] 增加 1。</p>
<p>这也是线段树和树状数组的基础，它们需要的空间都与数组 t 的下标范围 [L, R][L,R] 正相关。在本题数据规模较大的情况下（例如测试数据中，出现了元素值达到 32 位有符号整数的上下界），线段树和树状数组都会超出空间限制，因此需要借助「离散化」操作，将这些元素映射到一个较小规模的区间内。</p>
<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>给定数组元素 [1, 22, 333, 4444, 55555]，如果我们只关注它们之间的大小关系，那么该数组其实和 [1, 2, 3, 4, 5] 是等价的。</p>
<p>这就是离散化的技巧。我们将所有会涉及到比较操作的数全部放入一个列表中，进行排序，再从小到大依次给它们赋予一个新的值。在离散化完成后，任何两个数之间的相对大小都不会改变，但是元素的上下界范围被限制住，这使得我们可以方便地使用一些数据结构。</p>
<p>在本题中，我们可以将所有的 $P[j], P[j] - \textit{upper}, P[j] - \textit{lower}$一起进行离散化，并将它们从小到大，依次赋予一个从 1 开始的整数值。这样一来，我们所有涉及到的元素值都会在 [1, 3(n+1)]的范围内。</p>
<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>当我们将元素离散化后，就可以直接使用线段树了。最基础的线段树恰好就支持这两种操作：</p>
<p>操作 1「查询」：给定一个范围$ [\textit{left}, \textit{right}]$,查询$ t[\textit{left}] $到 $t[\textit{right}]$ 的和；</p>
<p>操作 2「更新」：给定一个元素 x，将 t[x] 增加 $\delta$。</p>
<p>我们只需要时刻令$\delta$=1即可。两种操作的时间复杂度均为$ O(\log n)$</p>
<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p>当我们将元素离散化后，也可以直接使用树状数组了。最基础的线段树支持这两种操作：</p>
<p>操作 1「查询」：给定一个下标$ \textit{right}$，查询 t[1] 到$ t[\textit{right}]$ 的和（即前缀和）；</p>
<p>操作 2「更新」：给定一个元素 x，将t[x] 增加 $\deltaδ$。</p>
<p>我们只需要时刻令 $\delta=1$ 即可，并且通过调用操作 1 两次（即 $\textit{right}$ 和$ \textit{left}-1left−1）相减得到 t[\textit{left}]$ 到 $t[\textit{right}]$ 的和。两种操作的时间复杂度均为 $O(\log n)$。</p>
<h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><p>平衡树实际上就是「平衡」的二叉搜索树，它与线段树和树状数组不同，并且它不需要借助离散化操作。支持的操作（在本题中会使用到的）主要有以下几种：</p>
<p>操作 1「lower bound」：给定一个元素 x，查询平衡树中最小的大于等于 x 的元素；</p>
<p>操作 2「upper bound」：给定一个元素 x，查询平衡树中最小的大于 x 的元素；</p>
<p>操作 3「rank」：给定一个元素 x（它必须在平衡树中），求它是第几小的元素。当存在重复元素时，会计入多次；</p>
<p>操作 4「insert」：给定一个元素 x，将它放入平衡树中。</p>
<p>所有操作的时间复杂度均为 $O(\log n)$。大部分语言自带的平衡树支持操作 1 和 2 和 4 但不支持操作 3。</p>
<p>那么对于本题中需要的两种操作：</p>
<p>「查询」：我们令 $u = P[j] - \textit{upper}$，$v = P[j] - \textit{lower}$。对 u 使用操作 11 得到 u’′<br> ，对 v 使用操作 2 得到 v’  。我们再使用操作 3 得到 u’的$ rank r_u$ 以及 v’<br>  的$ rank r_v$ ，那么$ r_v’-r_u’$′， 就是$ \big[P[j] - \textit{upper}, P[j] - \textit{lower}\big]$ 中的元素个数。</p>
<p>「更新」：我们对 x 使用操作 4 即可。</p>
<h3 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h3><p>关于这些竞赛难度的知识点，我建议读者在学有余力的情况下学习。这些知识点对面试几乎没有任何帮助；相反，在没有完全掌握这些知识点的前提下，可能会影响读者原本正常的思维，产生「看什么题都是线段树」之类的后果。</p>
<p>这里我推荐两个参考资料：</p>
<ul>
<li><a href="https://oi-wiki.org/" target="_blank" rel="noopener">OI Wiki</a>，是一个信息学竞赛爱好者用爱发电的算法小百科。</li>
<li><a href="https://github.com/atcoder/ac-library" target="_blank" rel="noopener">ac-library</a>，是日本著名算法竞赛平台 AtCoder 整理的算法模板，但其中没有平衡树。</li>
</ul>
<p>读者也可以参考其它互联网上的博客。线段树、树状数组和平衡树在算法竞赛圈中是非常基础的知识点，优质的博客数量也很多</p>
<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>归并排序</tag>
        <tag>线段树</tag>
        <tag>动态线段树</tag>
        <tag>平衡二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>史上最全的遍历二叉树详解</title>
    <url>/Detailed_explanation_of_tree/</url>
    <content><![CDATA[<h1 id="X-遍历二叉树的方法合集"><a href="#X-遍历二叉树的方法合集" class="headerlink" title="X.遍历二叉树的方法合集"></a>X.遍历二叉树的方法合集</h1><ol>
<li><ol>
<li>二叉树的中序遍历</li>
</ol>
</li>
<li><ol>
<li>二叉树的前序遍历</li>
</ol>
</li>
<li><ol>
<li>二叉树的后序遍历</li>
</ol>
</li>
</ol>
<h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><a id="more"></a>

<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderRecur</span><span class="params">(TreeNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">    preOrderRecur(head.left);</span><br><span class="line">    preOrderRecur(head.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderRecur</span><span class="params">(TreeNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    preOrderRecur(head.left);</span><br><span class="line">    System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">    preOrderRecur(head.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderRecur</span><span class="params">(TreeNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    postOrderRecur(head.left);</span><br><span class="line">    postOrderRecur(head.right);</span><br><span class="line">    System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><p>这里没有对递归遍历做过多的解释，仅仅给出了简单的动画演示。<br>要理解递归的思路并且熟练的使用它，就是要想清楚你想做什么，什么时候停止。</p>
<h3 id="如前序遍历："><a href="#如前序遍历：" class="headerlink" title="如前序遍历："></a>如前序遍历：</h3><p>我想先打印头节点对吧？那我打印完了头节点，我现在想打印左边节点了，我只是告诉计算机我想打印左边结点，之后打印右边结点。</p>
<h3 id="那么后序遍历呢？"><a href="#那么后序遍历呢？" class="headerlink" title="那么后序遍历呢？"></a>那么后序遍历呢？</h3><p>这个时候你应该知道了，我就是想操作左边然后右边，最后打印中间的元素。</p>
<p>我们并不需要太过于在意具体的递归过程，而是要想清楚让计算机干什么。</p>
<p>计算机都可能溢出，用人脑去遍历就不现实了。</p>
<h2 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h2><p>本质上是在模拟递归，因为在递归的过程中使用了系统栈，所以在迭代的解法中常用Stack来模拟系统栈。</p>
<h3 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>首先我们应该创建一个Stack用来存放节点，首先我们想要打印根节点的数据，此时Stack里面的内容为空，所以我们优先将头结点加入Stack，然后打印。</p>
<p>之后我们应该先打印左子树，然后右子树。所以先加入Stack的就是右子树，然后左子树。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderIteration</span><span class="params">(TreeNode head)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">	stack.push(head);</span><br><span class="line">	<span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">		TreeNode node = stack.pop();</span><br><span class="line">		System.out.print(node.value + <span class="string">" "</span>);</span><br><span class="line">		<span class="keyword">if</span> (node.right != <span class="keyword">null</span>) {</span><br><span class="line">			stack.push(node.right);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (node.left != <span class="keyword">null</span>) {</span><br><span class="line">			stack.push(node.left);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>同理创建一个Stack，然后按 左 中 右的顺序输出节点。<br>尽可能的将这个节点的左子树压入Stack，此时栈顶的元素是最左侧的元素，其目的是找到一个最小单位的子树(也就是最左侧的一个节点)，并且在寻找的过程中记录了来源，才能返回上层,同时在返回上层的时候已经处理完毕左子树了。。当处理完最小单位的子树时，返回到上层处理了中间节点。（如果把整个左中右的遍历都理解成子树的话，就是处理完 <code>左子树-&gt;中间(就是一个节点)-&gt;右子树）</code><br>如果有右节点，其也要进行中序遍历。</p>
<p><a href="https://imgchr.com/i/B84oZt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/29/B84oZt.png" alt="B84oZt.png"></a></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderIteration</span><span class="params">(TreeNode head)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	TreeNode cur = head;</span><br><span class="line">	Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">	<span class="keyword">while</span> (!stack.isEmpty() || cur != <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">			stack.push(cur);</span><br><span class="line">			cur = cur.left;</span><br><span class="line">		}</span><br><span class="line">		TreeNode node = stack.pop();</span><br><span class="line">		System.out.print(node.value + <span class="string">" "</span>);</span><br><span class="line">		<span class="keyword">if</span> (node.right != <span class="keyword">null</span>) {</span><br><span class="line">			cur = node.right;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h3><h4 id="代码片段-1"><a href="#代码片段-1" class="headerlink" title="代码片段 1"></a>代码片段 1</h4><ul>
<li>前序遍历的过程 是 中左右。</li>
<li>将其转化成 中右左。也就是压栈的过程中优先压入左子树，在压入右子树。</li>
<li>然后将这个结果返回来，这里是利用栈的先进后出倒序打印。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderIteration</span><span class="params">(TreeNode head)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		stack1.push(head);</span><br><span class="line">		<span class="keyword">while</span> (!stack1.isEmpty()) {</span><br><span class="line">			TreeNode node = stack1.pop();</span><br><span class="line">			stack2.push(node);</span><br><span class="line">			<span class="keyword">if</span> (node.left != <span class="keyword">null</span>) {</span><br><span class="line">				stack1.push(node.left);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (node.right != <span class="keyword">null</span>) {</span><br><span class="line">				stack1.push(node.right);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">while</span> (!stack2.isEmpty()) {</span><br><span class="line">			System.out.print(stack2.pop().value + <span class="string">" "</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="代码片段-2"><a href="#代码片段-2" class="headerlink" title="代码片段 2"></a>代码片段 2</h4><ul>
<li>bn用一个指针cur标记当前退出的节点是什么。</li>
<li>后序遍历的过程中在遍历完左子树跟右子树cur都会回到根结点。所以当前不管是从左子树还是右子树回到根结点都不应该再操作了，应该退回上层。</li>
<li>如果是从右边再返回根结点，应该回到上层。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderIteration2</span><span class="params">(TreeNode head)</span> </span>{ 感谢[<span class="meta">@ben</span>-ben-niu](/u/ben-ben-niu/)指出错误，代码确实存在问题，已经在原文中修复</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	TreeNode cur = head;</span><br><span class="line">	Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">	stack.push(head);</span><br><span class="line">	<span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">		TreeNode peek = stack.peek();</span><br><span class="line">		<span class="keyword">if</span> (peek.left != <span class="keyword">null</span> &amp;&amp; peek.left != cur &amp;&amp; peek.right != cur) {</span><br><span class="line">			stack.push(peek.left);</span><br><span class="line">		} <span class="keyword">else</span> <span class="keyword">if</span> (peek.right != <span class="keyword">null</span> &amp;&amp; peek.right != cur) {</span><br><span class="line">			stack.push(peek.right);</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			System.out.print(stack.pop().val + <span class="string">" "</span>);</span><br><span class="line">			cur = peek;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Morris解法"><a href="#Morris解法" class="headerlink" title="Morris解法"></a>Morris解法</h2><p>Morris遍历使用二叉树节点中大量指向null的指针，由Joseph Morris 于1979年发明。<br>时间复杂度：O(n)<br>额外空间复杂度：O(1)</p>
<p>在你阅读以下代码之前，在这边先讲解一下Morris的通用解法过程。</p>
<p><a href="https://imgchr.com/i/B84OzQ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/29/B84OzQ.png" alt="B84OzQ.png"></a></p>
<p>Morris的整体思路就是将 以某个根结点开始，找到它左子树的最右侧节点之后与这个根结点进行连接<br>我们可以从 图2 看到，如果这么连接之后，cur 这个指针是可以完整的从一个节点顺着下一个节点遍历，将整棵树遍历完毕，直到 7 这个节点右侧没有指向。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderMorris</span><span class="params">(TreeNode head)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	TreeNode cur1 = head;<span class="comment">//当前开始遍历的节点</span></span><br><span class="line">	TreeNode cur2 = <span class="keyword">null</span>;<span class="comment">//记录当前结点的左子树</span></span><br><span class="line">	<span class="keyword">while</span> (cur1 != <span class="keyword">null</span>) {</span><br><span class="line">		cur2 = cur1.left;</span><br><span class="line">		<span class="keyword">if</span> (cur2 != <span class="keyword">null</span>) {</span><br><span class="line">			<span class="keyword">while</span> (cur2.right != <span class="keyword">null</span> &amp;&amp; cur2.right != cur1) {<span class="comment">//找到当前左子树的最右侧节点，且这个节点应该在指向根结点之前，否则整个节点又回到了根结点。</span></span><br><span class="line">				cur2 = cur2.right;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (cur2.right == <span class="keyword">null</span>) {<span class="comment">//这个时候如果最右侧这个节点的右指针没有指向根结点，创建连接然后往下一个左子树的根结点进行连接操作。</span></span><br><span class="line">				cur2.right = cur1;</span><br><span class="line">				cur1 = cur1.left;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			} <span class="keyword">else</span> {<span class="comment">//当左子树的最右侧节点有指向根结点，此时说明我们已经回到了根结点并重复了之前的操作，同时在回到根结点的时候我们应该已经处理完 左子树的最右侧节点 了，把路断开。</span></span><br><span class="line">				cur2.right = <span class="keyword">null</span>;</span><br><span class="line">			}</span><br><span class="line">		} </span><br><span class="line">		cur1 = cur1.right;<span class="comment">//一直往右边走，参考图</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="前序遍历-2"><a href="#前序遍历-2" class="headerlink" title="前序遍历"></a>前序遍历</h3><ol>
<li>在某个根结点创建连线的时候打印。因为我们是顺着左边的根节点来创建连线，且创建的过程只有一次。</li>
<li>打印某些自身无法创建连线的节点，也就是叶子节点。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderMorris</span><span class="params">(TreeNode head)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	TreeNode cur1 = head;</span><br><span class="line">	TreeNode cur2 = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span> (cur1 != <span class="keyword">null</span>) {</span><br><span class="line">		cur2 = cur1.left;</span><br><span class="line">		<span class="keyword">if</span> (cur2 != <span class="keyword">null</span>) {</span><br><span class="line">			<span class="keyword">while</span> (cur2.right != <span class="keyword">null</span> &amp;&amp; cur2.right != cur1) {</span><br><span class="line">				cur2 = cur2.right;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (cur2.right == <span class="keyword">null</span>) {</span><br><span class="line">				cur2.right = cur1;</span><br><span class="line">				System.out.print(cur1.value + <span class="string">" "</span>);</span><br><span class="line">				cur1 = cur1.left;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			} <span class="keyword">else</span> {</span><br><span class="line">				cur2.right = <span class="keyword">null</span>;</span><br><span class="line">			}</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			System.out.print(cur1.value + <span class="string">" "</span>);</span><br><span class="line">		}</span><br><span class="line">		cur1 = cur1.right;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="中序遍历-2"><a href="#中序遍历-2" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>从最左侧开始顺着右节点打印。也就是在将cu1切换到上层节点的时候</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderMorris</span><span class="params">(TreeNode head)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	TreeNode cur1 = head;</span><br><span class="line">	TreeNode cur2 = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span> (cur1 != <span class="keyword">null</span>) {</span><br><span class="line">		cur2 = cur1.left;</span><br><span class="line">		<span class="comment">//构建连接线</span></span><br><span class="line">		<span class="keyword">if</span> (cur2 != <span class="keyword">null</span>) {</span><br><span class="line">			<span class="keyword">while</span> (cur2.right != <span class="keyword">null</span> &amp;&amp; cur2.right != cur1) {</span><br><span class="line">				cur2 = cur2.right;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (cur2.right == <span class="keyword">null</span>) {</span><br><span class="line">				cur2.right = cur1;</span><br><span class="line">				cur1 = cur1.left;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			} <span class="keyword">else</span> {</span><br><span class="line">				cur2.right = <span class="keyword">null</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		System.out.print(cur1.value + <span class="string">" "</span>);</span><br><span class="line">		cur1 = cur1.right;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="后序遍历-2"><a href="#后序遍历-2" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>后序遍历就比较复杂了哈，先看一下图</p>
<p><a href="https://imgchr.com/i/B84vss" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/29/B84vss.png" alt="B84vss.png"></a></p>
<p>当我们到达最左侧，也就是左边连线已经创建完毕了。<br>打印 4<br>打印 5 2<br>打印 6<br>打印 7 3 1<br>我们将一个节点的连续右节点当成一个单链表来看待。<br>当我们返回上层之后，也就是将连线断开的时候，打印下层的单链表。<br>比如返回到　２，此时打印　４<br>比如返回到　１，此时打印　５　２<br>比如返回到　３，此时打印　６<br>那么我们只需要将这个单链表逆序打印就行了，下文也给出了 单链表逆序代码<br>这里不应该打印当前层，而是下一层，否则根结点会先与右边打印。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//后序Morris</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderMorris</span><span class="params">(TreeNode head)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	TreeNode cur1 = head;<span class="comment">//遍历树的指针变量</span></span><br><span class="line">	TreeNode cur2 = <span class="keyword">null</span>;<span class="comment">//当前子树的最右节点</span></span><br><span class="line">	<span class="keyword">while</span> (cur1 != <span class="keyword">null</span>) {</span><br><span class="line">		cur2 = cur1.left;</span><br><span class="line">		<span class="keyword">if</span> (cur2 != <span class="keyword">null</span>) {</span><br><span class="line">			<span class="keyword">while</span> (cur2.right != <span class="keyword">null</span> &amp;&amp; cur2.right != cur1) {</span><br><span class="line">				cur2 = cur2.right;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (cur2.right == <span class="keyword">null</span>) {</span><br><span class="line">				cur2.right = cur1;</span><br><span class="line">				cur1 = cur1.left;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			} <span class="keyword">else</span> {</span><br><span class="line">				cur2.right = <span class="keyword">null</span>;</span><br><span class="line">				postMorrisPrint(cur1.left);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		cur1 = cur1.right;</span><br><span class="line">	}</span><br><span class="line">	postMorrisPrint(head);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//打印函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postMorrisPrint</span><span class="params">(TreeNode head)</span> </span>{</span><br><span class="line">	TreeNode reverseList = postMorrisReverseList(head);</span><br><span class="line">	TreeNode cur = reverseList;</span><br><span class="line">	<span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">		System.out.print(cur.value + <span class="string">" "</span>);</span><br><span class="line">		cur = cur.right;</span><br><span class="line">	}</span><br><span class="line">	postMorrisReverseList(reverseList);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//翻转单链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">postMorrisReverseList</span><span class="params">(TreeNode head)</span> </span>{</span><br><span class="line">	TreeNode cur = head;</span><br><span class="line">	TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">		TreeNode next = cur.right;</span><br><span class="line">		cur.right = pre;</span><br><span class="line">		pre = cur;</span><br><span class="line">		cur = next;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> pre;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>中序遍历</tag>
        <tag>迭代</tag>
        <tag>前序遍历</tag>
        <tag>后序遍历</tag>
        <tag>Morris解法</tag>
      </tags>
  </entry>
  <entry>
    <title>脑筋急转弯_leetcode.1227.飞机座位分配概率</title>
    <url>/Aircraft_seat_allocation_probability/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。</p>
<p>剩下的乘客将会：</p>
<p>如果他们自己的座位还空着，就坐到自己的座位上，</p>
<p>当他们自己的座位被占用时，随机选择其他座位<br>第 n 位乘客坐在自己的座位上的概率是多少？</p>
 <a id="more"></a>

<p>示例 1：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：1.00000</span><br><span class="line">解释：第一个人只会坐在自己的位置上。</span><br></pre></td></tr></tbody></table></figure>


<p>示例 2：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: n = 2</span><br><span class="line">输出: 0.50000</span><br><span class="line">解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。</span><br></pre></td></tr></tbody></table></figure>


<p>提示：</p>
<ul>
<li>1 &lt;= n &lt;= 10^5</li>
</ul>
<h2 id="🌸解法：分类讨论"><a href="#🌸解法：分类讨论" class="headerlink" title="🌸解法：分类讨论"></a>🌸解法：分类讨论</h2><p>这道题代码很简单，但是就看你的脑袋想不想得到了，数学推理也挺难懂得，在这里大致说一下我的理解吧</p>
<ul>
<li><p>第一，题目并没有按照座位号1-n的顺序进行乘客登录飞机，也就是说第一个乘客的座位号并不是1，但是有一点巧妙的点就在于这个题并不管乘客的座位号是如何编排的，因为座位号也同样是1-n，所以我们可以以乘客的登录飞机的顺序为乘客重新进行编号，即第一个乘客所对应的座位号(编号代表的是入场的次序，而不是实际的座位号)。</p>
</li>
<li><p>第二，按照所有的情况进行分类讨论</p>
<ul>
<li><p>当n 等于1，毫无疑问，第n个乘客就是他自己，坐回他自己座位的概率为1.0</p>
</li>
<li><p>当n 不等于1，第一个乘客进入飞机后，可以分为以下几种情况。</p>
<ul>
<li><p>他有1/n的概率去选择到原本属于他自己的座位，也就是说他选择对了，则后面的所有人位置都是对的，所以第n个人的概率为1</p>
</li>
<li><p>他有1/n的概率选择到第n个人座位，即第n个人无论如何也选择不了自己的座位，概率为0</p>
</li>
<li><p>如果第一个人选择到了第i个人的座位，那么第二个人到第i- 1个人的位置都是对的，轮到第i个人时就会感觉到迷茫。因为自己的位置被占据了，如果第i个人选择第一个人的座位，那么后面的人位置都是完全正确的，如果他选择到了第i + 1到第n个座位，那么后面的人也会遇到同样迷茫的问题，那么，怎么做呢？</p>
</li>
<li><p>其实，当轮到第i个人的时候，i感觉到了迷茫，就像一开始第一个人一样不知道自己应该坐哪儿，所以这个时候我们可以将i和1身份互换一下，令第一个位置就是i本身的座位，这样就会有i选择第一个座位，后面的人座位肯定是对的，如果i不选择1号，同样是会令下一个i感到迷茫，这样就可以产生递归了，并且将问题的规模缩减到了n - i + 1(即还剩下多少个座位没有没有被选或者还剩下多少个人没有选，n - i代表i后面的人，再加上迷茫的i就是n - i + 1)</p>
</li>
<li><p>我们令f(n)为第n个人坐到自己原本座位的概率，按照递推规律可有</p>
<ul>
<li><p>$f(n) = \frac{1}{n}\left(1 + \sum_{i=2}^{n-1}{f(n-i+1)}\right)$</p>
</li>
<li><p>这个递推式想必大家高中就会求了，令 n = n-1再写出一项：</p>
</li>
<li><p>$f(n-1) = \frac{1}{n-1}\left(1 + \sum_{i=2}^{n-2}{f(n-i)}\right)$</p>
</li>
<li><p>然后两式相减得到：$nf(n) - (n-1)f(n-1) = f(n-1)$</p>
<p>即：$f(n) = f(n-1) = \cdots = f(2)$</p>
<p>那么我们就可以得到最终的答案了，对任意的 $n \ge 2n≥2 $都有 <code>f(n) = f(2) = 0.5</code></p>
</li>
</ul>
</li>
<li><p>另一种理解：可以把0到n-1看成一个整体，那对于n来说，无非就两种情况，前0到n-1号是否会把n的位置占据，概率就是0.5；只有一个人的情况概率为1（一定坐在自己的位置上）。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">nthPersonGetsNthSeat</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">1.0</span> : <span class="number">0.5</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>分类讨论</tag>
      </tags>
  </entry>
  <entry>
    <title>脑筋急转弯_leetcode.1033.移动石子直到连续</title>
    <url>/Move_the_stone_until_continuous/</url>
    <content><![CDATA[<blockquote>
<p>哎，最近忙着ACM和蓝桥杯（毕竟都是第一次参赛的小白），可把自己整迷糊了，当两项比赛全部告一段落，自己才是真的觉悟到自己与别人的差距以及自己的大脑思考问题的能力很是欠缺，还有就是思考不够全面，往往一道题明明自己已经写出了方法，但硬是在比赛途中想不出一种有效的方法去优化方法和更快的得出答案，总是赛后诸葛亮的想出这该怎么做，那该怎么做，这些欠缺都导致自己在ACM和蓝桥杯中丢失得分，看来还是得努力呀，不让自己变得更强又何能征战星辰大海呢，先来练练思维能力吧，从最简单的脑筋急转弯开始！</p>
</blockquote>
<a id="more"></a>

<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁三枚石子放置在数轴上，位置分别为 a，b，c。</p>
<p>每一回合，我们假设这三枚石子当前分别位于位置 x, y, z 且 x &lt; y &lt; z。从位置 x 或者是位置 z 拿起一枚石子，并将该石子移动到某一整数位置 k 处，其中 x &lt; k &lt; z 且 k != y。</p>
<p>当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。</p>
<p>要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves]</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：a = 1, b = 2, c = 5</span><br><span class="line">输出：[1, 2]</span><br><span class="line">解释：将石子从 5 移动到 4 再移动到 3，或者我们可以直接将石子移动到 3。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：a = 4, b = 3, c = 2</span><br><span class="line">输出：[0, 0]</span><br><span class="line">解释：我们无法进行任何移动。</span><br></pre></td></tr></tbody></table></figure>


<p>提示：</p>
<ul>
<li>1 &lt;= a &lt;= 100</li>
<li>1 &lt;= b &lt;= 100</li>
<li>1 &lt;= c &lt;= 100</li>
<li>a != b, b != c, c != a</li>
</ul>
<h2 id="🌸解法：分类讨论"><a href="#🌸解法：分类讨论" class="headerlink" title="🌸解法：分类讨论"></a>🌸解法：分类讨论</h2><p>这道题给出的数据并没有直接给你排好序了的，他的数据顺序是乱的（这是一个小小的坑）</p>
<p>假设已经排好序了那么要求出最大次数和最小次数，即</p>
<ul>
<li>最大次数，无疑就是一步一步的走，即最后一个元素减去第一个元素 再减二（这很好推断，自己画一个数轴就知道了）</li>
<li>最小次数，只能是1或者2，这就要分类讨论了<ul>
<li>最小次数为一，即只需要动一步，即已经有两个数是连续的了或者两个数之间只有一个空的时候,例如 <code>1  2  5</code>、<code>1  3  5</code>。</li>
<li>最小次数为二，即除上面情况之后的所有情况</li>
</ul>
</li>
</ul>
<p>代码就很好得出了</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] numMovesStones(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) {</span><br><span class="line">    	<span class="keyword">int</span> max = Math.max(Math.max(a, b), c);<span class="comment">//找到最大值</span></span><br><span class="line">    	<span class="keyword">int</span> min = Math.min(Math.min(a, b), c);<span class="comment">//找到最小值</span></span><br><span class="line">    	<span class="keyword">int</span> cur = a + b + c - max - min; <span class="comment">// 找到中间那个数</span></span><br><span class="line">    	<span class="keyword">if</span>(max - cur == <span class="number">1</span> &amp;&amp; cur - min == <span class="number">1</span>) { <span class="comment">//如果已经是连续的了，则不用移动</span></span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">0</span>, <span class="number">0</span>};</span><br><span class="line">    	}</span><br><span class="line">    	<span class="keyword">if</span>(max - cur &lt;= <span class="number">2</span> || cur - min &lt;= <span class="number">2</span>) { <span class="comment">//不连续但是有其中两个中间只有一个位置时候例如：1 3 4 、 1 3 5，都只需要最小移动一次即可连续</span></span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] {<span class="number">1</span>, max - min - <span class="number">2</span>};</span><br><span class="line">    	}<span class="keyword">else</span> {<span class="comment">//否则最少移动两次才可以连续</span></span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] {<span class="number">2</span>, max - min - <span class="number">2</span>};</span><br><span class="line">    	}</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸题目-1"><a href="#🌸题目-1" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>你和你的朋友，两个人一起玩 Nim 游戏：</p>
<p>桌子上有一堆石头。<br>你们轮流进行自己的回合，你作为先手。<br>每一回合，轮到的人拿掉 1 - 3 块石头。<br>拿掉最后一块石头的人就是获胜者。<br>j假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：false </span><br><span class="line">解释：如果堆中有 4 块石头，那么你永远不会赢得比赛；</span><br><span class="line">     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿</span><br></pre></td></tr></tbody></table></figure>

<p>走。<br>示例 2：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：true</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：n = 2</span><br><span class="line">输出：true</span><br></pre></td></tr></tbody></table></figure>


<p>提示：</p>
<ul>
<li>1 &lt;= n &lt;= 2^31 - 1</li>
</ul>
<h2 id="🌸解法一：记忆化递归"><a href="#🌸解法一：记忆化递归" class="headerlink" title="🌸解法一：记忆化递归"></a>🌸解法一：记忆化递归</h2><ul>
<li>为什么在两个人「足够聪明」（你们是聪明人，每一步都是最优解）这个前提下，比赛的结果是「由输入数据确定的」</li>
</ul>
<p>用具体的例子 8 进行分析可以得出结论：</p>
<p>当 N = 3 的时候，当前做出选择的人可以拿掉最后一块石头，获得胜利；<br>然后我们逐层向上分析，当 N = 4的时候，无论当前做出哪一种选择，对方都会赢，所以当前只能输掉比赛；<br>如果当前这一层的结点里「有输有赢」，因为我们「足够聪明」，所以必须选择可以让对方输掉的分支，好让自己赢；<br>对于这个问题的特点是，当 N不是 4 的倍数的时候，先手（当前做出选择的人），或者说游戏一开始做出选择的玩家一定会输。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="comment">// 使用包装类型的布尔数组，可以用 null 这个状态，表示当前 n 的结果还没有被计算出来</span></span><br><span class="line">    Boolean[] memo = <span class="keyword">new</span> Boolean[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dfs(n, memo);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, Boolean[] memo)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 3 种选择，只要有一种对方输掉，自己就可以赢</span></span><br><span class="line">    <span class="keyword">if</span> (!dfs(n - <span class="number">1</span>, memo) || !dfs(n - <span class="number">2</span>, memo) || !dfs(n - <span class="number">3</span>, memo)) {</span><br><span class="line">        memo[n] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 否则自己输</span></span><br><span class="line">    memo[n] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法二：动态规划"><a href="#🌸解法二：动态规划" class="headerlink" title="🌸解法二：动态规划"></a>🌸解法二：动态规划</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp[0] 的值可以不管，没有意义</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="keyword">true</span>;</span><br><span class="line">    dp[<span class="number">3</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) {</span><br><span class="line">        dp[i] = !dp[i - <span class="number">1</span>] || !dp[i - <span class="number">2</span>] || !dp[i - <span class="number">3</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>滚动数组优化</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">4</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="keyword">true</span>;</span><br><span class="line">    dp[<span class="number">3</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) {</span><br><span class="line">        dp[i % <span class="number">4</span>] = !dp[(i - <span class="number">1</span>) % <span class="number">4</span>] || !dp[(i - <span class="number">2</span>) % <span class="number">4</span>] || !dp[(i - <span class="number">3</span>) % <span class="number">4</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n % <span class="number">4</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法三：数学方法"><a href="#🌸解法三：数学方法" class="headerlink" title="🌸解法三：数学方法"></a>🌸解法三：数学方法</h2><p>让我们考虑一些小例子。显而易见的是，如果石头堆中只有一块、两块、或是三块石头，那么在你的回合，你就可以把全部石子拿走，从而在游戏中取胜。而如果就像题目描述那样，堆中恰好有四块石头，你就会失败。因为在这种情况下不管你取走多少石头，总会为你的对手留下几块，使得他可以在游戏中打败你。因此，要想获胜，在你的回合中，必须避免石头堆中的石子数为 4 的情况。</p>
<p>同样地，如果有五块、六块、或是七块石头，你可以控制自己拿取的石头数，总是恰好给你的对手留下四块石头，使他输掉这场比赛。但是如果石头堆里有八块石头，你就不可避免地会输掉，因为不管你从一堆石头中挑出一块、两块还是三块，你的对手都可以选择三块、两块或一块，以确保在再一次轮到你的时候，你会面对四块石头。</p>
<p>显然，它以相同的模式不断重复 n=4,8,12,16,…，基本可以看出是 4 的倍数。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (n % <span class="number">4</span>) != <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可怕可怕。。。</p>
<h2 id="🌸题目-2"><a href="#🌸题目-2" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>给你两个字符串，请你从这两个字符串中找出最长的特殊序列。</p>
<p>「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。</p>
<p>子序列 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。</p>
<p>输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: "aba", "cdc"</span><br><span class="line">输出: 3</span><br><span class="line">解释: 最长特殊序列可为 "aba" (或 "cdc")，两者均为自身的子序列且不是对方的子序列。</span><br></pre></td></tr></tbody></table></figure>


<p>示例 2：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：a = "aaa", b = "bbb"</span><br><span class="line">输出：3</span><br></pre></td></tr></tbody></table></figure>


<p>示例 3：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：a = "aaa", b = "aaa"</span><br><span class="line">输出：-1</span><br></pre></td></tr></tbody></table></figure>


<p>提示：</p>
<ul>
<li>两个字符串长度均处于区间 [1 - 100] 。</li>
<li>字符串中的字符仅含有 ‘a’~’z’ 。</li>
</ul>
<h2 id="🌸解法一：暴力解法"><a href="#🌸解法一：暴力解法" class="headerlink" title="🌸解法一：暴力解法"></a>🌸解法一：暴力解法</h2><p>暴力解法中，生成两个字符串所有的子序列共 2^n<br>  个，将其存储在 hashmap 中，并记录每个子序列出现的次数。然后找出出现次数为 11 的最长子序列。如果不存在这样的子序列，返回 -1。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLUSlength</span><span class="params">(String a, String b)</span> </span>{</span><br><span class="line">    HashMap &lt; String, Integer &gt; map = <span class="keyword">new</span> HashMap &lt; &gt; ();</span><br><span class="line">    <span class="keyword">for</span> (String s: <span class="keyword">new</span> String[] {a, b}) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; s.length()); i++) {</span><br><span class="line">            String t = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length(); j++) {</span><br><span class="line">                <span class="keyword">if</span> (((i &gt;&gt; j) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                    t += s.charAt(j);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(t))</span><br><span class="line">                map.put(t, map.get(t) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map.put(t, <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (String s: map.keySet()) {</span><br><span class="line">        <span class="keyword">if</span> (map.get(s) == <span class="number">1</span>)</span><br><span class="line">            res = Math.max(res, s.length());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法二：寻找规律"><a href="#🌸解法二：寻找规律" class="headerlink" title="🌸解法二：寻找规律"></a>🌸解法二：寻找规律</h2><p>字符串 a 和 b 共有 3 种情况：</p>
<ul>
<li><p>a=b。如果两个字符串相同，则没有特殊子序列，返回 -1。</p>
</li>
<li><p>length(a)=length(b) 且 a != b。例如：abc 和 abd。这种情况下，一个字符串一定不会是另外一个字符串的子序列，因此可以将任意一个字符串看作是特殊子序列，返回 length(a) 或 length(b)</p>
</li>
<li><p>length(a)&gt; =length(b)。例如：abcd 和 abc。这种情况下，长的字符串一定不会是短字符串的子序列，因此可以将长字符串看作是特殊子序列，返回 max(length(a),length(b))。</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLUSlength</span><span class="params">(String a, String b)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(a.equals(b)){</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">return</span> Math.max(a.length(), b.length());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>记忆化递归</tag>
        <tag>取模运算</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title>一文搞定常见的链表问题</title>
    <url>/Linked_list_problem/</url>
    <content><![CDATA[<p>作为线性表的两种存储方式 —— 链表和数组，这对相爱相杀的好基友有着各自的优缺点。接下来，我们梳理一下这两种方式。</p>
<p>数组，所有元素都连续的存储于一段内存中，且每个元素占用的内存大小相同。这使得数组具备了通过下标快速访问数据的能力。<br>但连续存储的缺点也很明显，增加容量，增删元素的成本很高，时间复杂度均为 O(n)。</p>
<a id="more"></a>

<p>增加数组容量需要先申请一块新的内存，然后复制原有的元素。如果需要的话，可能还要删除原先的内存。</p>
<p>删除元素时需要移动被删除元素之后的所有元素以保证所有元素是连续的。增加元素时需要移动指定位置及之后的所有元素，然后将新增元素插入到指定位置，如果容量不足的话还需要先进行扩容操作。</p>
<p>总结一下数组的优缺点：</p>
<p>优点：可以根据偏移实现快速的随机读写。<br>缺点：扩容，增删元素极慢。<br>链表，由若干个结点组成，每个结点包含数据域和指针域。结点结构如下图所示：</p>
<p>一般来讲，链表中只会有一个结点的指针域为空，该结点为尾结点，其他结点的指针域都会存储一个结点的内存地址。链表中也只会有一个结点的内存地址没有存储在其他结点的指针域，该结点称为头结点。</p>
<p>链表的存储方式使得它可以高效的在指定位置插入与删除，时间复杂度均为 O(1)。<br>在结点 p 之后增加一个结点 q 总共分三步：</p>
<p>申请一段内存用以存储 q (可以使用内存池避免频繁申请和销毁内存)。<br>将 p 的指针域数据复制到 q 的指针域。<br>更新 p 的指针域为 q 的地址。</p>
<p>删除结点 p 之后的结点 q 总共分两步：</p>
<ol>
<li><p>将 q 的指针域复制到 p 的指针域。</p>
</li>
<li><p>释放 q 结点的内存。</p>
<p>链表的主要代码</p>
</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个结点模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span></span><br><span class="line">	T data;</span><br><span class="line">	Node *next;</span><br><span class="line">	Node() : next(<span class="literal">nullptr</span>) {}</span><br><span class="line">	Node(<span class="keyword">const</span> T &amp;d) : data(d), next(<span class="literal">nullptr</span>) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除 p 结点后面的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Remove</span><span class="params">(Node&lt;T&gt; *p)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">nullptr</span> || p-&gt;next == <span class="literal">nullptr</span>) {</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">auto</span> tmp = p-&gt;next-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> p-&gt;next;</span><br><span class="line">	p-&gt;next = tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 p 结点后面插入元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Node&lt;T&gt; *p, <span class="keyword">const</span> T &amp;data)</span> </span>{</span><br><span class="line">	<span class="keyword">auto</span> tmp = <span class="keyword">new</span> Node&lt;T&gt;(data);</span><br><span class="line">	tmp-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Walk</span><span class="params">(Node&lt;T&gt; *p, <span class="keyword">const</span> V &amp;vistor)</span> </span>{</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">nullptr</span>) {</span><br><span class="line">		vistor(p);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">auto</span> p = <span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">	Insert(p, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	Walk(p, [&amp;sum](<span class="keyword">const</span> Node&lt;<span class="keyword">int</span>&gt; *p) -&gt; <span class="keyword">void</span> { sum += p-&gt;data; });</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Remove(p);</span><br><span class="line">	sum = <span class="number">0</span>;</span><br><span class="line">	Walk(p, [&amp;sum](<span class="keyword">const</span> Node&lt;<span class="keyword">int</span>&gt; *p) -&gt; <span class="keyword">void</span> { sum += p-&gt;data; });</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() {}</span><br><span class="line">    ListNode(<span class="keyword">int</span> val) { <span class="keyword">this</span>.val = val; }</span><br><span class="line">    ListNode(<span class="keyword">int</span> val, ListNode next) { <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>面试问题总结</strong></p>
<p>无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。然而面试的时候经常碰见诸如获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度等和长度与位置有关的问题。这些问题都可以通过灵活运用双指针来解决。</p>
<p>Tips：双指针并不是固定的公式，而是一种思维方式~</p>
<p>先来看”倒数第k个元素的问题”。设有两个指针 p 和 q，初始时均指向头结点。首先，先让 p 沿着 next 移动 k 次。此时，p 指向第 k+1个结点，q 指向头节点，两个指针的距离为 k 。然后，同时移动 p 和 q，直到 p 指向空，此时 q 即指向倒数第 k 个结点。可以参考下图来理解：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        ListNode *p = head, *q = head; <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">while</span>(k--) {   <span class="comment">//将 p指针移动 k 次</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>) {<span class="comment">//同时移动，直到 p == nullptr</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>获取中间元素的问题。设有两个指针 fast 和 slow，初始时指向头节点。每次移动时，fast向后走两次，slow向后走一次，直到 fast 无法向后走两次。这使得在每轮移动之后。fast 和 slow 的距离就会增加一。设链表有 n 个元素，那么最多移动 n/2 轮。当 n 为奇数时，slow 恰好指向中间结点，当 n 为 偶数时，slow 恰好指向中间两个结点的靠前一个(可以考虑下如何使其指向后一个结点呢？)。</p>
<p>下述代码实现了 n 为<strong>偶数</strong>时慢指针指向<strong>靠后结点</strong>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode *p = head, *q = head;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">nullptr</span> &amp;&amp; q-&gt;next != <span class="literal">nullptr</span>) {</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    } </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>是否存在环的问题。如果将尾结点的 next 指针指向其他任意一个结点，那么链表就存在了一个环。</p>
<p>一部分中，总结快慢指针的特性 —— 每轮移动之后两者的距离会加一。下面会继续用该特性解决环的问题。<br>当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了追及问题。想象一下在操场跑步的场景，只要一直跑下去，快的总会追上慢的。当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。</p>
<p>根据上述表述得出，如果一个链表存在环，那么快慢指针必然会相遇。实现代码如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>{</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>) {</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast != <span class="literal">nullptr</span>) {</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>后一个问题，如果存在环，如何判断环的长度呢？方法是，快慢指针相遇后继续移动，直到第二次相遇。两次相遇间的移动次数即为环的长度。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>数组</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS_面试题_08.10_颜色填充</title>
    <url>/Color_fill/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁编写函数，实现许多图片编辑软件都支持的「颜色填充」功能。</p>
<p>待填充的图像用二维数组 image 表示，元素为初始颜色值。初始坐标点的横坐标为 sr 纵坐标为 sc。需要填充的新颜色为 newColor 。</p>
<p>「周围区域」是指颜色相同且在上、下、左、右四个方向上存在相连情况的若干元素。</p>
<p>请用新颜色填充初始坐标点的周围区域，并返回填充后的图像。</p>
 <a id="more"></a>

<p>示例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">image = [[1,1,1],[1,1,0],[1,0,1]] </span><br><span class="line">sr = 1, sc = 1, newColor = 2</span><br><span class="line">输出：[[2,2,2],[2,2,0],[2,0,1]]</span><br><span class="line">解释: </span><br><span class="line">初始坐标点位于图像的正中间，坐标 (sr,sc)=(1,1) 。</span><br><span class="line">初始坐标点周围区域上所有符合条件的像素点的颜色都被更改成 2 。</span><br><span class="line">注意，右下角的像素没有更改为 2 ，因为它不属于初始坐标点的周围区域。</span><br></pre></td></tr></tbody></table></figure>


<p>提示：</p>
<ul>
<li>image 和 image[0] 的长度均在范围 [1, 50] 内。</li>
<li>初始坐标点 (sr,sc) 满足 0 &lt;= sr &lt; image.length 和 0 &lt;= sc &lt; image[0].length 。</li>
<li>image[i] [j] 和 newColor 表示的颜色值在范围 [0, 65535] 内。</li>
</ul>
<h2 id="🌸解法：DFS"><a href="#🌸解法：DFS" class="headerlink" title="🌸解法：DFS"></a>🌸解法：DFS</h2><p>因为只是修改颜色，所以不需要记录路径，只需要4个方向暴力搜索就行.</p>
<p>模板</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if (越界||路径不能走){</span><br><span class="line">    return;</span><br><span class="line">}</span><br><span class="line">image[x][y] = newColor;    //标记，更换颜色</span><br><span class="line">for (int k = 0; k &lt; 4; k++){</span><br><span class="line">    helpfunc(image, x + next[k][0], y + next[k][1], oldColor, newColor);</span><br><span class="line">}</span><br><span class="line">//如果需要回溯，在这里进行恢复</span><br><span class="line">//image[x][y] = unchange_val;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="一个小坑"><a href="#一个小坑" class="headerlink" title="一个小坑"></a>一个小坑</h3><p>​      如果起始点的颜色本来就是目标颜色，那么就不需要进行遍历更改。因为所有从起始点可达且颜色相同的点，它们的颜色也都已经是目标颜色了，不必更改；而与起始点颜色不同的那些点，本来就不能更改，所以不需要进行遍历</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) {</span><br><span class="line">	dfs(image, sr, sc, image[sr][sc], newColor);</span><br><span class="line">	<span class="keyword">return</span> image;</span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> val, <span class="keyword">int</span> newColor)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span>(sr &lt; <span class="number">0</span> || sr &gt; image.length - <span class="number">1</span> || sc &lt; <span class="number">0</span> || sc &gt; image[<span class="number">0</span>].length - <span class="number">1</span> || image[sr][sc] != val || val == newColor) {</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}<span class="keyword">else</span> {</span><br><span class="line">		image[sr][sc] = newColor;</span><br><span class="line"></span><br><span class="line">		dfs(image, sr + <span class="number">1</span>, sc, val, newColor);</span><br><span class="line">		dfs(image, sr, sc + <span class="number">1</span>, val, newColor);</span><br><span class="line">		dfs(image, sr - <span class="number">1</span>, sc, val, newColor);</span><br><span class="line">		dfs(image, sr, sc - <span class="number">1</span>, val, newColor);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM基础数学</title>
    <url>/ACM_basic_mathematics/</url>
    <content><![CDATA[<p><strong>1.最大公约数，最小公倍数</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> z=y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(x%y!=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        z=x%y;</span><br><span class="line"></span><br><span class="line">        x=y;</span><br><span class="line"></span><br><span class="line">        y=z；</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x*y/gcd(x,y);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<p><strong>2.快速幂</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> mod)</span><span class="comment">//a^b</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            t=(t*a)%mod;</span><br><span class="line">            b--;</span><br><span class="line">        }</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> t;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>&gt;&gt;矩阵快速幂 很久以前收集的模板，亲测可用</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> m[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">Mul</span><span class="params">(Matrix a,Matrix b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    Matrix c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(c.m,<span class="number">0</span>,<span class="keyword">sizeof</span>(c.m));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)</span><br><span class="line"></span><br><span class="line">                c.m[i][j] += ((a.m[i][k]*b.m[k][j])%SMod + SMod)%SMod;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">fastm</span><span class="params">(Matrix a,<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Matrix res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(res.m,<span class="number">0</span>,<span class="keyword">sizeof</span>(res.m));</span><br><span class="line"></span><br><span class="line">    res.m[<span class="number">0</span>][<span class="number">0</span>] = res.m[<span class="number">1</span>][<span class="number">1</span>] = res.m[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">            res = Mul(res,a);</span><br><span class="line"></span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a = Mul(a,a);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">MPow</span><span class="params">(Matrix a,<span class="keyword">int</span> n)</span>  <span class="comment">//第二种写法,慎用,易RE</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">    Matrix res = fastm(a,n/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    res = Mul(res,res);</span><br><span class="line">   <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        res = Mul(res,a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>另外一种</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"></span><br><span class="line">    lll m[<span class="number">13</span>][<span class="number">13</span>];</span><br><span class="line"></span><br><span class="line">    Matrix()</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++)</span><br><span class="line"></span><br><span class="line">            m[i][i] = <span class="number">1L</span>L;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">Mul</span><span class="params">(Matrix a,Matrix b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    Matrix res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++)</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n+<span class="number">2</span>;j++)</span><br><span class="line"></span><br><span class="line">        {</span><br><span class="line"></span><br><span class="line">            res.m[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n+<span class="number">2</span>;k++)</span><br><span class="line">                res.m[i][j] = (res.m[i][j]+(a.m[i][k]*b.m[k][j])%SMod + SMod)%SMod;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">fastm</span><span class="params">(Matrix a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    Matrix res;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            res = Mul(res,a);</span><br><span class="line">        a = Mul(a,a);</span><br><span class="line"></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>对元素0较多的矩阵取快速幂时可在Mul函数中加一个小优化：</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Matrix <span class="title">Mul</span><span class="params">(Matrix a,Matrix b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Matrix res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(res.m,<span class="number">0</span>,<span class="keyword">sizeof</span>(res.m));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n+<span class="number">2</span>;k++)</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(a.m[i][k])</span><br><span class="line"></span><br><span class="line">            {</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n+<span class="number">2</span>;j++)</span><br><span class="line"></span><br><span class="line">                    res.m[i][j] = (res.m[i][j]+(a.m[i][k]*b.m[k][j])%SMod + SMod)%SMod;</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>3.排列组合</strong></p>
<p><strong><img src="https://images2018.cnblogs.com/blog/1458413/201808/1458413-20180806171419851-479703983.png" alt="img"></strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">A</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span><span class="comment">//n&gt;=m</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        ans*=n;</span><br><span class="line">  n--;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n&lt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> A(n,m)/A(m,m);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> 组合数性质：从这看到的：<a href="https://blog.csdn.net/litble/article/details/75913032" target="_blank" rel="noopener">https://blog.csdn.net/litble/article/details/75913032</a></p>
<p><img src="https://images2018.cnblogs.com/blog/1458413/201808/1458413-20180807092033984-886826912.png" alt="img"></p>
<p><img src="https://images2018.cnblogs.com/blog/1458413/201808/1458413-20180807092042262-2121295377.png" alt="img"></p>
<p><img src="https://images2018.cnblogs.com/blog/1458413/201808/1458413-20180807092055838-1849485820.png" alt="img"></p>
<p><img src="https://images2018.cnblogs.com/blog/1458413/201808/1458413-20180807092106829-1242924198.png" alt="img"></p>
<p><img src="https://images2018.cnblogs.com/blog/1458413/201808/1458413-20180807092115984-915400971.png" alt="img"></p>
<p><img src="https://images2018.cnblogs.com/blog/1458413/201808/1458413-20180807092130715-1600490627.png" alt="img"></p>
<p><img src="https://images2018.cnblogs.com/blog/1458413/201808/1458413-20180807092226548-1935049046.png" alt="img"></p>
<p><strong>4.错排</strong></p>
<p><strong>D(n) = (n-1) [D(n-2) + D(n-1)]（n物品全部错位的方案数）</strong></p>
<p><strong>D(n) = n! [(-1)^2/2! + … + (-1)^(n-1)/(n-1)! + (-1)^n/n!].</strong></p>
<p><strong>记住公式就知道代码了</strong></p>
<p><strong>5.费马小定理：</strong> 假如p是<a href="https://baike.baidu.com/item/质数" target="_blank" rel="noopener">质数</a>，且gcd(a,p)=1，那么 a^(p-1)≡1(mod p)。（如果a为整数，p为质数，a和p互质，则a的p-1次幂对p取模永远等于1）</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM传奇之路(紧握着自己颤抖的双手)</title>
    <url>/acm_road/</url>
    <content><![CDATA[<p>从我接触程序竞赛到现在应该有十多年了，单说ACM竞赛，从第一次非正式参赛到现在也差不多有7年多的样子。有太多的故事，想说的话，却一直没能有机会写下来。一方面是自己忙，一方面也是自己懒。所以很感谢能有人“逼”我来写点什么。想到会有很多人来读我写的文字，自己也觉得很开心。其实每个人的生活都是一部电影，只是没有那么多幸运的人有机会去诉说。这里，且说三个小故事。 </p>
<a id="more"></a>

<p>一个关于仰望，崇拜和梦想的故事 </p>
<p>2000年，有一个天才的高中生，在IMO（国际数学奥林匹克竞赛）中以满分获得了金牌并提前一年进入北大读书。在他前往北大之前，他受邀到他毕业的小学给了一个演讲。而听众里面有一个三年级的小正太，演讲啥也没记住，倒是在心里埋下了一个小小的梦想：“我也想代表中国去拿金牌”。 </p>
<p>10年后这个天才高中生博士毕业，并受邀回到他毕业的高中又给了一个演讲，当年的小正太变成了少年，又恰好在听众席里。这个少年刚刚入选了信息学奥林匹克中国国家队，将代表中国去加拿大参加国际比赛。 </p>
<p>这个天才高中生叫恽之玮，拉马努金奖得主，目前在斯坦福大学任教；而那个小正太，也就是那个少年，后来非常丢人的拿到了国际比赛的银牌，又在ACM竞赛圈子里晃悠了一圈，现在也跑到美国读博士了。很不幸，世界没能狗血到再度产生一个莫扎特和贝多芬的故事。少年自然没法和天才相比拟，不过起码在需要写写文字的时候，少年的故事可以这样开头：“我有一个梦想”。 </p>
<p>小学的时候参加计算机兴趣小组，从那里接触了编程。不过，要说真正被带入了程序竞赛这条不归路，那还得归功于我的恩师，常州高级中学的曹文老师的顶级忽悠能力。 </p>
<p>我从初一开始跟着曹老师学习信息学竞赛，曹老师最喜欢有事没事的扯他过去的学生的故事，以及竞赛圈里的八卦。也正是那个时候，从曹老师的口中，我知道了世界上还有ACM这么个玩意。还记得某一天，曹老师又在胡侃：“ACM比赛一共有4所大学夺得过2次世界冠军：上海交通大学，圣彼得堡ITMO，华沙大学还有斯坦福大学。”说出来不怕笑话，这也是我第一次听到斯坦福大学这个名字。所以斯坦福大学给我的第一印象就是：两次世界冠军的学校！说句题外话：因为恽之玮的原因，我喜欢了北大很长时间，也因为曹老师的这句胡侃，让斯坦福成了我最向往的大学；不过造化弄人，我的本科在北大的隔壁度过，而博士，又跑到了斯坦福的隔壁。 </p>
<p>曹老师八卦的性格，也潜移默化的影响了我。平时没事的时候，就特别喜欢翻阅往年的OI比赛的成绩单，还有ACM世界总决赛的名单。直到现在，我都可以如数家珍的说出之前近10年的信息学竞赛中国国家队（甚至美国国家队）的队员名单，或者ACM世界总决赛清华，交大的队员名字，以及他们的名次。对于一个初中的孩子，翻着这些名字，听着这些故事，我无法用言语描述那是我心中的激动，好像这些故事，发生在一个无与伦比的，广阔的世界，而这些名字，就犹如夜空中的星星一样，闪耀，夺目。后来的很多年中，我很有幸几乎全部见过或者接触过了这些当年在我心中犹如浩瀚星辰般的神们。他们应该很难想象，当我第一次见到他们的激动的心情。那种感觉，和歌迷见到他们的偶像一样。那时候心中埋藏很多年的小小的执念，也不过就是见他们一次。甚至直到现在，对一些人，还是这样。 </p>
<p>初中的时候最喜欢参加省里的夏令营，冬令营，那时候年纪小，最喜欢跟在师兄的后面，听着师兄们讲着我听不懂的算法，打着我没玩过的游戏（我对仙剑的执念也是从那个时候开始的）；初三的暑假我有幸到了上海交通大学ACM队训练了一个月，作为一个初中生，我第一次见到了，国内顶尖的大学，顶尖的大学生是怎么样的，也遇到了我无比尊敬和感恩的，上海交通大学ACM班的俞勇老师；到了高中开始以非正式队伍的身份参加ACM区域赛，也就总算可以亲眼看一看，那些传说中的人，还可以冲上去和他们合一张影，然后激动的晚上睡不着觉；上了大学，大二暑假我到美国Facebook公司总部实习，在湾区见到了更老一辈的，那些如雷贯耳的名字。 </p>
<p>光阴荏苒，时光匆匆流逝，好些画面在心里依然是那么清晰。讲讲那些名字吧。初中每次参加省里组织的信息学冬令营夏令营都会嚷嚷，我要是能见一面朱泽园（IOI金牌，ACM总决赛亚军，MIT博士）就好了，后来高二时在ACM杭州赛区总算见到了，当时还见到了他的两位队友：楼天成（楼教主，圈内人士应该都很熟悉）和周源（IOI满分，ACM总决赛亚军，CMU博士），当时捧着那张合影，简直比拿了冠军还激动；初三暑假在交大，第一次在机房里见到了仰慕已久的戴文渊（ACM世界冠军，目前就职于华为诺亚方舟实验室），后来每次只要有机会都要蹦蹦跳跳的跑去找戴文渊合影；高一在ACM南京赛区，第一次见到了唐文斌（ACM总决赛世界第六，Face++ CEO），以及他的两个队友王栋（IOI金牌）和龙凡（IOI金牌，MIT博士），当然还见到了因为比砸了心情不好而拒绝我合影请求的郭华阳（IOI金牌，就职于Facebook）。当时我可能做梦也想不到，过了若干年，我会和唐文斌一起坐在火车的餐车地上打牌，会和郭华阳在纽约曼哈顿睡上下铺。后来进了大学，和贝小辉成了好朋友，楼天成成了我的助教，胡伟栋（IOI金牌，ACM世界亚军）会请我吃饭；我更不会想到，再后来，张一飞（IOI两枚金牌得主，就职于Facebook）会给我推荐简历，我会和符文杰（中国唯一IOI，IMO双国家队成员，就职于Facebook）一起吃饭，和侯启明（NOI历史上唯一的满分，IOI金牌，浙江大学副教授）一起扯淡。当然了，进入大学以后，我不会再端着相机四处合影了。 </p>
<p>现在看，这些名字也很普通，也很平常，很多过去的故事，可能在茶余饭后都不会被提起了。但是世界上毕竟有这么一个小故事曾发生过：在很多很多年前，曾经有一个小正太，每天念叨着这些名字，在心里埋下小小的梦想，然后一步一步的，他见到了这些他成天念叨的人，和他们成了朋友。多年以后，他的梦想本身，也许此时正化作一个淡然的微笑。 </p>
<p>一个关于固执，坚持和自信的故事 </p>
<p>从小学开始参加信息学比赛，高一开始参加ACM区域赛，一直到现在博士还在参赛。这么多年了，有时自己都会感慨。每年参加比赛这件事情，好像已经快成为我生活的一部分了。记得有一次在ACM区域赛的时候发言，我说ACM是我的初恋，现在看，可能ACM成了我的生活了吧。懵懂，热烈，坚持，淡然，其实爱情也不过如此，最后所有的一切，都化作了生活。 </p>
<p>很多人问我，这么多年了你怎么还在参赛呢，花费这么多精力，时间，到底是为什么呢？其实我也快说不清楚了。很小很小的时候，那时候教数学奥赛的老师嫌我贪玩训斥我鄙视我的智商。小孩子自尊心总是特别强，想着我换个地方证明我比那些你喜欢的人都厉害，最后差不多是做到了；到了初中，我想比那些师兄师姐们都厉害，要做全国一流的选手，后来差不多也做到了；到了高中发现好像在我身边的师兄，同学超不过了（提一下，有一个高中师兄叫金斌，TCO世界冠军，ACM总决赛冠军亚军各一次，还有一个高中师兄叫吴卓杰，ACM总决赛冠军，目前都就职于Google），我就想我可以到了大学参加ACM，在ACM赛场上超过他们；到了大学，做工程的不断实习做项目，做科研的一篇接一篇的发论文，刷GPA的几乎每门课都是满分。我看看自己似乎没有一样能做到最好的，于是就想，要不然就做一个科研界ACM比的最好的，而ACM界又科研做的最好的人吧；再到后来，我知道世界上还有Percy Liang（斯坦福大学助理教授，ACM总决赛亚军），Matei Zaharia（MIT助理教授，Spark的开发者，ACM总决赛第四）这些人，遂发现自己实在是差距太大了，实在连个理由都编不出了（也许可能是常州方言讲的最好的？）。可能这个时候，ACM对我而言，更像是对自己的敬礼。毕竟，自己已经坚持了很久很久，从江南，到帝都，再到美利坚加利福尼亚。就像唱一首歌，跳一支舞，写一段文字，哪怕根本没有观众，也总希望能够最后落下伴着微笑的句点。做一件事不一定非要有一个意义，因为坚持的本身，就有意义，也因为，坚持总能伴着一份感动，时不时的在心中翻涌。 </p>
<p>坚持是要有信念的，信念是什么？当然是“赢”。想想还挺不容易也挺可笑的，到现在还在乎着输赢，尤其输赢已经早就没有了意义。不过也不那么可笑，因为我并不执念。“赢”也许只是对生活的热情的简写吧。小时候想打败所有的人，做最好的选手，结果过了十年参加国际比赛拿了块丢人的银牌，在中国队里垫了底；高中参加ACM，每次都为击败一支清华的队伍感到振奋，而当自己到了清华，第一次参赛就在清华内部排在了最后；大学幻想着以自己作为队伍的核心战斗力，代表清华拿冠军，参加总决赛，结果连续拿到了4次区域赛的亚军（清华的规矩是，只有冠军才有资格代表学校参加总决赛），并且其中三次都是在最后时刻被反超，同题数输罚时；大三那年总算进了总决赛，幻想着能够屌丝逆袭一次进个前八，结果最后惊险拿到了领奖队伍的最后一名（总决赛一共12支队伍可以获得奖牌，金银铜各4支，我在2013年的总决赛获得第12名），并且还输给了CMU（后来在CMU遇到了他们的教练，被调侃：“Oh, we beat you, right?”）；大四练了很久的俄罗斯风格的题目，想着再去一次在俄罗斯举办的总决赛，证明一下自己，结果在最后一次区域赛输给了当时完美发挥的交大，最后甚至连亚军都没有拿到。今年8月我在加州大学伯克利分校开始了自己博士生涯。很有幸，我找到了两个老朋友作为自己的队友，然后我们轻松的拿到了西北太平洋赛区的冠军。于是，我可以代表加州大学伯克利分校，参加5月份的ACM世界总决赛了。这是我的第二次总决赛，也将是最后一次。不过我希望后面的故事不要再继续按照之前的走势了。 </p>
<p>这里着重说一下我大三那年（2012）参加ACM的经历。当年我们的队名叫Again And Again，理由很简单，队里面三个人，我，毛杰明（IOI金牌，目前在普林斯顿读博士），莫涛（NOI第一，目前在香港中文读博士），在过去的2年里（2010和2011）分别参加过8个不同的赛区，一共获得了其中的6个亚军，并且又在2012年的长春赛区，一起携手拿到了我们的第7个亚军。9次比赛7次亚军，我想这个记录也是挺难超越的了。 </p>
<p>我是一个固执的人，一旦认定的事情很难再被改变；我也是一个幸运的人，大部分我认定的事情都起码没有失败。也许，老天真的会偏爱一个愿意一直仅仅因为喜欢而坚持的人吧。中学的时候，大部分时间都是我一个人呆在机房里，或者一个人在家里抱着电脑想问题，那时候参加编程比赛是有理有据的，因为可以保送大学，可以给学校争光，家长和学校也都支持。到了清华，事情就不一样了。我知道，现在参加程序比赛越来越多的有了功利性，拿奖可以保研，可以找工作，或者给学校给领导争光。不过这些理由在清华，都是不成立的。我的大部分天才同学们，都在北美最好的学校读博士，至于给学校和领导争光，我想也许我们拿到了世界冠军，可能会有机会上一次清华首页吧，不过这也只是我的猜测——毕竟清华从来没有在ACM总决赛上夺冠过。清华没有什么ACM队，没有ACM训练或者选拔，也没有什么奖金或者评优加分。在清华，ACM不过是众多学生活动中普通的一项。我们这些老人有一个老笑话：“如何在开幕式迅速识别出清华的学生？在那里做作业的！”在很多学校，也许有很多ACM队的黑话，传统，故事；而清华也有他自己的故事，这些故事可能最特别也最普通。特别在于，清华也有与众不同的故事，不过这些故事几乎没有单纯关于ACM的：比如鬲融的故事（清华的一段传说，计算机系历史最高GPA，IOI金牌，ACM总决赛亚军，普林斯顿大学博士），周源的故事，或者楼天成的故事；普通在于，这些故事并没有一个明确的标签，ACM比赛只是这些故事里面，很小很小的一部分。大家是清华人，要做最好的学生，要发论文，要搞好课业，要跑3000米，只是大家都喜欢ACM，觉得她有趣。 </p>
<p>“有趣”二字，说来轻巧，可是，我似乎也找不出更好的词汇来评价ACM这项活动了。读博士了之后很多人劝我说：“你都读博士了还玩这些年轻人的活动。”我同意这个观点。不过因为我还是觉得参加ACM很有趣，所以我又固执的接着参加了。于是作为一个老博士，我又得继续忽悠着同为博士的队友们在周末抽出时间来训练，继续在闲着无聊的时候作着我自己关于“赢”的春秋大梦。 </p>
<p>一个关于青春，热情和友谊的故事 </p>
<p>参加ACM ICPC竞赛，给了我太多太多美好的回忆，让我收获了太多太多宝贵的友谊。每当回忆翻涌，总会感慨当时的纯粹，热情和真挚——自己也算，有一段奋斗过的青春。 </p>
<p>初三的暑假和两个师兄，吴沛凡（目前在纽约大学读经济博士）和金斌在上海交大ACM队训练了一个月。期间每天上午做一套真题，下午修订和讨论。还记得那时候金斌第一次洗冷水澡的时候爆发出的惊人惨叫；记得最后一部哈利波特问世，我晚上拽着沛凡给我恶补哈利波特；记得第一次知道交大的BBS叫未名，清华的BBS叫水木；记得第一次知道了当时还得审核大学生身份的人人网，当时吴卓杰还用人人网的bug玩上面买车位的网页游戏；记得第一次去问交大师姐一道题怎么做的时候红着脸踌躇了好半天；记得当时更老的师兄们骑车载着我们去吃盖浇饭；更记得第一次三人组队赢了交大一队时候的兴奋和激动；也记得第一次见到交大ACM班的俞勇老师时候的胆怯和害羞……那段时光是我整个中学生涯中最好的时光，每天都很快乐，每天都有进步。我不得不承认，从那时候开始，交大成了我高中时期最向往的地方：为了去交大而不去清华，我还在高三的时候和我的妈妈进行了接近三个月的激烈斗争。好多好多年过去了，当年的ACM队师兄师姐们，早就工作，或者快博士毕业了；三个坐在后座的小屁孩，现在两个在读博士，一个拿了世界冠军，去了谷歌；俞勇老师老了很多岁。据我很多交大的同学说，俞勇老师很严厉。也许正因为我没真正做过俞老师的学生，所以起码在我这里，俞老师给我的印象是一个温和负责的导师，每次我参加比赛见到俞老师，都会特别亲切的打招呼，交谈。也许我应该对我去了清华感到庆幸吧，因为，从此交大在我心里就只留下了她最美好的样子。 </p>
<p>大学在清华碰到了毛杰明和莫涛两个死党，一起吃外卖，一起互黑，一起旅游。那时候我自封后勤队长（其实我在每一个队伍里的角色都是这个），负责研究去什么赛区，每次协调大家什么时候训练，训练什么题，还负责代购火车票飞机票以及和教练沟通，并且乐此不疲。他俩也待我不薄，因为毛杰明，我在大学里少走了很多弯路，又因为莫涛，让我多了一个特别铁杆的基友。 </p>
<p>2011年福州赛区，只要另一支清华的队伍不能在30分钟内通过最后一题，我和毛杰明就能晋级总决赛。只是很可惜，20分钟后，那支队伍前，升起了对应颜色的气球。我还清楚的记得，在回程的飞机上，心情郁闷的我和厦门航空的空乘吵了起来。毛杰明不停的安慰我不用跟人一般见识。我后来又去过不少次福建，不过也再没做过厦门航空的飞机。 </p>
<p>2012年我和毛杰明还有莫涛组队。那年的长春赛区，比赛前我们三个吃牛排刮出了一张奖励2元钱的发票，要知道当时我们已经拿了6次亚军了。莫涛觉得2元钱太晦气，还刻意第二天早上给服务员送出1元的小费希望讨个吉利。结果赛场上，我们站在中山大学的身后，近距离目睹了他们在比赛结束后5分钟得到系统返回的一个YES，并以罚时优势将我们反超并夺冠的欣喜若狂。更狗血的是，在接下来的由中山大学负责命题的天津赛区，有一道题目和之前在长春赛区中山反超我们的那题一模一样。于是，在中大的好心保送下，我们总算拿到了冠军。 </p>
<p>2013年圣彼得堡的总决赛，从来不喝咖啡的我在赛前喝了咖啡，不过似乎咖啡对于紧张没有什么好的疗效。虽然这么多年来我每逢ACM比赛都会紧张，心跳加速，血压升高，不过那一天似乎大家都紧张的特别严重：场上三个人对着两道题看了1个多小时居然都不会做，而一出赛场就都会了。回忆到当时看结果公布时自己的焦虑和不安，我觉得以后估计也不会有机会能够让自己的心律比那个时候更快一点了。记得比赛入场的时候我和我的一个俄罗斯朋友，当时莫斯科大学的选手Sergey握了一个手，然后那一年莫斯科大学和我们都拿了铜牌。毛杰明和莫涛都说，估计是我吸来了莫斯科大学的仙气，把人家拉成了铜牌，把我们从胸牌，提到了奖牌。这事我后来一直没好意思和Sergey说，希望他不会在心里骂我。 </p>
<p>2013年下半年，毛杰明去了普林斯顿读博士，我和莫涛拉来了陈高远（Topcoder Target，USC硕士在读）。我们三个大四狗组了个队，唤作“老流氓”。作为流氓头子，我愣是自己联系，办理手续，然后忽悠另外两个老家伙们掏出了之前的比赛的奖金买了飞往日本的机票，使我们队成为了近10年来清华第一支参加海外ACM赛区的队伍（清华由于经费不够，加上一些历史原因，是不参加海外赛区的）。比赛比的很糟，不过三个老家伙在富士山下泡温泉，在东京米其林餐厅吃寿司，爬东京塔也是挺值得怀念的。还记得当时莫涛痴迷某日剧（具体原因我后来黑了他好久），我们被忽悠着整个一天东京的行程都按照剧里男主和女主的约会路线进行。傍晚，在东京的台场，莫涛望着远处的彩虹桥，掏出了他的iTouch和我说：“你看，剧里就是这个位置，这个角度，这个时间！”那荡漾的眼神，一定会成为未来很多很多年，一个关于莫涛的经典槽点。 </p>
<p>2014年，我来到了加州伯克利大学读博士。很幸运，我遇到了两个也再读博士的中国队友，姜碧野（NOI2009金牌，在清华ACM区域赛和莫涛一起拿过3次亚军，代表伯克利参加了2014年ACM总决赛）和赖陆航（数学博士，IOI2010金牌，代表北大参加了2011年ACM总决赛），组成了伯克利中国队。于是我又开始了我后勤部长兼队内主码的身份——反正我对这个角色早已驾轻就熟。我们很轻松的晋级了2015年5月份将在摩洛哥举行的ACM总决赛。这对我们三个人来说，都是第二次，也是最后一次总决赛，也将是竞赛生涯的最后一场比赛了。想想时间过得真快，从一个小孩到一个博士，关于青春的故事，也终要画上句号了。 </p>
<p>这段青春里，有太多有趣的事，有趣的人。很多很多年以后，这些说不完、道不尽，也都化为老友相聚时的调侃和相逢一笑。我觉得，这也许就是生活里，最美的喜剧。 </p>
<p>最后的一些话 </p>
<p>这是我的故事，感谢我有这个机会能把我的故事写下来，也感谢前来阅读的人。ACM不是生活的全部，甚至连一小部分都算不上——就像，写完这些文字，我还得抓紧时间继续准备我的论文，继续我的研究工作。也确实是这样，一个人的生活应该是丰富的，充实的和多彩的。生活应当像浩瀚的宇宙，壮阔却又静谧，ACM不过是那绚烂星辰中的一颗。宇宙不应因为少了一颗星而暗淡，但是却可能因为多了一颗星而多了一段璀璨的文明。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS_leetcode.22.括号生成</title>
    <url>/bracket_generating/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[</span><br><span class="line">       "((()))",</span><br><span class="line">       "(()())",</span><br><span class="line">       "(())()",</span><br><span class="line">       "()(())",</span><br><span class="line">       "()()()"</span><br><span class="line">     ]</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<h2 id="🌸解法一：暴力DFS"><a href="#🌸解法一：暴力DFS" class="headerlink" title="🌸解法一：暴力DFS"></a>🌸解法一：暴力DFS</h2><p>我们可以生成所有$ 2^{2n}$ 个 <code>'('</code> 和 <code>')'</code> 字符构成的序列，然后我们检查每一个是否有效即可。</p>
<p>为了生成所有序列，我们可以使用递归。长度为 n 的序列就是在长度为 n-1 的序列前加一个 ‘(‘ 或 ‘)’。</p>
<p>为了检查序列是否有效，我们遍历这个序列，并使用一个变量 balance 表示左括号的数量减去右括号的数量。如果在遍历过程中 balance 的值小于零，或者结束时 balance 的值不为零，那么该序列就是无效的，否则它是有效的</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	dfs(<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span> * n], <span class="number">0</span>, res);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] cur, <span class="keyword">int</span> pos, List&lt;String&gt; res)</span> </span>{</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="keyword">if</span>(pos == cur.length) {</span><br><span class="line">		<span class="keyword">if</span>(valid(cur)) {</span><br><span class="line">			res.add(<span class="keyword">new</span> String(cur));</span><br><span class="line">		}</span><br><span class="line">	}<span class="keyword">else</span> {</span><br><span class="line">		cur[pos] = <span class="string">'('</span>;</span><br><span class="line">		dfs(cur, pos + <span class="number">1</span>, res);</span><br><span class="line">		cur[pos] = <span class="string">')'</span>;</span><br><span class="line">		dfs(cur, pos + <span class="number">1</span>, res);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">char</span>[] cur)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> balance = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c : cur) {</span><br><span class="line">		<span class="keyword">if</span>(c == <span class="string">'('</span>) {</span><br><span class="line">			balance++;</span><br><span class="line">		}<span class="keyword">else</span> {</span><br><span class="line">			balance--;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(balance &lt; <span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> balance == <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>python</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(A)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(A) == <span class="number">2</span>*n:</span><br><span class="line">                <span class="keyword">if</span> valid(A):</span><br><span class="line">                    ans.append(<span class="string">""</span>.join(A))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A.append(<span class="string">'('</span>)</span><br><span class="line">                generate(A)</span><br><span class="line">                A.pop()</span><br><span class="line">                A.append(<span class="string">')'</span>)</span><br><span class="line">                generate(A)</span><br><span class="line">                A.pop()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(A)</span>:</span></span><br><span class="line">            bal = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> A:</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">'('</span>: bal += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: bal -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bal &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> bal == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        generate([])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸解法二：-DFS剪枝"><a href="#🌸解法二：-DFS剪枝" class="headerlink" title="🌸解法二： DFS剪枝"></a>🌸解法二： DFS剪枝</h2><ul>
<li><p>当前左右括号都有大于 0个可以使用的时候，才产生分支；</p>
</li>
<li><p>产生左分支的时候，只看当前是否还有左括号可以使用；</p>
</li>
<li><p>产生右分支的时候，还受到左分支的限制，右边剩余可以使用的括号数量一定得在严格大于左边剩余的数量的时候，才可以产生分支</p>
</li>
<li><p>在左边和右边剩余的括号数都等于 0 的时候结算。</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generateParenthesis2</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="comment">//特判</span></span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//回溯</span></span><br><span class="line">	dfs2(<span class="string">""</span>, n, n, res);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cur 当前递归得到的结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左括号还有几个可以使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 右括号还有几个可以使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> res 结果集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(String cur, <span class="keyword">int</span> left, <span class="keyword">int</span> right, List&lt;String&gt; res)</span> </span>{</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="comment">//因为每一次尝试，都使用新的字符串变量，所以无需回溯</span></span><br><span class="line">	<span class="comment">//在递归结束的时候，直接把他添加到结果集即可，</span></span><br><span class="line">	<span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) {</span><br><span class="line">		res.add(cur);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//剪枝（左括号可使用个数严格大于右括号使用个数，才剪枝）</span></span><br><span class="line">	<span class="keyword">if</span>(left &gt; right) {</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(left &gt; <span class="number">0</span>) {</span><br><span class="line">		dfs2(cur + <span class="string">"("</span>, left - <span class="number">1</span>, right, res);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(right &gt; <span class="number">0</span>) {</span><br><span class="line">		dfs2(cur + <span class="string">")"</span>, left, right - <span class="number">1</span>, res);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>python</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        cur_str = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur_str, left, right)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            :param cur_str: 从根结点到叶子结点的路径字符串</span></span><br><span class="line"><span class="string">            :param left: 左括号还可以使用的个数</span></span><br><span class="line"><span class="string">            :param right: 右括号还可以使用的个数</span></span><br><span class="line"><span class="string">            :return:</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">and</span> right == <span class="number">0</span>:</span><br><span class="line">                res.append(cur_str)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> right &lt; left:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; <span class="number">0</span>:</span><br><span class="line">                dfs(cur_str + <span class="string">'('</span>, left - <span class="number">1</span>, right)</span><br><span class="line">            <span class="keyword">if</span> right &gt; <span class="number">0</span>:</span><br><span class="line">                dfs(cur_str + <span class="string">')'</span>, left, right - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        dfs(cur_str, n, n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法三：-DFS剪枝（做加法）"><a href="#🌸解法三：-DFS剪枝（做加法）" class="headerlink" title="🌸解法三： DFS剪枝（做加法）"></a>🌸解法三： DFS剪枝（做加法）</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generateParenthesis3</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="comment">//特判</span></span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//回溯</span></span><br><span class="line">	dfs3(<span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, n, res);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cur 当前递归得到的结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左括号已经用了几个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 左括号、右括号一共得用几个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> res 结果集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(String cur, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> n, List&lt;String&gt; res)</span> </span>{</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="comment">//因为每一次尝试，都使用新的字符串变量，所以无需回溯</span></span><br><span class="line">	<span class="comment">//在递归结束的时候，直接把他添加到结果集即可，</span></span><br><span class="line">	<span class="keyword">if</span>(left == n &amp;&amp; right == n) {</span><br><span class="line">		res.add(cur);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//剪枝（左括号可使用个数严格大于右括号使用个数，才剪枝）</span></span><br><span class="line">	<span class="keyword">if</span>(left &lt; right) {</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(left &lt; n) {</span><br><span class="line">		dfs3(cur + <span class="string">"("</span>, left + <span class="number">1</span>, right, n, res);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(right &lt; n) {</span><br><span class="line">		dfs3(cur + <span class="string">")"</span>, left, right + <span class="number">1</span>, n, res);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        cur_str = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur_str, left, right, n)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            :param cur_str: 从根结点到叶子结点的路径字符串</span></span><br><span class="line"><span class="string">            :param left: 左括号已经使用的个数</span></span><br><span class="line"><span class="string">            :param right: 右括号已经使用的个数</span></span><br><span class="line"><span class="string">            :return:</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> left == n <span class="keyword">and</span> right == n:</span><br><span class="line">                res.append(cur_str)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left &lt; n:</span><br><span class="line">                dfs(cur_str + <span class="string">'('</span>, left + <span class="number">1</span>, right, n)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> right &lt; n:</span><br><span class="line">                dfs(cur_str + <span class="string">')'</span>, left, right + <span class="number">1</span>, n)</span><br><span class="line"></span><br><span class="line">        dfs(cur_str, <span class="number">0</span>, <span class="number">0</span>, n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法四：-BFS"><a href="#🌸解法四：-BFS" class="headerlink" title="🌸解法四： BFS"></a>🌸解法四： BFS</h2><p>广度优先遍历，得自己编写结点类，显示使用队列这个数据结构。深度优先遍历的时候，就可以直接使用系统栈，在递归方法执行完成的时候，系统栈顶就把我们所需要的状态信息直接弹出，而无须编写结点类和显示使用栈。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前得到的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String res;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 剩余左括号数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> left;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 剩余右括号数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String res, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.res = res;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node{"</span> +</span><br><span class="line">                <span class="string">"res='"</span> + res + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", left="</span> + left +</span><br><span class="line">                <span class="string">", right="</span> + right +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis4</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(<span class="keyword">new</span> Node(<span class="string">""</span>, n, n));</span><br><span class="line">    <span class="comment">// 总共需要拼凑的字符总数是 2 * n</span></span><br><span class="line">    n = <span class="number">2</span> * n;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            Node curNode = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (curNode.left &gt; <span class="number">0</span>) {</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Node(curNode.res + <span class="string">"("</span>, curNode.left - <span class="number">1</span>, curNode.right));</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (curNode.right &gt; <span class="number">0</span> &amp;&amp; curNode.left &lt; curNode.right) {</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Node(curNode.res + <span class="string">")"</span>, curNode.left, curNode.right - <span class="number">1</span>));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        n--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一层就是题目要求的结果集</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        res.add(queue.poll().res);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸解法四：动态规划"><a href="#🌸解法四：动态规划" class="headerlink" title="🌸解法四：动态规划"></a>🌸解法四：动态规划</h2><p><strong>第 1 步：定义状态 dp[i]</strong>：使用 i 对括号能够生成的组合。</p>
<p><strong>注意</strong>：每一个状态都是列表的形式。</p>
<p>第 2 步：状态转移方程：</p>
<ul>
<li>i 对括号的一个组合，在 i - 1 对括号的基础上得到，这是思考 “状态转移方程” 的基础；</li>
<li>i 对括号的一个组合，一定以左括号 “(“ 开始，不一定以 “)” 结尾。为此，我们可以枚举新的右括号 “)” 可能所处的位置，得到所有的组合；</li>
<li>枚举的方式就是枚举左括号 “(“ 和右括号 “)” <strong>中间可能的合法的括号对数</strong>，而剩下的合法的括号对数在与第一个左括号 “(“ 配对的右括号 “)” 的后面，这就用到了以前的状态。</li>
</ul>
<p>状态转移方程是：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">dp[i] = "(" + dp[可能的括号对数] + ")" + dp[剩下的括号对数]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>“可能的括号对数” 与 “剩下的括号对数” 之和得为 i - 1，故 “可能的括号对数” j 可以从 0 开始，最多不能超过 i， 即 i - 1；</li>
<li>“剩下的括号对数” + j = i - 1，故 “剩下的括号对数” = i - j - 1。</li>
</ul>
<p>整理得：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">dp[i] = "(" + dp[j] + ")" + dp[i- j - 1] , j = 0, 1, ..., i - 1</span><br></pre></td></tr></tbody></table></figure>

<p><strong>第 3 步： 思考初始状态和输出：</strong></p>
<ul>
<li>初始状态：因为我们需要 0 对括号这种状态，因此状态数组 dp 从 0 开始，0 个括号当然就是 <code>[""]</code>。</li>
<li>输出：<code>dp[n]</code> 。<br>这个方法暂且就叫它动态规划，这么用也是很神奇的，它有下面两个特点：</li>
</ul>
<p>1、自底向上：从小规模问题开始，逐渐得到大规模问题的解集；</p>
<p>2、无后效性：后面的结果的得到，不会影响到前面的结果。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 把结果集保存在动态规划的数组里</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis5</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 这里 dp 数组我们把它变成列表的样子，方便调用而已</span></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; dp = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; dp0 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    dp0.add(<span class="string">""</span>);</span><br><span class="line">    dp.add(dp0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        List&lt;String&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) {</span><br><span class="line">            List&lt;String&gt; str1 = dp.get(j);</span><br><span class="line">            List&lt;String&gt; str2 = dp.get(i - <span class="number">1</span> - j);</span><br><span class="line">            <span class="keyword">for</span> (String s1 : str1) {</span><br><span class="line">                <span class="keyword">for</span> (String s2 : str2) {</span><br><span class="line">                    <span class="comment">// 枚举右括号的位置</span></span><br><span class="line">                    cur.add(<span class="string">"("</span> + s1 + <span class="string">")"</span> + s2);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        dp.add(cur);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp.get(n);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>@题解来自<a href="https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/" target="_blank" rel="noopener">liweiwei</a></p>
<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>深度优先搜索</tag>
        <tag>BFS</tag>
        <tag>剪枝</tag>
        <tag>动态规划</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS-BFS_leetcode.637.二叉树的层平均值</title>
    <url>/Layer_average_of_binary_tree/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">输出：[3, 14.5, 11]</span><br><span class="line">解释：</span><br><span class="line">第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。</span><br></pre></td></tr></tbody></table></figure>


<p>提示：</p>
<ul>
<li>节点值的范围在32位有符号整数范围内。</li>
</ul>
<a id="more"></a>

<h2 id="🍁方法一：DFS"><a href="#🍁方法一：DFS" class="headerlink" title="🍁方法一：DFS"></a>🍁方法一：DFS</h2><p>使用深度优先搜索计算二叉树的层平均值，需要维护两个数组，counts 用于存储二叉树的每一层的节点数，sums 用于存储二叉树的每一层的节点值之和。搜索过程中需要记录当前节点所在层，如果访问到的节点在第 i 层，则将counts[i] 的值加 11，并将该节点的值加到 sums[i]。</p>
<p>遍历结束之后，第 ii 层的平均值即为<code>sums[i]/counts[i]</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">	List&lt;Double&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;Double&gt; sum = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;Integer&gt; counts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	dfs(<span class="number">0</span>, root, sum, counts);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum.size(); i++) {</span><br><span class="line">		res.add(sum.get(i) / counts.get(i));</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> level, TreeNode root, List&lt;Double&gt; sum, List&lt;Integer&gt; counts)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(level &lt; sum.size()) {</span><br><span class="line">		sum.set(level, sum.get(level) + root.val);</span><br><span class="line">		counts.set(level, counts.get(level) + <span class="number">1</span>);</span><br><span class="line">	}<span class="keyword">else</span> {</span><br><span class="line">		sum.add(<span class="number">1.0</span> * root.val);</span><br><span class="line">		counts.add(<span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">	dfs(level + <span class="number">1</span>, root.left, sum, counts);</span><br><span class="line">	dfs(level + <span class="number">1</span>, root.right, sum, counts);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averageOfLevels</span><span class="params">(self, root: TreeNode)</span> -&gt; List[float]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root: TreeNode, level: int)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> level &lt; len(totals):</span><br><span class="line">                totals[level] += root.val</span><br><span class="line">                counts[level] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                totals.append(root.val)</span><br><span class="line">                counts.append(<span class="number">1</span>)</span><br><span class="line">            dfs(root.left, level + <span class="number">1</span>)</span><br><span class="line">            dfs(root.right, level + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        counts = list()</span><br><span class="line">        totals = list()</span><br><span class="line">        dfs(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> [total / count <span class="keyword">for</span> total, count <span class="keyword">in</span> zip(totals, counts)]</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🍁解法二：-BFS"><a href="#🍁解法二：-BFS" class="headerlink" title="🍁解法二： BFS"></a>🍁解法二： BFS</h2><p>也可以使用广度优先搜索计算二叉树的层平均值。从根节点开始搜索，每一轮遍历同一层的全部节点，计算该层的节点数以及该层的节点值之和，然后计算该层的平均值。</p>
<p>如何确保每一轮遍历的是同一层的全部节点呢？我们可以借鉴层次遍历的做法，广度优先搜索使用队列存储待访问节点，只要确保在每一轮遍历时，队列中的节点是同一层的全部节点即可。具体做法如下：</p>
<ul>
<li>初始时，将根节点加入队列；</li>
<li>每一轮遍历时，将队列中的节点全部取出，计算这些节点的数量以及它们的节点值之和，并计算这些节点的平均值，然后将这些节点的全部非空子节点加入队列，重复上述操作直到队列为空，遍历结束。</li>
</ul>
<p>由于初始时队列中只有根节点，满足队列中的节点是同一层的全部节点，每一轮遍历时都会将队列中的当前层节点全部取出，并将下一层的全部节点加入队列，因此可以确保每一轮遍历的是同一层的全部节点。</p>
<p>具体实现方面，可以在每一轮遍历之前获得队列中的节点数量size，遍历时只遍历 size 个节点，即可满足每一轮遍历的是同一层的全部节点。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels2</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">	List&lt;Double&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	queue.offer(root);</span><br><span class="line">	<span class="keyword">while</span>(!queue.isEmpty()) {</span><br><span class="line">		<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> size = queue.size();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">			TreeNode curNode = queue.poll();</span><br><span class="line">			sum += curNode.val;</span><br><span class="line">			TreeNode left = curNode.left, right = curNode.right;</span><br><span class="line">			<span class="keyword">if</span>(left != <span class="keyword">null</span>) {</span><br><span class="line">				queue.offer(left);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span>(right != <span class="keyword">null</span>) {</span><br><span class="line">				queue.offer(right);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		res.add(sum / size);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averageOfLevels</span><span class="params">(self, root: TreeNode)</span> -&gt; List[float]:</span></span><br><span class="line">        averages = list()</span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line">            size = len(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(size):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                total += node.val</span><br><span class="line">                left, right = node.left, node.right</span><br><span class="line">                <span class="keyword">if</span> left:</span><br><span class="line">                    queue.append(left)</span><br><span class="line">                <span class="keyword">if</span> right:</span><br><span class="line">                    queue.append(right)</span><br><span class="line">            averages.append(total / size)</span><br><span class="line">        <span class="keyword">return</span> averages</span><br></pre></td></tr></tbody></table></figure>

<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>深度优先搜索</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯_leetcode.78.子集</title>
    <url>/Subset/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<h2 id="🌸分析"><a href="#🌸分析" class="headerlink" title="🌸分析"></a>🌸分析</h2><h2 id="🌸解法一：递归"><a href="#🌸解法一：递归" class="headerlink" title="🌸解法一：递归"></a>🌸解法一：递归</h2><p>开始假设输出子集为空，每一步都向子集添加新的整数，并生成新的子集。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) {</span><br><span class="line">  List&lt;List&lt;Integer&gt;&gt; output = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  output.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) {</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; newSubsets = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; curr : output) {</span><br><span class="line">      newSubsets.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(curr){{add(num);}});</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; curr : newSubsets) {</span><br><span class="line">      output.add(curr);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h2 id="🌸解法二：回溯"><a href="#🌸解法二：回溯" class="headerlink" title="🌸解法二：回溯"></a>🌸解法二：回溯</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; subsets1(<span class="keyword">int</span>[] nums) {</span><br><span class="line">	 List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	 dfs(<span class="number">0</span>, nums, nums.length, res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">	 <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> length, List&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; curList)</span> </span>{</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; length; j++) {</span><br><span class="line">		curList.add(nums[j]);</span><br><span class="line">		dfs(j + <span class="number">1</span>, nums, length, res, curList);</span><br><span class="line">		curList.remove(curList.size() - <span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h3><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>回溯</tag>
        <tag>DFS， 深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯_leetcode.77.组合</title>
    <url>/combination/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: n = 4, k = 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<h2 id="🌸分析"><a href="#🌸分析" class="headerlink" title="🌸分析"></a>🌸分析</h2><ul>
<li>如果解决一个问题有多个步骤，每一个步骤有多种方法，题目又要我们找出所有的方法，可以使用回溯算法；</li>
<li>回溯算法是在一棵树上的 深度优先遍历（因为要找所有的解，所以需要遍历）；</li>
<li>组合问题，相对于排列问题而言，不计较一个组合内元素的顺序性（即 [1, 2, 3] 与 [1, 3, 2] 认为是同一个组合），因此很多时候需要按某种顺序展开搜索，这样才能做到不重不漏。</li>
</ul>
<p>回溯算法首先需要画出递归树，不同的树决定了不同的代码实现。</p>
<h2 id="🌸解法一：根据搜索起点画出二叉树"><a href="#🌸解法一：根据搜索起点画出二叉树" class="headerlink" title="🌸解法一：根据搜索起点画出二叉树"></a>🌸解法一：根据搜索起点画出二叉树</h2><p>既然是树形问题上的 深度优先遍历，因此首先画出树形结构。例如输入：n = 4, k = 2，我们可以发现如下递归结构：</p>
<ul>
<li>如果组合里有 1 ，那么需要在 [2, 3, 4] 里再找 1 个数；</li>
<li>如果组合里有 2 ，那么需要在 [3, 4] 里再找 1数。注意：这里不能再考虑 1，因为包含 1 的组合，在第 1 种情况中已经包含。</li>
</ul>
<p>依次类推（后面部分省略），以上描述体现的 递归 结构是：在以 n 结尾的候选数组里，选出若干个元素。</p>
<p>说明：</p>
<ul>
<li>叶子结点的信息体现在从根结点到叶子结点的路径上，因此需要一个表示路径的变量 path，它是一个列表，特别地，path 是一个栈；</li>
<li>每一个结点递归地在做同样的事情，区别在于搜索起点，因此需要一个变量 start ，表示在区间 [begin, n] 里选出若干个数的组合；</li>
<li>可能有一些分支没有必要执行，我们放在优化中介绍。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k){</span><br><span class="line">	List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">if</span>(k &lt;= <span class="number">0</span> || n &lt; k) {</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//从1开始是题目的设定</span></span><br><span class="line">	Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">	dfs(n, k, <span class="number">1</span>, path, res);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> begin, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>{</span><br><span class="line">	<span class="comment">//递归终止条件是：path的长度等于K</span></span><br><span class="line">	<span class="keyword">if</span>(k == path.size()) {</span><br><span class="line">		res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//遍历可能的搜索起点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt;= n; i++) {</span><br><span class="line">		<span class="comment">//向路径变量里添加一个数</span></span><br><span class="line">		path.addLast(i);</span><br><span class="line">		<span class="comment">//下一轮搜索，设置搜索起点要加一，因为组合数里应该不欲奴徐出现重复数</span></span><br><span class="line">		dfs(n, k, begin + <span class="number">1</span>, path, res);</span><br><span class="line">		<span class="comment">//深度优先搜索遍历有回头的时候，因此需要回溯</span></span><br><span class="line">		path.removeLast();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h2 id="🌸解法二：分析搜索起点的上界进行剪枝"><a href="#🌸解法二：分析搜索起点的上界进行剪枝" class="headerlink" title="🌸解法二：分析搜索起点的上界进行剪枝"></a>🌸解法二：分析搜索起点的上界进行剪枝</h2><p>事实上，如果 n = 7, k = 4，从 55 开始搜索就已经没有意义了，这是因为：即使把 55 选上，后面的数只有 66 和 77，一共就 33 个候选数，凑不出 44 个数的组合。因此，搜索起点有上界，这个上界是多少，可以举几个例子分析。</p>
<p>分析搜索起点的上界，其实是在深度优先遍历的过程中剪枝，剪枝可以避免不必要的遍历，剪枝剪得好，可以大幅度节约算法的执行时间。</p>
<p>当 n 很大的时候，能少遍历很多结点，节约了时间。</p>
<p>例如<code>：n = 6 ，k = 4</code>。</p>
<p><code>path.size() == 1</code> 的时候，接下来要选择 3个数，搜索起点最大是 4，最后一个被选的组合是 <code>[4, 5, 6]</code>；<br><code>path.size() == 2</code> 的时候，接下来要选择 2 个数，搜索起点最大是 5，最后一个被选的组合是 <code>[5, 6]</code>；<br><code>path.size() == 3</code> 的时候，接下来要选择 1 个数，搜索起点最大是 6，最后一个被选的组合是 <code>[6]</code>；</p>
<p>再如：<code>n = 15 ，k = 4</code>。<br><code>path.size() == 1</code> 的时候，接下来要选择 3 个数，搜索起点最大是 13，最后一个被选的是 <code>[13, 14, 15]</code>；<br><code>path.size() == 2</code> 的时候，接下来要选择 2 个数，搜索起点最大是 14，最后一个被选的是 <code>[14, 15]</code>；<br><code>path.size() == 3</code> 的时候，接下来要选择 1 个数，搜索起点最大是 15，最后一个被选的是 [<code>15]</code>；</p>
<p>可以归纳出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">搜索起点的上界 + 接下来要选择的元素个数 - 1 = n</span><br></pre></td></tr></tbody></table></figure>


<p>其中，接下来要选择的元素个数 = <code>k - path.size()</code>，整理得到：</p>
<p>搜索起点的上界 = <code>n - (k - path.size()) + 1</code><br>所以，我们的剪枝过程就是<code>：把 i &lt;= n 改成 i &lt;= n - (k - path.size()) + 1</code> ：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k){</span><br><span class="line">	List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">if</span>(k &lt;= <span class="number">0</span> || n &lt; k) {</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//从1开始是题目的设定</span></span><br><span class="line">	Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">	dfs(n, k, <span class="number">1</span>, path, res);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> begin, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>{</span><br><span class="line">	<span class="comment">//递归终止条件是：path的长度等于K</span></span><br><span class="line">	<span class="keyword">if</span>(k == path.size()) {</span><br><span class="line">		res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//遍历可能的搜索起点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++) {</span><br><span class="line">		<span class="comment">//向路径变量里添加一个数</span></span><br><span class="line">		path.addLast(i);</span><br><span class="line">		<span class="comment">//下一轮搜索，设置搜索起点要加一，因为组合数里应该不欲奴徐出现重复数</span></span><br><span class="line">		dfs(n, k, begin + <span class="number">1</span>, path, res);</span><br><span class="line">		<span class="comment">//深度优先搜索遍历有回头的时候，因此需要回溯</span></span><br><span class="line">		path.removeLast();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h3><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>深度优先搜索</tag>
        <tag>剪枝</tag>
        <tag>递归</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>排序_leetcode.347.前K个高频元素</title>
    <url>/The_first_k_high_frequency_elements/</url>
    <content><![CDATA[<p>🌸题目</p>
<p>🍁给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></tbody></table></figure>


<p>示例 2:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<p>提示：</p>
<ul>
<li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li>
<li>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</li>
<li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li>
<li>你可以按任意顺序返回答案。</li>
</ul>
<h2 id="🌸分析"><a href="#🌸分析" class="headerlink" title="🌸分析"></a>🌸分析</h2><p>以下给出了两种方法，思路其实是一样的：通过 <strong>计算剩余数字个数的阶乘数</strong>，一位一位选出第 <code>k</code> 个排列的数位。</p>
<h2 id="🌸解法一：排序"><a href="#🌸解法一：排序" class="headerlink" title="🌸解法一：排序"></a>🌸解法一：排序</h2><p>最简单粗暴的思路就是 <strong>使用排序算法对元素按照频率由高到低进行排序</strong>，然后再取前 k 个元素。</p>
<p><a href="https://imgchr.com/i/wKJOZn" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/07/wKJOZn.png" alt="wKJOZn.png"></a></p>
<p>可以发现，使用常规的诸如 冒泡、选择、甚至快速排序都是不满足题目要求，它们的时间复杂度都是大于或者等于 O(n log⁡n)，而题目要求算法的时间复杂度必须优于 O(n log n)。</p>
<h2 id="🌸解法二：最小堆"><a href="#🌸解法二：最小堆" class="headerlink" title="🌸解法二：最小堆"></a>🌸解法二：最小堆</h2><p>题目最终需要返回的是前 k 个频率最大的元素，可以想到借助堆这种数据结构，对于 k 频率之后的元素不用再去处理，进一步优化时间复杂度。</p>
<p>具体操作为：</p>
<ul>
<li>借助 哈希表 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率</li>
<li>维护一个元素数目为 k的最小堆</li>
<li>每次都将新的元素与堆顶元素（堆中频率最小的元素）进行比较</li>
<li>如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中</li>
<li>最终，堆中的 k 个元素即为前 k 个高频元素</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">	<span class="comment">//使用字典，统计每个元素出现的次数，次数为建，元素出现的次数为值</span></span><br><span class="line">	Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> num : nums) {</span><br><span class="line">		<span class="keyword">if</span>(map.containsKey(num)) {</span><br><span class="line">			map.put(num, map.get(num) + <span class="number">1</span>);</span><br><span class="line">		}<span class="keyword">else</span> {</span><br><span class="line">			map.put(num, <span class="number">1</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//遍历map，用最小堆保存频率最大的K个元素</span></span><br><span class="line">	PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() {</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span> </span>{</span><br><span class="line">			<span class="keyword">return</span> map.get(a) - map.get(b);</span><br><span class="line">		}</span><br><span class="line">	});</span><br><span class="line">	<span class="keyword">for</span>(Integer key : map.keySet()) {</span><br><span class="line">		<span class="keyword">if</span>(pq.size() &lt; k) {</span><br><span class="line">			pq.add(key);</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(map.get(key) &gt; map.get(pq.peek())){</span><br><span class="line">			pq.remove();</span><br><span class="line">			pq.add(key);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//取出最小堆中的元素</span></span><br><span class="line">	List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">while</span>(!pq.isEmpty()) {</span><br><span class="line">		res.add(pq.remove());</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法三：桶排序"><a href="#🌸解法三：桶排序" class="headerlink" title="🌸解法三：桶排序"></a>🌸解法三：桶排序</h2><p>首先依旧使用哈希表统计频率，统计完成后，创建一个数组，将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标即可。</p>
<p><a href="https://imgchr.com/i/wKY1eA" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/07/wKY1eA.png" alt="wKY1eA.png"></a></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">	</span><br><span class="line">	List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="comment">//使用字典，统计每个元素出现的次数，次数为建，元素出现的次数为值</span></span><br><span class="line">	Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> num : nums) {</span><br><span class="line">		<span class="keyword">if</span>(map.containsKey(num)) {</span><br><span class="line">			map.put(num, map.get(num) + <span class="number">1</span>);</span><br><span class="line">		}<span class="keyword">else</span> {</span><br><span class="line">			map.put(num, <span class="number">1</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//桶排序</span></span><br><span class="line">	<span class="comment">//将频率作为数组的下标，对于出现频率不同的数字集合，存入对应的下标数组</span></span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	List&lt;Integer&gt;[] list = <span class="keyword">new</span> List[nums.length + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> key : map.keySet()) {</span><br><span class="line">		<span class="comment">//获取出现的次数作为下标</span></span><br><span class="line">		<span class="keyword">int</span> i = map.get(key);</span><br><span class="line">		<span class="keyword">if</span>(list[i] == <span class="keyword">null</span>) {</span><br><span class="line">			list[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		}</span><br><span class="line">		list[i].add(key);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//倒序遍历数组获取出现顺序从大到小的排列</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = list.length - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; res.size() &lt; k; i--) {</span><br><span class="line">		<span class="keyword">if</span>(list[i] == <span class="keyword">null</span>) {</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		}</span><br><span class="line">		res.addAll(list[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>堆</tag>
        <tag>桶排序</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯_leetcode.60.第k个排列</title>
    <url>/K-th_permutation/</url>
    <content><![CDATA[<p>🌸题目</p>
<p>🍁给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">"123"</span><br><span class="line">"132"</span><br><span class="line">"213"</span><br><span class="line">"231"</span><br><span class="line">"312"</span><br><span class="line">"321"</span><br></pre></td></tr></tbody></table></figure>


<p>给定 n 和 k，返回第 k 个排列。</p>
<a id="more"></a>

<p>说明：</p>
<ul>
<li>给定 n 的范围是 <code>[1, 9]</code>。</li>
<li>给定 k 的范围是<code>[1,  n!]</code>。</li>
</ul>
<p>示例 1:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: n = 3, k = 3</span><br><span class="line">输出: "213"</span><br></pre></td></tr></tbody></table></figure>


<p>示例 2:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: n = 4, k = 9</span><br><span class="line">输出: "2314"</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸分析"><a href="#🌸分析" class="headerlink" title="🌸分析"></a>🌸分析</h2><p>以下给出了两种方法，思路其实是一样的：通过 <strong>计算剩余数字个数的阶乘数</strong>，一位一位选出第 <code>k</code> 个排列的数位。</p>
<h2 id="🌸解法一：DFS-剪枝"><a href="#🌸解法一：DFS-剪枝" class="headerlink" title="🌸解法一：DFS+剪枝"></a>🌸解法一：DFS+剪枝</h2><p>容易想到，使用同「力扣」第 46 题： 全排列 的回溯搜索算法，依次得到全排列，输出第 k 个全排列即可。事实上，我们不必求出所有的全排列。</p>
<p>基于以下几点考虑：</p>
<ul>
<li>所求排列 <strong>一定在叶子结点处得到</strong>，进入每一个分支，可以根据已经选定的数的个数，进而计算还未选定的数的个数，然后计算阶乘，就知道这一个分支的 <strong>叶子结点</strong> 的个数：<ul>
<li>如果 k 大于这一个分支将要产生的叶子结点数，直接跳过这个分支，这个操作叫「剪枝」；</li>
<li>如果 k 小于<strong>等于</strong>这一个分支将要产生的叶子结点数，那说明所求的全排列一定在这一个分支将要产生的叶子结点里，需要递归求解。</li>
</ul>
</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/1599273370-WyOYCO-image.png" alt=""></p>
<p>编码注意事项：</p>
<ul>
<li>计算阶乘的时候，可以使用循环计算。注意：0!=1，它表示了没有数可选的时候，即表示到达叶子结点了，排列数只剩下 1个；</li>
<li>题目中说「给定 n 的范围是 [1, 9]」，可以把从 0到 9 的阶乘计算好，放在一个数组里，可以根据索引直接获得阶乘值；</li>
<li>编码的时候，+1 还是 -1 ，大于还是大于等于，这些不能靠猜。常见的做法是：代入一个具体的数值，认真调试。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录数字是否使用过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阶乘数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] factorial;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        calculateFactorial(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找全排列需要的布尔数组</span></span><br><span class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(used, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        StringBuilder path = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        dfs(<span class="number">0</span>, path);</span><br><span class="line">        <span class="keyword">return</span> path.toString();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 在这一步之前已经选择了几个数字，其值恰好等于这一步需要确定的下标位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, StringBuilder path)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (index == n) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算还未确定的数字的全排列的个数，第 1 次进入的时候是 n - 1</span></span><br><span class="line">        <span class="keyword">int</span> cnt = factorial[n - <span class="number">1</span> - index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (used[i]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; k) {</span><br><span class="line">                k -= cnt;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            path.append(i);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            dfs(index + <span class="number">1</span>, path);</span><br><span class="line">            <span class="comment">// 注意 1：没有回溯（状态重置）的必要</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意 2：这里要加 return，后面的数没有必要遍历去尝试了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算阶乘数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calculateFactorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        factorial = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        factorial[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            factorial[i] = factorial[i - <span class="number">1</span>] * i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>python</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(n, k, index, path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> index == n:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            cnt = factorial[n - <span class="number">1</span> - index]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> used[i]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> cnt &lt; k:</span><br><span class="line">                    k -= cnt</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(i)</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line">                dfs(n, k, index + <span class="number">1</span>, path)</span><br><span class="line">                <span class="comment"># 注意：这里要加 return，后面的数没有必要遍历去尝试了</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        used = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        path = []</span><br><span class="line">        factorial = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            factorial[i] = factorial[i - <span class="number">1</span>] * i</span><br><span class="line"></span><br><span class="line">        dfs(n, k, <span class="number">0</span>, path)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join([str(num) <span class="keyword">for</span> num <span class="keyword">in</span> path])</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>时间复杂度：O({N^2})，</p>
</li>
<li><p>空间复杂度：O(N)，nums、used、path 都与 N 等长，factorial 数组就 10个数，是常数级别的。</p>
</li>
</ul>
<p><code>k -= cnt;</code> 这一步，每一次剪枝太慢，事实上，可以用除法加快这一步骤。但是需要维护一个有序数组（或者链表），时间复杂度不变。</p>
<h2 id="🌸解法二：有序数组（链表）模拟"><a href="#🌸解法二：有序数组（链表）模拟" class="headerlink" title="🌸解法二：有序数组（链表）模拟"></a>🌸解法二：有序数组（链表）模拟</h2><p>以 <code>n = 4</code>，<code>k = 6</code>，为例，现在确定第 1 个数字填啥。如果第 <code>k</code>个数恰好是后面的数字个数的阶乘，那么第 1 个数字就只能填最小的 1。</p>
<p>如果 <code>n = 4</code>，<code>k = 16</code>，现在确定第 1 个数字填啥。如果 <code>k</code> &gt; 后面的数字个数的阶乘。数一数，可以跳过几个阶乘数。</p>
<p>其实这个思路很像方法一的「剪枝」，只不过方法一就减法，方法二用除法。事实上，方法二要维护数组的有序性，所以时间复杂度不变。根据以上思路，设计算法流程如下：</p>
<p>算法流程设计：</p>
<ul>
<li>把候选数放在一个 有序列表 里，从左到右根据「剩下的数的阶乘数」确定每一位填谁，公式 k / (后面几位的阶乘数) 的值 恰好等于候选数组的下标；</li>
<li>选出一个数以后，k 就需要减去相应跳过的阶乘数的倍数；</li>
<li>已经填好的数需要从候选列表里删除，注意保持列表的有序性（因为排列的定义是按照字典序）；</li>
<li>由于这里考虑的是下标，第 k 个数，下标为 <code>k - 1</code>，一开始的时候，k–。<br>每次选出一个数，就将这个数从列表里面拿出。这个列表需要支持频繁的删除操作，因此使用双链表。在 Java 中 <code>LinkedList</code> 就是使用双链表实现的。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="comment">// 注意：相当于在 n 个数字的全排列中找到下标为 k - 1 的那个数，因此 k 先减 1</span></span><br><span class="line">        k --;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] factorial = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        factorial[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 先算出所有的阶乘值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            factorial[i] = factorial[i - <span class="number">1</span>] * i;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里使用数组或者链表都行</span></span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            nums.add(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i 表示剩余的数字个数，初始化为 n - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">int</span> index = k / factorial[i] ;</span><br><span class="line">            stringBuilder.append(nums.remove(index));</span><br><span class="line">            k -= index * factorial[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>题解出自<a href="https://leetcode-cn.com/problems/permutation-sequence/solution/hui-su-jian-zhi-python-dai-ma-java-dai-ma-by-liwei/" target="_blank" rel="noopener">@liweiwei1419</a></p>
<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>深度优先搜索</tag>
        <tag>递归</tag>
        <tag>回溯</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS_leetcode.841.钥匙和房间</title>
    <url>/Keys_and_rooms/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁有 <code>N</code> 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，…，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。</p>
<p>在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 <code>rooms[i][j]</code> 由 <code>[0,1，...，N-1]</code> 中的一个整数表示，其中 <code>N = rooms.length</code>。 钥匙 <code>rooms[i][j] = v</code> 可以打开编号为 v 的房间。</p>
<p>最初，除 0 号房间外的其余所有房间都被锁住。</p>
<p>你可以自由地在房间之间来回走动。</p>
<p>如果能进入每个房间返回 <code>true</code>，否则返回 <code>false</code>。</p>
<a id="more"></a>

<p>示例:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: [[1],[2],[3],[]]</span><br><span class="line">输出: true</span><br><span class="line">解释:  </span><br><span class="line">我们从 0 号房间开始，拿到钥匙 1。</span><br><span class="line">之后我们去 1 号房间，拿到钥匙 2。</span><br><span class="line">然后我们去 2 号房间，拿到钥匙 3。</span><br><span class="line">最后我们去了 3 号房间。</span><br><span class="line">由于我们能够进入每个房间，我们返回 true。</span><br></pre></td></tr></tbody></table></figure>

<p>示例2</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：[[1,3],[3,0,1],[2],[0]]</span><br><span class="line">输出：false</span><br><span class="line">解释：我们不能进入 2 号房间。</span><br></pre></td></tr></tbody></table></figure>


<p>提示:</p>
<ol>
<li><code>1 &lt;= rooms.length &lt;= 1000</code></li>
<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>
<li>所有房间中的钥匙数量总计不超过 <code>3000</code>。</li>
</ol>
<h2 id="🌸分析"><a href="#🌸分析" class="headerlink" title="🌸分析"></a>🌸分析</h2><p>当 x 号房间中有 y号房间的钥匙时，我们就可以从 xx 号房间去往 y 号房间。如果我们将这 n 个房间看成有向图中的 n 个节点，那么上述关系就可以看作是图中的x号点到 y 号点的一条有向边。</p>
<p>这样一来，问题就变成了给定一张有向图，询问从 0 号节点出发是否能够到达所有的节点。</p>
<h2 id="🌸解法一：DFS"><a href="#🌸解法一：DFS" class="headerlink" title="🌸解法一：DFS"></a>🌸解法一：DFS</h2><p>我们可以使用深度优先搜索的方式遍历整张图，统计可以到达的节点个数，并利用数组<code>vis</code> 标记当前节点是否访问过，以防止重复访问。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span>[] vis;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = rooms.size();</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        dfs(rooms, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> num == n;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms, <span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        vis[x] = <span class="keyword">true</span>;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> it : rooms.get(x)) {</span><br><span class="line">            <span class="keyword">if</span> (!vis[it]) {</span><br><span class="line">                dfs(rooms, it);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>python</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canVisitAllRooms</span><span class="params">(self, rooms: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x: int)</span>:</span></span><br><span class="line">            vis.add(x)</span><br><span class="line">            <span class="keyword">nonlocal</span> num</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> it <span class="keyword">in</span> rooms[x]:</span><br><span class="line">                <span class="keyword">if</span> it <span class="keyword">not</span> <span class="keyword">in</span> vis:</span><br><span class="line">                    dfs(it)</span><br><span class="line">        </span><br><span class="line">        n = len(rooms)</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        vis = set()</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> num == n</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>时间复杂度：O(n+m)，其中 n 是房间的数量，m 是所有房间中的钥匙数量的总数。</p>
</li>
<li><p>空间复杂度：O(n)，其中 n 是房间的数量。主要为栈空间的开销。</p>
</li>
</ul>
<h2 id="🌸解法二：-BFS"><a href="#🌸解法二：-BFS" class="headerlink" title="🌸解法二： BFS"></a>🌸解法二： BFS</h2><p>我们也可以使用广度优先搜索的方式遍历整张图，统计可以到达的节点个数，并利用数组 <code>vis</code> 标记当前节点是否访问过，以防止重复访问。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = rooms.size(), num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        Queue&lt;Integer&gt; que = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        vis[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        que.offer(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) {</span><br><span class="line">            <span class="keyword">int</span> x = que.poll();</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> it : rooms.get(x)) {</span><br><span class="line">                <span class="keyword">if</span> (!vis[it]) {</span><br><span class="line">                    vis[it] = <span class="keyword">true</span>;</span><br><span class="line">                    que.offer(it);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> num == n;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>python</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canVisitAllRooms</span><span class="params">(self, rooms: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        n = len(rooms)</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        vis = {<span class="number">0</span>}</span><br><span class="line">        que = collections.deque([<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            x = que.popleft()</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> it <span class="keyword">in</span> rooms[x]:</span><br><span class="line">                <span class="keyword">if</span> it <span class="keyword">not</span> <span class="keyword">in</span> vis:</span><br><span class="line">                    vis.add(it)</span><br><span class="line">                    que.append(it)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num == n</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>时间复杂度：O(n+m)，其中 n 是房间的数量，m 是所有房间中的钥匙数量的总数。</p>
</li>
<li><p>空间复杂度：O(n)，其中 n 是房间的数量。主要为队列的开销。</p>
</li>
</ul>
<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>深度优先搜索</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划_leetcode.486.预测赢家</title>
    <url>/Predicting_winners/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p>
<p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p>
 <a id="more"></a>

<p>示例 1：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：[1, 5, 2]</span><br><span class="line">输出：False</span><br><span class="line">解释：一开始，玩家1可以从1和2中进行选择。</span><br><span class="line">如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。</span><br><span class="line">所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。</span><br><span class="line">因此，玩家 1 永远不会成为赢家，返回 False 。</span><br></pre></td></tr></tbody></table></figure>


<p>示例 2：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：[1, 5, 233, 7]</span><br><span class="line">输出：True</span><br><span class="line">解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。</span><br><span class="line">     最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。</span><br></pre></td></tr></tbody></table></figure>


<p>提示：</p>
<ul>
<li>1 &lt;= 给定的数组长度 &lt;= 20.</li>
<li>数组里所有分数都为非负数且不会大于 10000000 。</li>
<li>如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先分析就是使用递归</p>
<h2 id="🌸方法一：暴力递归（正常思路）"><a href="#🌸方法一：暴力递归（正常思路）" class="headerlink" title="🌸方法一：暴力递归（正常思路）"></a>🌸方法一：暴力递归（正常思路）</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">	<span class="comment">// 模拟真实情况下，A，B轮流选牌的过程，求出结果</span></span><br><span class="line">	<span class="keyword">return</span> dfs(<span class="number">0</span>, nums.length - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">true</span>, nums);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//分别为  左边可取的位置，右边可取的位置，A的得分，B的得分，   轮到谁选牌，   nums数组</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> sumA, <span class="keyword">int</span> sumB, <span class="keyword">boolean</span> to_A, <span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="keyword">if</span>(left &gt; right) {<span class="comment">//左右越界，没有牌了，比较得分，判断胜负（以A为主角）</span></span><br><span class="line">		<span class="keyword">return</span> sumA &gt;= sumB;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(to_A) {<span class="comment">//轮到A选牌,A是主角，只要左边或者右边有一种必胜情况，就说明可以必胜</span></span><br><span class="line">		<span class="keyword">return</span> dfs(left + <span class="number">1</span>, right, sumA + nums[left], sumB, <span class="keyword">false</span>, nums) || dfs(left, right - <span class="number">1</span>, sumA + nums[right], sumB, <span class="keyword">false</span>, nums);</span><br><span class="line">	}<span class="keyword">else</span> {<span class="comment">//轮到B选牌，不管B怎么选，此时只有左右两边都保证A是必胜的，才能保证A最终必胜</span></span><br><span class="line">		<span class="keyword">return</span> dfs(left + <span class="number">1</span>, right, sumA, sumB+ nums[left], <span class="keyword">true</span>, nums) &amp;&amp; dfs(left, right - <span class="number">1</span>, sumA, sumB + nums[right], <span class="keyword">true</span>, nums);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸方法二：递归（思路一）"><a href="#🌸方法二：递归（思路一）" class="headerlink" title="🌸方法二：递归（思路一）"></a>🌸方法二：递归（思路一）</h2><h3 id="🍁分析"><a href="#🍁分析" class="headerlink" title="🍁分析"></a>🍁分析</h3><p>为了判断哪个玩家可以获胜，需要计算一个总分，为先手得分与后手得分之差。当数组中的所有数字都被拿取时，如果总分大于或等于 00，则先手获胜，反之则后手获胜。</p>
<p>由于每次只能从数组的任意一端拿取数字，因此可以保证数组中剩下的部分一定是连续的。假设数组当前剩下的部分为下标start 到下标end，其中$ 0 \le \textit{start} \le \textit{end} &lt; \textit{nums}.\text{length}$。如果 $\textit{start}=\textit{end}$，则只剩一个数字，当前玩家只能拿取这个数字。如果$ \textit{start}&lt;\textit{end}$，则当前玩家可以选择 $\textit{nums}[\textit{start}]$ 或 $\textit{nums}[\textit{end}]$，然后轮到另一个玩家在数组剩下的部分选取数字。这是一个递归的过程。</p>
<p>计算总分时，需要记录当前玩家是先手还是后手，判断当前玩家的得分应该记为正还是负。当数组中剩下的数字多于 1 个时，当前玩家会选择最优的方案，使得自己的分数最大化，因此对两种方案分别计算当前玩家可以得到的分数，其中的最大值为当前玩家最多可以得到的分数。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> total(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, <span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">total</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> turn)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (start == end) {</span><br><span class="line">        <span class="keyword">return</span> nums[start] * turn;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> scoreStart = nums[start] * turn + total(nums, start + <span class="number">1</span>, end, -turn);</span><br><span class="line">    <span class="keyword">int</span> scoreEnd = nums[end] * turn + total(nums, start, end - <span class="number">1</span>, -turn);</span><br><span class="line">    <span class="keyword">return</span> Math.max(scoreStart * turn, scoreEnd * turn) * turn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸方法三：递归（思路二）"><a href="#🌸方法三：递归（思路二）" class="headerlink" title="🌸方法三：递归（思路二）"></a>🌸方法三：递归（思路二）</h2><h3 id="🍁分析-1"><a href="#🍁分析-1" class="headerlink" title="🍁分析"></a>🍁分析</h3><p>以 <code>[1, 5, 233, 7]</code> 为例，玩家 1 先手。</p>
<p>如果玩家 1 先选左端 1，则玩家 2 在 <code>[5, 233, 7]</code> 的两端中选。<br>如果玩家 1 先选右端 7，则玩家 2 在 <code>[1, 5, 233]</code> 的两端中选。</p>
<p>可以看到，每个节点都是其中一个玩家在选择。当前子问题下，谁的分数更多，谁就赢。</p>
<p>当前，你选了 x，得 x 分，他没选，得 0分，你赢了别人 x 分，接下来呢？他选，然后你选……你们交替地得分……打住，你已进入递归的细节，别想下去了。</p>
<p>当前你有 x 分，对手 0 分，在后面的游戏中，对手拢共超过你 y 分，如果 x &gt;= y，那你赢咯。</p>
<p>别操心递归的细节，细节丢给子调用去做，眼睛盯着当前的 x 分，想想子调用应该返回什么，去和当前的 x 分作比较，判断出胜利。</p>
<p>于是，递归函数做的事：计算当前做选择的玩家能赢过对手的分数。如果大于零，则表示他在这个子问题中赢了。</p>
<p>怎么计算呢？当前选择的分数，减去，接下来对手赢过自己的分数（剩余数组的递归结果），因为选择有两种，所以我们二者取其大。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> help(<span class="number">0</span>, nums.length - <span class="number">1</span>, nums) &gt;= <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="keyword">if</span>(left == right) {</span><br><span class="line">		<span class="keyword">return</span> nums[left];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> sumL = nums[left] - help(left + <span class="number">1</span>, right, nums); <span class="comment">// 选择左端</span></span><br><span class="line">	<span class="keyword">int</span> sumR = nums[right] - help(left, right, nums);<span class="comment">// 选择右端</span></span><br><span class="line">	<span class="keyword">return</span> Math.max(sumL, sumR);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸方法四：记忆化递归（思路优化）"><a href="#🌸方法四：记忆化递归（思路优化）" class="headerlink" title="🌸方法四：记忆化递归（思路优化）"></a>🌸方法四：记忆化递归（思路优化）</h2><h3 id="🍁分析-2"><a href="#🍁分析-2" class="headerlink" title="🍁分析"></a>🍁分析</h3><p>我们做了哪些重复的计算呢？<br>比如，你先选 1，我再选 7，和你先选 7，我再选 1，这两种所带来的子问题是一样的，都是剩下[5, 233]。我们用数组或哈希表去存储计算过的子问题的解，下次遇到重复的子问题，就不用再次递归计算。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner3</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> len = nums.length;</span><br><span class="line">	<span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">		Arrays.fill(memo[i], Integer.MIN_VALUE);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> dfs2(nums, <span class="number">0</span>, len - <span class="number">1</span>, memo) &gt;= <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[][] memo)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span>(left &gt; right) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(memo[left][right] != Integer.MIN_VALUE) {</span><br><span class="line">		<span class="keyword">return</span> memo[left][right];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> Left = nums[left] - dfs2(nums, left + <span class="number">1</span>, right, memo);</span><br><span class="line">	<span class="keyword">int</span> Right = nums[right] - dfs2(nums, left, right - <span class="number">1</span>, memo);</span><br><span class="line">	memo[left][right] = Math.max(Left, Right);</span><br><span class="line">	<span class="keyword">return</span> memo[left][right];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸方法五：动态规划"><a href="#🌸方法五：动态规划" class="headerlink" title="🌸方法五：动态规划"></a>🌸方法五：动态规划</h2><h3 id="🍁分析-3"><a href="#🍁分析-3" class="headerlink" title="🍁分析"></a>🍁分析</h3><p>定义二维数组$\textit{dp}$，其行数和列数都等于数组的长度，$\textit{dp}[i][j]$表示当数组剩下的部分为下标 i 到下标 j 时，当前玩家与另一个玩家的分数之差的最大值，注意当前玩家不一定是先手。</p>
<p>只有当$ i \le j $时，数组剩下的部分才有意义，因此当 $i&gt;j$ 时，$\textit{dp}[i][j]=0$。</p>
<p>当 i=j时，只剩一个数字，当前玩家只能拿取这个数字，因此对于所有 $0 \le i &lt; \textit{nums}.\text{length}$，都有$ \textit{dp}[i][i]=\textit{nums}[i]$。</p>
<p>当 i&lt;j时，当前玩家可以选择 $\textit{nums}[i]$ 或$\textit{nums}[j]$，然后轮到另一个玩家在数组剩下的部分选取数字。在两种方案中，当前玩家会选择最优的方案，使得自己的分数最大化。因此可以得到如下状态转移方程：</p>
<p>$\textit{dp}[i][j]=\max(\textit{nums}[i] - \textit{dp}[i + 1][j], \textit{nums}[j] - \textit{dp}[i][j - 1])<br>$</p>
<p>最后判断$ \textit{dp}[0][\textit{nums}.\text{length}-1]$ 的值，如果大于或等于 0，则先手得分大于或等于后手得分，因此先手成为赢家，否则后手成为赢家。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner4</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> len = nums.length;</span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">		dp[i][i] = nums[i];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) {</span><br><span class="line">			dp[i][j] = Math.max(nums[i] - dp[i + <span class="number">1</span>][j], nums[j] - dp[i][j - <span class="number">1</span>]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][len - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸方法六：动态规划优化"><a href="#🌸方法六：动态规划优化" class="headerlink" title="🌸方法六：动态规划优化"></a>🌸方法六：动态规划优化</h2><h3 id="🍁分析-4"><a href="#🍁分析-4" class="headerlink" title="🍁分析"></a>🍁分析</h3><p>上述代码中使用了二维数组 $\textit{dp}$。分析状态转移方程可以看到，$\textit{dp}[i][j$ 的值只和$ \textit{dp}[i + 1][j] $与$ \textit{dp}[i][j - 1] $有关，即在计算$ \textit{dp} $的第 ii 行的值时，只需要使用到 $\textit{dp} $的第 <code>i</code> 行和第 <code>i+1</code> 行的值，因此可以使用一维数组代替二维数组，对空间进行优化。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner5</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> len = nums.length;</span><br><span class="line">	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">		dp[i] = nums[i];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) {</span><br><span class="line">			dp[j] = Math.max(nums[i] - dp[j], nums[j] - dp[j - <span class="number">1</span>]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> dp[len - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>递归</tag>
        <tag>记忆化递归</tag>
      </tags>
  </entry>
  <entry>
    <title>状态机_剑指offer.20_表示数值的字符串</title>
    <url>/A_string_representing_numeric/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p>
<a id="more"></a>

<h2 id="🌸方法一：暴力模拟"><a href="#🌸方法一：暴力模拟" class="headerlink" title="🌸方法一：暴力模拟"></a>🌸方法一：暴力模拟</h2><p>目的是判断m在哪个排序数组中。在numbers [m]&gt;numbers[i] 情况下,</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span>(s.length() &lt;= <span class="number">0</span> || s == <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">boolean</span> isEExist = <span class="keyword">false</span>;<span class="comment">// 记录 e 和 E 是否存在</span></span><br><span class="line">	<span class="keyword">boolean</span> isDotExist = <span class="keyword">false</span>;<span class="comment">// 记录 小数点 是否存在</span></span><br><span class="line">	<span class="keyword">boolean</span> numberic = <span class="keyword">false</span>;<span class="comment">// 记录 当前数字 是否合法</span></span><br><span class="line">	<span class="keyword">char</span>[] chars = s.trim().toCharArray();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) {</span><br><span class="line">		<span class="keyword">char</span> c = chars[i];</span><br><span class="line">		<span class="keyword">if</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) {</span><br><span class="line">			numberic = <span class="keyword">true</span>;</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'+'</span> || c == <span class="string">'-'</span>) {</span><br><span class="line">			<span class="comment">//+-出现在0位置或者e/E的后面第一个位置才是合法的</span></span><br><span class="line">			<span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; chars[i - <span class="number">1</span>] != <span class="string">'e'</span> &amp;&amp; chars[i - <span class="number">1</span>] != <span class="string">'E'</span>) {</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			}</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'.'</span>) {</span><br><span class="line">			 <span class="comment">//.之前不能出现.或者e</span></span><br><span class="line">			<span class="keyword">if</span>(isEExist || isDotExist) {</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			}</span><br><span class="line">			isDotExist = <span class="keyword">true</span>;</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'E'</span> || c == <span class="string">'e'</span>) {<span class="comment">// E/e之前必须有数，且没出现过</span></span><br><span class="line">			 <span class="comment">//e之前不能出现e，必须出现数</span></span><br><span class="line">			<span class="keyword">if</span>(isEExist || !numberic) {</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			}</span><br><span class="line">			isEExist = <span class="keyword">true</span>;</span><br><span class="line">			numberic = <span class="keyword">false</span>;<span class="comment">//重置numberic，排除123e或者123e+的情况,确保e之后也出现数</span></span><br><span class="line">		}<span class="keyword">else</span> {<span class="comment">//其他不合法字符</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> numberic;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸方法二：有限状态自动机"><a href="#🌸方法二：有限状态自动机" class="headerlink" title="🌸方法二：有限状态自动机"></a>🌸方法二：有限状态自动机</h2><h3 id="🍁分析"><a href="#🍁分析" class="headerlink" title="🍁分析"></a>🍁分析</h3><p>本题使用有限状态自动机。根据字符类型和合法数值的特点，先定义状态，再画出状态转移图，最后编写代码即可。</p>
<h4 id="字符类型："><a href="#字符类型：" class="headerlink" title="字符类型："></a>字符类型：</h4><p>空格 「 」、数字「 0—90—9 」 、正负号 「 +-+− 」 、小数点 「 .. 」 、幂符号 「 eEeE 」 。</p>
<h4 id="状态定义："><a href="#状态定义：" class="headerlink" title="状态定义："></a>状态定义：</h4><p>按照字符串从左到右的顺序，定义以下 9 种状态。</p>
<ul>
<li>0 开始的空格</li>
<li>1 幂符号前的正负号</li>
<li>2小数点前的数字</li>
<li>3小数点、小数点后的数字</li>
<li>4当小数点前为空格时，小数点、小数点后的数字</li>
<li>5幂符号</li>
<li>6幂符号后的正负号</li>
<li>7幂符号后的数字</li>
<li>8结尾的空格</li>
</ul>
<h4 id="结束状态："><a href="#结束状态：" class="headerlink" title="结束状态："></a>结束状态：</h4><p>合法的结束状态有 2, 3, 7, 8 。</p>
<p><a href="https://imgchr.com/i/dzjvxP" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/02/dzjvxP.png" alt="dzjvxP.png"></a></p>
<h3 id="🍁算法流程："><a href="#🍁算法流程：" class="headerlink" title="🍁算法流程："></a>🍁算法流程：</h3><ol>
<li>初始化：</li>
</ol>
<ul>
<li><strong>状态转移表 states</strong> ： 设 states[i] ，其中 i为所处状态， states[i]states[i]使用哈希表存储可转移至的状态。键值对 (key, value) 含义：若输入 key ，则可从状态 i转移至状态 value</li>
<li>当前状态 p ： 起始状态初始化为 p = 0。</li>
</ul>
<ol start="2">
<li><p><strong>状态转移循环：</strong> 遍历字符串 s的每个字符 c 。</p>
<ol>
<li>记录字符类型 t ： 分为四种情况。<ul>
<li>当 c 为正负号时，执行 <code>t = 's'</code> ;</li>
<li>当 c 为数字时，执行 <code>t = 'd'</code> ;</li>
<li>当 c 为 e , E 时，执行 <code>t = 'e'</code> ;</li>
<li>当 c 为 . , 空格 时，执行 t = c ``（即用字符本身表示字符类型）;</li>
<li>否则，执行 <code>t = '?</code>‘ ，代表为不属于判断范围的非法字符，后续直接返回 <code>false</code>。</li>
</ul>
</li>
<li>终止条件： 若字符类型 t 不在哈希表 <code>states[p]</code> 中，说明无法转移至下一状态，因此直接返回 False 。</li>
<li>状态转移： 状态 p 转移至 states[p] [t] 。</li>
</ol>
</li>
<li><p>返回值： 跳出循环后，若状态 $p \in {2, 3, 7, 8}$ ，说明结尾合法，返回 TrueTru ，否则返回 False 。</p>
</li>
</ol>
<h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p><strong>时间复杂度 O(N)</strong> ： 其中 N 为字符串 s 的长度，判断需遍历字符串，每轮状态转移的使用 O(1)时间。<br><strong>空间复杂度 O(1)</strong>： states 和 p 使用常数大小的额外空间</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        Map[] states = {</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() {{ put(<span class="string">' '</span>, <span class="number">0</span>); put(<span class="string">'s'</span>, <span class="number">1</span>); put(<span class="string">'d'</span>, <span class="number">2</span>); put(<span class="string">'.'</span>, <span class="number">4</span>); }}, <span class="comment">// 0.</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() {{ put(<span class="string">'d'</span>, <span class="number">2</span>); put(<span class="string">'.'</span>, <span class="number">4</span>); }},                           <span class="comment">// 1.</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() {{ put(<span class="string">'d'</span>, <span class="number">2</span>); put(<span class="string">'.'</span>, <span class="number">3</span>); put(<span class="string">'e'</span>, <span class="number">5</span>); put(<span class="string">' '</span>, <span class="number">8</span>); }}, <span class="comment">// 2.</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() {{ put(<span class="string">'d'</span>, <span class="number">3</span>); put(<span class="string">'e'</span>, <span class="number">5</span>); put(<span class="string">' '</span>, <span class="number">8</span>); }},              <span class="comment">// 3.</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() {{ put(<span class="string">'d'</span>, <span class="number">3</span>); }},                                        <span class="comment">// 4.</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() {{ put(<span class="string">'s'</span>, <span class="number">6</span>); put(<span class="string">'d'</span>, <span class="number">7</span>); }},                           <span class="comment">// 5.</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() {{ put(<span class="string">'d'</span>, <span class="number">7</span>); }},                                        <span class="comment">// 6.</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() {{ put(<span class="string">'d'</span>, <span class="number">7</span>); put(<span class="string">' '</span>, <span class="number">8</span>); }},                           <span class="comment">// 7.</span></span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;&gt;() {{ put(<span class="string">' '</span>, <span class="number">8</span>); }}                                         <span class="comment">// 8.</span></span><br><span class="line">        };</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray()) {</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) t = <span class="string">'d'</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'+'</span> || c == <span class="string">'-'</span>) t = <span class="string">'s'</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'e'</span> || c == <span class="string">'E'</span>) t = <span class="string">'e'</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'.'</span> || c == <span class="string">' '</span>) t = c;</span><br><span class="line">            <span class="keyword">else</span> t = <span class="string">'?'</span>;</span><br><span class="line">            <span class="keyword">if</span>(!states[p].containsKey(t)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            p = (<span class="keyword">int</span>)states[p].get(t);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> p == <span class="number">2</span> || p == <span class="number">3</span> || p == <span class="number">7</span> || p == <span class="number">8</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        states = [</span><br><span class="line">            { <span class="string">' '</span>: <span class="number">0</span>, <span class="string">'s'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">2</span>, <span class="string">'.'</span>: <span class="number">4</span> }, <span class="comment"># 0. start with 'blank'</span></span><br><span class="line">            { <span class="string">'d'</span>: <span class="number">2</span>, <span class="string">'.'</span>: <span class="number">4</span> } ,                <span class="comment"># 1. 'sign' before 'e'</span></span><br><span class="line">            { <span class="string">'d'</span>: <span class="number">2</span>, <span class="string">'.'</span>: <span class="number">3</span>, <span class="string">'e'</span>: <span class="number">5</span>, <span class="string">' '</span>: <span class="number">8</span> }, <span class="comment"># 2. 'digit' before 'dot'</span></span><br><span class="line">            { <span class="string">'d'</span>: <span class="number">3</span>, <span class="string">'e'</span>: <span class="number">5</span>, <span class="string">' '</span>: <span class="number">8</span> },         <span class="comment"># 3. 'digit' after 'dot'</span></span><br><span class="line">            { <span class="string">'d'</span>: <span class="number">3</span> },                         <span class="comment"># 4. 'digit' after 'dot' (‘blank’ before 'dot')</span></span><br><span class="line">            { <span class="string">'s'</span>: <span class="number">6</span>, <span class="string">'d'</span>: <span class="number">7</span> },                 <span class="comment"># 5. 'e'</span></span><br><span class="line">            { <span class="string">'d'</span>: <span class="number">7</span> },                         <span class="comment"># 6. 'sign' after 'e'</span></span><br><span class="line">            { <span class="string">'d'</span>: <span class="number">7</span>, <span class="string">' '</span>: <span class="number">8</span> },                 <span class="comment"># 7. 'digit' after 'e'</span></span><br><span class="line">            { <span class="string">' '</span>: <span class="number">8</span> }                          <span class="comment"># 8. end with 'blank'</span></span><br><span class="line">        ]</span><br><span class="line">        p = <span class="number">0</span>                           <span class="comment"># start with state 0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'0'</span> &lt;= c &lt;= <span class="string">'9'</span>: t = <span class="string">'d'</span> <span class="comment"># digit</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">"+-"</span>: t = <span class="string">'s'</span>     <span class="comment"># sign</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">"eE"</span>: t = <span class="string">'e'</span>     <span class="comment"># e or E</span></span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">". "</span>: t = c       <span class="comment"># dot, blank</span></span><br><span class="line">            <span class="keyword">else</span>: t = <span class="string">'?'</span>               <span class="comment"># unknown</span></span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">not</span> <span class="keyword">in</span> states[p]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            p = states[p][t]</span><br><span class="line">        <span class="keyword">return</span> p <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>状态机</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP_leetcode.214.最短回文串</title>
    <url>/small_String/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p>
<a id="more"></a>

<p>示例 1:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: "aacecaaa"</span><br><span class="line">输出: "aaacecaaa"</span><br></pre></td></tr></tbody></table></figure>


<p>示例 2:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: "abcd"</span><br><span class="line">输出: "dcbabcd"</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸分析"><a href="#🌸分析" class="headerlink" title="🌸分析"></a>🌸分析</h2><p>在字符串开头补充最少的字符，使得当前字符串成为回文串。</p>
<h2 id="🌸解法一：暴力解法"><a href="#🌸解法一：暴力解法" class="headerlink" title="🌸解法一：暴力解法"></a>🌸解法一：暴力解法</h2><p>先判断整个字符串是不是回文串，如果是的话，就直接将当前字符串返回。不是的话，进行下一步。</p>
<p>判断去掉末尾 1 个字符的字符串是不是回文串，如果是的话，就将末尾的 1 个字符加到原字符串的头部返回。不是的话，进行下一步。</p>
<p>判断去掉末尾 2 个字符的字符串是不是回文串，如果是的话，就将末尾的 2 个字符倒置后加到原字符串的头部返回。不是的话，进行下一步。</p>
<p>判断去掉末尾 3 个字符的字符串是不是回文串，如果是的话，就将末尾的 3 个字符倒置后加到原字符串的头部返回。不是的话，进行下一步。</p>
<p>…</p>
<p>直到判断去掉末尾的 <code>n - 1</code> 个字符，整个字符串剩下一个字符，把末尾的 <code>n - 1</code> 个字符倒置后加到原字符串的头部返回。</p>
<p>举个例子，比如字符串 abbacd。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">原字符串 abbacd</span><br><span class="line">先判断 abbacd 是不是回文串, 发现不是, 执行下一步</span><br><span class="line">判断 abbac 是不是回文串, 发现不是, 执行下一步</span><br><span class="line">判断 abba 是不是回文串, 发现是，将末尾的 2 个字符 cd 倒置后加到原字符串的头部,</span><br><span class="line">即 dcabbacd</span><br></pre></td></tr></tbody></table></figure>

<p>代码的话，判断是否是回文串的话可以用 <a href="https://leetcode.wang/leetcode-125-Valid-Palindrome.html" target="_blank" rel="noopener">125 题</a> 的思想，利用双指针法</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否是回文串, 传入字符串的范围</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindromic</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) {</span><br><span class="line">        <span class="keyword">if</span> (c[start] != c[end]) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> end = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//找到回文串的结尾, 用 end 标记</span></span><br><span class="line">    <span class="keyword">for</span> (; end &gt; <span class="number">0</span>; end--) {</span><br><span class="line">        <span class="keyword">if</span> (isPalindromic(s, <span class="number">0</span>, end)) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//将末尾的几个倒置然后加到原字符串开头</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(s.substring(end + <span class="number">1</span>)).reverse() + s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法二："><a href="#🌸解法二：" class="headerlink" title="🌸解法二："></a>🌸解法二：</h2><p>根据解法一，我们其实就是在<strong>寻找从开头开始的最长回文串</strong>（这个很关键，后边所有的解法都是基于这个了），然后将末尾的除去最长回文串部分的几个字符倒置后加到原字符串开头即可。</p>
<p>我们只需要两个指针， <code>i</code> 和 <code>j</code>，<code>i</code> 初始化为 0，<code>j</code> 初始化为字符串长度减 1。然后依次判断 <code>s[i]</code> 和 <code>s[j]</code> 是否相同，相同的话， i 就进行加 1，j 进行减 1。 s[i] 和 s[j] 不同的话，只将 j 进行减 1。</p>
<p>看几个例子。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">abbacde</span><br><span class="line">a b b a c d e</span><br><span class="line">^           ^</span><br><span class="line">i           j</span><br><span class="line">如上所示, s[i] != s[j], j--</span><br><span class="line">    </span><br><span class="line">a b b a c d e</span><br><span class="line">^         ^</span><br><span class="line">i         j</span><br><span class="line">如上所示, s[i] != s[j], j--</span><br><span class="line">    </span><br><span class="line">a b b a c d e</span><br><span class="line">^       ^</span><br><span class="line">i       j</span><br><span class="line">如上所示, s[i] != s[j], j--</span><br><span class="line">    </span><br><span class="line">a b b a c d e</span><br><span class="line">^     ^</span><br><span class="line">i     j</span><br><span class="line">如上所示, s[i] == s[j], i++, j--</span><br><span class="line">    </span><br><span class="line">a b b a c d e</span><br><span class="line">  ^ ^</span><br><span class="line">  i j</span><br><span class="line">如上所示, s[i] == s[j], i++, j--</span><br><span class="line">    </span><br><span class="line">a b b a c d e</span><br><span class="line">  ^ ^</span><br><span class="line">  j i</span><br><span class="line">如上所示, s[i] == s[j], i++, j--</span><br><span class="line">    </span><br><span class="line">a b b a c d e</span><br><span class="line">^     ^</span><br><span class="line">j     i</span><br><span class="line">如上所示, s[i] == s[j], i++, j--</span><br><span class="line">    </span><br><span class="line"> a b b a c d e</span><br><span class="line">^        ^</span><br><span class="line">j        i</span><br><span class="line">如上所示, j &lt; 0, 结束循环。</span><br><span class="line">此时 i 指向最长回文串的下一个字符串,我们只需要把 i 到 最后的字符倒置加到开头即可。</span><br></pre></td></tr></tbody></table></figure>

<p>当然，上边是最理想的情况，如果 <code>j</code> 在最长回文串外提前出现了和 <code>i</code> 相同的字符会有影响吗？</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">abbacba</span><br><span class="line">a b b a c b a</span><br><span class="line">^           ^</span><br><span class="line">i           j</span><br><span class="line">如上所示, s[i] == s[j], i++, j--</span><br><span class="line">    </span><br><span class="line">a b b a c b a</span><br><span class="line">  ^       ^</span><br><span class="line">  i       j</span><br><span class="line">如上所示, s[i] == s[j], i++, j--    </span><br><span class="line">    </span><br><span class="line">a b b a c b a</span><br><span class="line">    ^   ^</span><br><span class="line">    i   j</span><br><span class="line">如上所示, s[i] != s[j], j--</span><br><span class="line">    </span><br><span class="line">a b b a c b a</span><br><span class="line">    ^ ^</span><br><span class="line">    i j</span><br><span class="line">如上所示, s[i] != s[j], j--</span><br><span class="line">    </span><br><span class="line">a b b a c b a</span><br><span class="line">    ^  </span><br><span class="line">    i  </span><br><span class="line">    j</span><br><span class="line">如上所示, s[i] == s[j], i++, j--</span><br><span class="line">    </span><br><span class="line">a b b a c b a</span><br><span class="line">  ^   ^  </span><br><span class="line">  j   i  </span><br><span class="line">如上所示, s[i] != s[j], j--</span><br><span class="line">    </span><br><span class="line">a b b a c b a</span><br><span class="line">^     ^  </span><br><span class="line">j     i  </span><br><span class="line">如上所示, s[i] == s[j], i++, j--   </span><br><span class="line">    </span><br><span class="line"> a b b a c d e</span><br><span class="line">^        ^</span><br><span class="line">j        i</span><br><span class="line">如上所示, j &lt; 0, 结束循环。</span><br><span class="line">会发现此时 i 和之前一样, 依旧指向最长回文串的下一个字符,我们只需要把 i 到最后的字符倒置加到开头即可。</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到上边的两种情况，只要 <code>j</code> 进入了最长回文子串，一定会使得 <code>i</code> 走出最长回文子串。所以我们可以利用双指针写一下代码了。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (i == j){</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (c[i] == c[j]) {</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        j--;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//此时代表整个字符串是回文串</span></span><br><span class="line">    <span class="keyword">if</span> (i == s.length()) {</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//后缀</span></span><br><span class="line">    String suffix = s.substring(i);</span><br><span class="line">    <span class="comment">//后缀倒置</span></span><br><span class="line">    String reverse = <span class="keyword">new</span> StringBuilder(suffix).reverse().toString();</span><br><span class="line">    <span class="comment">//加到开头</span></span><br><span class="line">    <span class="keyword">return</span> reverse + s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>看起来没什么问题，但还有一种情况，那就是 <code>i</code> 提前走出了最长回文子串，看下边的例子。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ababbcefbbaba</span><br><span class="line">a b a b b c e f b b a b a</span><br><span class="line">^                       ^</span><br><span class="line">i                       j</span><br><span class="line"></span><br><span class="line">i 和 j 同时移动, 一直是相等, 直到下边的情况</span><br><span class="line"></span><br><span class="line">a b a b b c e f b b a b a</span><br><span class="line">          ^   ^</span><br><span class="line">          i   j</span><br><span class="line"></span><br><span class="line">然后继续移动, 最后就变成了下边的样子</span><br><span class="line"></span><br><span class="line"> a b a b b c e f b b a b a</span><br><span class="line">^            ^  </span><br><span class="line">j            i   </span><br><span class="line"></span><br><span class="line">会发现此时 0 到 i - 1 并不是一个回文串, 所以我们需要递归的去解决这个问题</span><br></pre></td></tr></tbody></table></figure>

<p>此时我们并没有找到最长回文串，但是我们可以肯定最长回文串一定在 0 到 i 之间，所以我们只需要递归的从<code>s[0, i)</code> 中继续寻找最长回文串即可。</p>
<p>因为上边的所有情况，都保证了 i 一定可以走出最长回文串，只不过可能超出一部分，所以用递归解决即可。代码的整体框架不需要改变。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (c[i] == c[j]) {</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        j--;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//此时代表整个字符串是回文串</span></span><br><span class="line">    <span class="keyword">if</span> (i == s.length()) {</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//后缀</span></span><br><span class="line">    String suffix = s.substring(i);</span><br><span class="line">    <span class="comment">//后缀倒置</span></span><br><span class="line">    String reverse = <span class="keyword">new</span> StringBuilder(suffix).reverse().toString();</span><br><span class="line">    <span class="comment">//递归 s[0,i),寻找开头开始的最长回文串，将其余部分加到开头和结尾</span></span><br><span class="line">    <span class="keyword">return</span> reverse + shortestPalindrome(s.substring(<span class="number">0</span>, i)) + suffix;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法三：暴力（判断回文升级）"><a href="#🌸解法三：暴力（判断回文升级）" class="headerlink" title="🌸解法三：暴力（判断回文升级）"></a>🌸解法三：暴力（判断回文升级）</h2><p>寻找开头开始的最长回文串，我们回到更暴力的方法。</p>
<p>将原始字符串逆序，然后比较对应的子串即可判断是否是回文串。举个例子。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">abbacd</span><br><span class="line"></span><br><span class="line">原s: abbacd, 长度记为 n</span><br><span class="line">逆r: dcabba, 长度记为 n</span><br><span class="line"></span><br><span class="line">判断 s[0,n) 和 r[0,n)</span><br><span class="line">abbacd != dcabba</span><br><span class="line"></span><br><span class="line">判断 s[0,n - 1) 和 r[1,n)</span><br><span class="line">abbac != cabba  </span><br><span class="line"></span><br><span class="line">判断 s[0,n - 2) 和 r[2,n)</span><br><span class="line">abba == abba  </span><br><span class="line"></span><br><span class="line">从开头开始的最长回文串也就找到了, 接下来只需要使用之前的方法。</span><br><span class="line">将末尾不是回文串的部分倒置加到原字符串开头即可。</span><br></pre></td></tr></tbody></table></figure>

<p>代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    String r = <span class="keyword">new</span> StringBuilder(s).reverse().toString();</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">if</span> (s.substring(<span class="number">0</span>, n - i).equals(r.substring(i))) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(s.substring(n - i)).reverse() + s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法四：字符串哈希"><a href="#🌸解法四：字符串哈希" class="headerlink" title="🌸解法四：字符串哈希"></a>🌸解法四：字符串哈希</h2><p>在解法三倒置的基础上进行一下优化，参考 这里。</p>
<p>用到了字符串匹配算法 RK 算法的思想，也就是滚动哈希。</p>
<p>解法三中，每次比较两个字符串是否相等都需要一个字符一个字符比较，如果我们把字符串通过 hash 算法映射到数字，就可以只判断数字是否相等即可。</p>
<p>而 hash 算法，这里的话，我们将 a 看做 1，b 看做 2 … 以此类推，然后把字符串看做是 26 进制的一个数字，将其转为十进制后的值作为 hash 值。</p>
<p>举个例子，对于 abcd。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> a      b    c    d</span><br><span class="line"> 1      2    3    4</span><br><span class="line">26^3  26^2   26   1</span><br></pre></td></tr></tbody></table></figure>

<p>那么 abcd 的 hash 值就是 4+3*26+2*26^2^ + 1*26^3^ 。</p>
<p>这样做的好处是，我们可以通过前一个字符串的 <code>hash</code> 值，算出当前字符串的 <code>hash</code> 值。</p>
<p>举个例子。</p>
<p>对于字符串 abb ，如果我们知道了它的 hash 值是 x ，那么对于 abba 的 hash 值，因为新增加的数字 a 对应 1，所以 abba 的 hash 值就是 <code>(x * 26 + 1)</code>。</p>
<p>所以代码可以写成下边的样子。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = s.length(), pos = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">26</span>; <span class="comment">// 基数</span></span><br><span class="line">    <span class="keyword">int</span> pow = <span class="number">1</span>; <span class="comment">// 为了方便计算倒置字符串的 hash 值</span></span><br><span class="line">    <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> hash1 = <span class="number">0</span>, hash2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++, pow = pow * b) {</span><br><span class="line">        hash1 = hash1 * b + (c[i] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 倒置字符串的 hash 值, 新增的字符要放到最高位</span></span><br><span class="line">        hash2 = hash2 + (c[i] - <span class="string">'a'</span> + <span class="number">1</span>) * pow;</span><br><span class="line">        <span class="keyword">if</span> (hash1 == hash2) {</span><br><span class="line">            pos = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(s.substring(pos + <span class="number">1</span>)).reverse() + s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>提交时出现错误，最直接的问题肯定是由于我们用 int 存储 hash 值，所以一定会出现溢出的情况。溢出以后，接着带来了 hash 冲突，从而使得相同的 hash 值，但是字符串并不相同。</p>
<p>基于上边的分析，我们可以在 pos = i 之前判断一下当前是否是回文串。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindromic</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) {</span><br><span class="line">        <span class="keyword">if</span> (c[start] != c[end]) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = s.length(), pos = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">26</span>; <span class="comment">// 基数</span></span><br><span class="line">    <span class="keyword">int</span> pow = <span class="number">1</span>; <span class="comment">// 为了方便计算倒置字符串的 hash 值</span></span><br><span class="line">    <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> hash1 = <span class="number">0</span>, hash2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++, pow = pow * b) {</span><br><span class="line">        hash1 = hash1 * b + (c[i] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 倒置字符串的 hash 值, 新增的字符要放到最高位</span></span><br><span class="line">        hash2 = hash2 + (c[i] - <span class="string">'a'</span> + <span class="number">1</span>) * pow;</span><br><span class="line">        <span class="keyword">if</span> (hash1 == hash2) {</span><br><span class="line">            <span class="comment">//确认下当前是否是回文串</span></span><br><span class="line">            <span class="keyword">if</span> (isPalindromic(s,<span class="number">0</span>,i)) {</span><br><span class="line">                pos = i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(s.substring(pos + <span class="number">1</span>)).reverse() + s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后就是换 <code>hash</code> 算法，我们可以把每次的结果取模，这样就不会溢出了。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = s.length(), pos = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">26</span>; <span class="comment">// 基数</span></span><br><span class="line">    <span class="keyword">int</span> pow = <span class="number">1</span>; <span class="comment">// 为了方便计算倒置字符串的 hash 值</span></span><br><span class="line">    <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> hash1 = <span class="number">0</span>, hash2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++, pow = (pow * b) % mod) {</span><br><span class="line">        hash1 = (hash1 * b + (c[i] - <span class="string">'a'</span> + <span class="number">1</span>)) % mod;</span><br><span class="line">        <span class="comment">// 倒置字符串的 hash 值, 新增的字符要放到最高位</span></span><br><span class="line">        hash2 = (hash2 + (c[i] - <span class="string">'a'</span> + <span class="number">1</span>) * pow)% mod;</span><br><span class="line">        <span class="keyword">if</span> (hash1 == hash2) {</span><br><span class="line">            pos = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(s.substring(pos + <span class="number">1</span>)).reverse() + s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上边确认当前是否是回文串的时候，我们调用了 isPalindromic ，但超时了，这里的话我们还可以和它的逆置字符串进行比较。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = s.length(), pos = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">26</span>; <span class="comment">// 基数</span></span><br><span class="line">    <span class="keyword">int</span> pow = <span class="number">1</span>; <span class="comment">// 为了方便计算倒置字符串的 hash 值</span></span><br><span class="line">    <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">    String rev = <span class="keyword">new</span> StringBuilder(s).reverse().toString();</span><br><span class="line">    <span class="keyword">int</span> hash1 = <span class="number">0</span>, hash2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++, pow = pow * b) {</span><br><span class="line">        hash1 = hash1 * b + (c[i] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 倒置字符串的 hash 值, 新增的字符要放到最高位</span></span><br><span class="line">        hash2 = hash2 + (c[i] - <span class="string">'a'</span> + <span class="number">1</span>) * pow;</span><br><span class="line">        <span class="keyword">if</span> (hash1 == hash2) {</span><br><span class="line">            <span class="keyword">if</span> (s.substring(<span class="number">0</span>, i + <span class="number">1</span>).equals(rev.substring(n - i - <span class="number">1</span>))) {</span><br><span class="line">                pos = i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(s.substring(pos + <span class="number">1</span>)).reverse() + s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸解法五：KMP算法"><a href="#🌸解法五：KMP算法" class="headerlink" title="🌸解法五：KMP算法"></a>🌸解法五：KMP算法</h2><p>这个解法的前提是你熟悉另一种字符串匹配算法，即 KMP 算法。推荐两个链接，大家可以先学习一下，我就不多说了。</p>
<p>之前也有一篇文章写了KMP，那里有详细证明</p>
<p>如果熟悉了 KMP 算法，下边就简单了。</p>
<p>再回想一下解法三，倒置字符串的思路，依次比较对应子串。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">abbacd</span><br><span class="line"></span><br><span class="line">原s: abbacd, 长度记为 n</span><br><span class="line">逆r: dcabba, 长度记为 n</span><br><span class="line"></span><br><span class="line">我们把两个字符串写在一起</span><br><span class="line">abbacd dcabba</span><br><span class="line"></span><br><span class="line">判断 abbacd 和 dcabba 是否相等</span><br><span class="line">判断 abbac 和 cabba 是否相等</span><br><span class="line">判断 abba 和 abba 是否相等</span><br></pre></td></tr></tbody></table></figure>

<p>如果我们把 abbacd dcabba看成一个字符串，中间加上一个分隔符 #，abbacd#dcabba。</p>
<p>回味一下上边的三条判断，判断 XXX 和 XXX 是否相等，按列看一下。</p>
<p>左半部分 abbacd，abbac , abba 其实就是 abbacd#dcabba 的一些前缀。</p>
<p>右半部分dcabba，cabba，abba 其实就是 abbacd#dcabba 的一些后缀。</p>
<p>寻找前缀和后缀相等。</p>
<p>想一想 KMP 算法，这不就是 next 数组做的事情吗。</p>
<p>而我们中间加了分隔符，也就保证了前缀和后缀相等时，前缀一定在 abbacd 中。</p>
<p>换句话说，我们如果求出了 <code>abbacd#dcabba</code> 的 next 数组，因为我们构造的字符串后缀就是原字符串的倒置，前缀后缀相等时，也就意味着当前前缀是一个回文串，而 next 数组是寻求最长的前缀，我们也就找到了开头开始的最长回文串。</p>
<p>因为 next 数组的含义并不统一，但 KMP 算法本质上都是一样的，所以下边的代码仅供参考。</p>
<p>我的 next 数组 next[i] 所考虑的对应字符串不包含 s[i]。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    String ss = s + <span class="string">'#'</span> + <span class="keyword">new</span> StringBuilder(s).reverse();</span><br><span class="line">    <span class="keyword">int</span> max = getLastNext(ss);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(s.substring(max)).reverse() + s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 next 数组的最后一个值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLastNext</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) {</span><br><span class="line">        <span class="keyword">if</span> (k == -<span class="number">1</span> || c[i - <span class="number">1</span>] == c[k]) {</span><br><span class="line">            next[i] = k + <span class="number">1</span>;</span><br><span class="line">            k++;</span><br><span class="line">            i++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            k = next[k];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> next[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法六-马拉车"><a href="#🌸解法六-马拉车" class="headerlink" title="🌸解法六: 马拉车"></a>🌸解法六: 马拉车</h2><p>大家还记得 第 5 题 吗？求最长回文子串。</p>
<p>这里我们已经把题目转换成了求开头开始的最长回文子串，很明显这个问题只是第 5 题的子问题了。但这道题时间复杂度差不多只有 O(n) 才会通过。这就必须使用 第 5 题 介绍的马拉车算法了。</p>
<p>直接把马拉车算法粘贴过来即可，然后在最后稍微修改一下即可</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">preProcess</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"^$"</span>;</span><br><span class="line">    }</span><br><span class="line">    String ret = <span class="string">"^"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        ret += <span class="string">"#"</span> + s.charAt(i);</span><br><span class="line">    ret += <span class="string">"#$"</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 马拉车算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    String T = preProcess(s);</span><br><span class="line">    <span class="keyword">int</span> n = T.length();</span><br><span class="line">    <span class="keyword">int</span>[] P = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> C = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> i_mirror = <span class="number">2</span> * C - i;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; i) {</span><br><span class="line">            P[i] = Math.min(R - i, P[i_mirror]);<span class="comment">// 防止超出 R</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            P[i] = <span class="number">0</span>;<span class="comment">// 等于 R 的情况</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class="line">        <span class="keyword">while</span> (T.charAt(i + <span class="number">1</span> + P[i]) == T.charAt(i - <span class="number">1</span> - P[i])) {</span><br><span class="line">            P[i]++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否需要更新 R</span></span><br><span class="line">        <span class="keyword">if</span> (i + P[i] &gt; R) {</span><br><span class="line">            C = i;</span><br><span class="line">            R = i + P[i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里的话需要修改</span></span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> centerIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> start = (i - P[i]) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//我们要判断当前回文串是不是开头是不是从 0 开始的</span></span><br><span class="line">        <span class="keyword">if</span> (start == <span class="number">0</span>) {</span><br><span class="line">            maxLen = P[i] &gt; maxLen ? P[i] : maxLen;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(s.substring(maxLen)).reverse() + s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>题解出自<a href="https://leetcode-cn.com/problems/shortest-palindrome/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--44/" target="_blank" rel="noopener">windliang</a></p>
<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>递归</tag>
        <tag>Manacher(马拉车)</tag>
        <tag>Rabin-Karp</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown_语法_数学公式合集</title>
    <url>/markdown_grammer/</url>
    <content><![CDATA[<h2 id="markdown数学公式语法"><a href="#markdown数学公式语法" class="headerlink" title="markdown数学公式语法"></a>markdown数学公式语法</h2><hr>
<h4 id="1-常见运算符"><a href="#1-常见运算符" class="headerlink" title="1.常见运算符"></a>1.常见运算符</h4><table>
<thead>
<tr>
<th>符号</th>
<th>表达式</th>
<th>符号</th>
<th>表达式</th>
<th>符号</th>
<th>表达式</th>
</tr>
</thead>
<tbody><tr>
<td>$$\pm$$</td>
<td>\pm</td>
<td>$$\times$$</td>
<td>\times</td>
<td>$$\div$$</td>
<td>\div</td>
</tr>
<tr>
<td>$$\cdot$$</td>
<td>\cdot</td>
<td>$$\leq$$</td>
<td>\leq</td>
<td>$$\geq$$</td>
<td>\geq</td>
</tr>
<tr>
<td>$$\neq$$</td>
<td>\neq</td>
<td>$$\approx$$</td>
<td>\approx</td>
<td>$$\equiv$$</td>
<td>\equiv</td>
</tr>
<tr>
<td>$$\in$$</td>
<td>\in</td>
<td>$$\notin$$</td>
<td>\notin</td>
<td>$$\subset$$</td>
<td>\subset</td>
</tr>
<tr>
<td>$$\supset$$</td>
<td>\supset</td>
<td>$$\bigcap$$</td>
<td>\bigcap</td>
<td>$$\bigcup$$</td>
<td>\bigcup</td>
</tr>
</tbody></table>
<a id="more"></a>

<h4 id="2-上标和下标"><a href="#2-上标和下标" class="headerlink" title="2.上标和下标"></a>2.上标和下标</h4><ul>
<li>下标使用符号<code>Y_1</code>表达,其中较为复杂的表达式用<code>{}</code>包含，公式表达结果为: $$y_{n+1}$$</li>
<li>上标使用 <code>X^{2m}</code>或者<code>X^2</code>, 其中较为复杂的表达式用<code>{}</code>包含, 公式表达结果为: $$X^{2m}+X^2$$</li>
</ul>
<h4 id="3-特殊符号"><a href="#3-特殊符号" class="headerlink" title="3.特殊符号"></a>3.特殊符号</h4><ul>
<li>求和符号: 使用<code>\sum</code> 转义表达求和符号,下限符号使用<code>_{m}</code>,上限符号使用<code>^\infty</code>, 如:  $$\sum_{m=0}^\infty$$</li>
<li>积分符号: <code>\int_0^1</code>转义表达积分符号, 如: $$\int_0^1$$</li>
<li>极限符号: <code>\lim_{变量 \to 表达式} 表达式</code>, 如 $$\lim_{1 \to 5} 表达式$$</li>
<li>向量符号: <code>\vec{a}</code>转义表达向量, 如: $$\vec{a}$$</li>
<li>空格符号: markdown支持四种空格<code>\, 、\;、\quad 和 \qquad</code></li>
</ul>
<h4 id="4-希腊字母的大小写"><a href="#4-希腊字母的大小写" class="headerlink" title="4.希腊字母的大小写"></a>4.希腊字母的大小写</h4><p>希腊字母的大写使用首字母大写<code>\Gamma</code>转义,小写使用首字母小写<code>\gamma</code>转义, 公式表达结果为:$$\Gamma$$  和   $$\gamma$$</p>
<h4 id="5-关于注释"><a href="#5-关于注释" class="headerlink" title="5.关于注释"></a>5.关于注释</h4><ul>
<li>公式注释: 使用<code>\text{内容}</code>转义注释,公式表达结果为: $$\text {公式注释}$$</li>
<li>文字颜色: 使用<code>\color{颜色}{文字}</code>转义表达带颜色的文字,公式表达结果为:  $$\color{green}{文字}$$</li>
</ul>
<h4 id="6-分数"><a href="#6-分数" class="headerlink" title="6.分数"></a>6.分数</h4><p>分数使用<code>\frac{part I}{part II}</code>转义表达,公式表达结果为: $$\frac{(-1)^m}{m!(m + 1)}$$</p>
<h4 id="7-公式中的大括号或大分隔符"><a href="#7-公式中的大括号或大分隔符" class="headerlink" title="7.公式中的大括号或大分隔符"></a>7.公式中的大括号或大分隔符</h4><ul>
<li>在配对符号中.如公式中的括号使用<code>\left(</code>表达左括号,使用<code>\right)</code>转义表达向右的括号;如: $$\left({\frac{x}{2} }\right)$$</li>
<li>在非配对符号中以<code>\left. 其他 \right符号</code> 或 <code>\left符号 其他 \right.</code> 表非配对的较大符号.如: $$\left.\frac{du}{dx}\right|_{x=0}$$</li>
<li>注: 转义表达不需要<code>{ 和 }</code></li>
</ul>
<h4 id="8-上划线与下划线"><a href="#8-上划线与下划线" class="headerlink" title="8.上划线与下划线"></a>8.上划线与下划线</h4><p>上划线使用<code>\overline{}</code>转义表达,下划线使用<code>\underline{}</code>转义表达,公式表达结果为: $$\overline{a+b+c+d}$$和$$\underline{a+b+c+d}$$</p>
<h4 id="9-开根号"><a href="#9-开根号" class="headerlink" title="9.开根号"></a>9.开根号</h4><p>多次方根使用<code>\sqrt[n]{x}</code>,其中<code>n</code>表示根的次数,<code>x</code>表示被开方项,公式表达结果为: $$\sqrt[n]{3}$$</p>
<h4 id="10-方程组"><a href="#10-方程组" class="headerlink" title="10.方程组"></a>10.方程组</h4><p>1.表达方式一: 使用<code>\begin{array}{c} 表达式一\\表达式二... \end{array}</code></p>
<p> $$\left{ \begin{array} {a} a_1x+b_1y+c_1z=d_1 \ a_2x+b_2y+c_2z=d_2 \end{array} \right.$$</p>
<p>2.表达方式二: 使用<code>\begin{cases}…\end{cases}</code></p>
<p>$$f(n) = \begin{cases} \frac{n}{2}, &amp; \text{if $n$ is even} \[2ex] 3n+1, &amp; \text{if $n$ is odd} \end{cases}$$</p>
<p> 注: 关于<code>\\[2ex]</code>一个 [ex] 指一个 “X-Height”，即x字母高度。可以根据情况指定多个 [ex]，如 [3ex]、[4ex] 等。 其实可以在任何地方使用 [2ex] 语句，只要你觉得合适。</p>
<h4 id="12-使用HTML语法表达数学公式"><a href="#12-使用HTML语法表达数学公式" class="headerlink" title="12.使用HTML语法表达数学公式"></a>12.使用HTML语法表达数学公式</h4><ul>
<li>上标与下标的表达: 使用标签<code>&lt;sub&gt;</code>和<code>&lt;sup&gt;</code>表达, 表达结果为: text 与text</li>
<li>上划线表达: 使用标签<code>&lt;SPAN style="TEXT-DECORATION: overline"&gt;X&lt;/SPAN&gt;</code>表达,表达结果为: <span style="TEXT-DECORATION: overline">X</span></li>
</ul>
<h4 id="13-补充"><a href="#13-补充" class="headerlink" title="13.补充"></a>13.补充</h4><p>对于部分符号无法用 markdown 的公式表达,可以使用 <code>\符号</code> 转义表达,如 $$%$$等</p>
<p>——-欢迎补充</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展欧几里得算法</title>
    <url>/Euclidean_algorithm/</url>
    <content><![CDATA[<h2 id="🌸扩展欧几里德算法"><a href="#🌸扩展欧几里德算法" class="headerlink" title="🌸扩展欧几里德算法"></a>🌸扩展欧几里德算法</h2><p><strong>欧几里德算法是用来求最大公约数的：</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">int gcd(int a,int b)</span><br><span class="line">{</span><br><span class="line">　　return b==0?a:gcd(b,a%b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<p><strong>扩展欧几里德算法描述为：已知a, b求解一组x，y，使它们满足贝祖等式： ax+by = gcd(a, b) =d（解一定存在，根据数论中的相关定理）。</strong></p>
<p><strong>扩展欧几里德常用在求解模线性方程及方程组中。（百度百科）</strong></p>
<p><strong>求解x，y的代码如下：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>    <span class="comment">//扩展欧几里德</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        d=gcd(b,a%b);</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        temp=x;</span><br><span class="line">        x=y;</span><br><span class="line">        y=temp-(a/b)*y;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>已知 a*x+b*y= =gcd(a，b)，gcd(a，b)==gcd(b，a%b)，将 gcd(b，a%b) 代入 a*x+b*y 可得</strong></p>
<p><strong>b*x1+(a%b)*y1==a*x+b*y（ 注意，(x，y) 和（x1,y1）是不同的 ，(x1，y1)是(x，y) 下层的递归值 ）</strong></p>
<p><strong>然后我们需要知道一个公式，a%b= =a-（a/b）*b，将上式变形得 b*x1+（ a-(a/b)*b ）*y1= =a*x+b*y，整理可得a*y1+b*（x1-（a/b）*y）==a*x+b*y；</strong></p>
<p><strong>由此我们可知：</strong></p>
<p><strong>x==y1;</strong></p>
<p><strong>y==x1-（a/b）y;</strong></p>
<p><strong>当递归到底层时，此时 b= =0 ，从而能轻易的得出 gcd（a，b）= =a，x= =1，y==0；知道了最底层的（x，y），我们就可以根据公式递归回去求上面层的（x，y）。</strong></p>
<p><strong>此刻我们只求出了 a*x+b*y==gcd（a，b）的一组解，下面给出公式求剩下的解：</strong></p>
<p><strong>x=x0+a/gcd(a，b)*t；</strong></p>
<p><strong>y=y0-b/gcd(a，b)*t；</strong>　　</p>
<p><strong>（x0，y0）为我们在上面求得的第一组解（x，y）；（t为任意整数，t==0时，就是我们上面的第一组解）</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>    <span class="comment">//扩展欧几里德</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        d=gcd(b,a%b);    <span class="comment">//d存储最大公约数</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        temp=x;</span><br><span class="line">        x=y;</span><br><span class="line">        y=temp-(a/b)*y;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="keyword">int</span> Byue=gcd(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最大公约数为：%d\n"</span>,Byue);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"第一组解为：%d %d\n"</span>,x,y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"有其余解如下：\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">1</span>;t&lt;=<span class="number">10</span>;t++)    <span class="comment">//另外给出10组解</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,x+b/Byue*t,y-a/Byue*t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>下面讨论二元一次方程 ax+by==c的解。</strong></p>
<p><strong>在 ax+by==gcd（a，b）（设解为x0，y0）的基础上等号两边同时乘以 c/gcd（a，b）就可以转换过来了。</strong></p>
<p><strong>所以方程的解为 ：</strong></p>
<p><strong>x=x0*（ c/gcd（a，b））；</strong></p>
<p><strong>y=y0*（ c/gcd（a，b））；</strong></p>
<p><strong>所以我们每求得一组 ax+by==gcd（a，b）的解，就能得到一组 ax+by= =c 的解。</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>    <span class="comment">//扩展欧几里德</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        d=gcd(b,a%b);    <span class="comment">//d存储最大公约数</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        temp=x;</span><br><span class="line">        x=y;</span><br><span class="line">        y=temp-(a/b)*y;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入 ax+by==c 中的 a,b,c: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="keyword">int</span> Byue=gcd(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最大公约数为：%d\n"</span>,Byue);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"第一组解为：%d %d\n"</span>,x*(c/Byue),y*(c/Byue));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"有其余解如下：\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">1</span>;t&lt;=<span class="number">10</span>;t++)    <span class="comment">//另外给出10组解</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,( x+b/Byue*t )*(c/Byue),( y-a/Byue*t )*(c/Byue));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>原文<a href="https://www.cnblogs.com/chiweiming/p/8878202.html" target="_blank" rel="noopener">剑冢</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title>2020_java蓝桥_暑假训练_分治与动态规划2</title>
    <url>/dynamic_programming/</url>
    <content><![CDATA[<h2 id="🌸分治与动态规划训练"><a href="#🌸分治与动态规划训练" class="headerlink" title="🌸分治与动态规划训练"></a>🌸分治与动态规划训练</h2><p>贴在前面，想了解什么是分治，可查看我的这篇文章<a href="https://blog.csdn.net/weixin_45333934/article/details/107434256" target="_blank" rel="noopener">二分查找</a></p>
<h2 id="🍁大数相乘"><a href="#🍁大数相乘" class="headerlink" title="🍁大数相乘"></a>🍁大数相乘</h2><p>用串的形式表示大数的乘法。<br>即求类似：<br>“23234845847839461464158174814792” * “6457847285617487843234535”<br>要求结果返回一个串。</p>
<a id="more"></a>

<h4 id="🍂分析"><a href="#🍂分析" class="headerlink" title="🍂分析"></a>🍂分析</h4><p>这道题既然写在分治里，那必然跟分治脱不了干系，当然一开始也还是想不到分治是怎么分治的（确实好难）。所谓万物皆暴力，一切能暴力出来就先暴力出来，在进行一步步优化升级。好在这道题没有要求不能使用乘法，要是那样的话就整个人都不好了</p>
<h5 id="💥利用大数类BigDecimal"><a href="#💥利用大数类BigDecimal" class="headerlink" title="💥利用大数类BigDecimal"></a>💥利用大数类BigDecimal</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Multiple</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		System.out.println(multiply(<span class="string">"23234845847839461464158174814792"</span>, <span class="string">"6457847285617487843234535"</span>));</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 利用大数类</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> num1</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> num2</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(num1).multiply(<span class="keyword">new</span> BigDecimal(num2)).toString();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="💥模拟人工乘法"><a href="#💥模拟人工乘法" class="headerlink" title="💥模拟人工乘法"></a>💥模拟人工乘法</h5><p>人工乘法在座的各位没有谁不会吧？？？手写的过程利用计算机去一步步实现罢了（对于大数不建议使用，复杂度较高）</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Multiple</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		System.out.println(multiply1(<span class="string">"23234845847839461464158174814792"</span>, <span class="string">"6457847285617487843234535"</span>));</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">multiply1</span><span class="params">(String num1, String num2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 保存计算结果</span></span><br><span class="line">        String res = <span class="string">"0"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// num2 逐位与 num1 相乘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num2.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 保存 num2 第i位数字与 num1 相乘的结果</span></span><br><span class="line">            StringBuilder temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="comment">// 补 0 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num2.length() - <span class="number">1</span> - i; j++) {</span><br><span class="line">                temp.append(<span class="number">0</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">int</span> n2 = num2.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// num2 的第 i 位数字 n2 与 num1 相乘</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = num1.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span> || carry != <span class="number">0</span>; j--) {</span><br><span class="line">                <span class="keyword">int</span> n1 = j &lt; <span class="number">0</span> ? <span class="number">0</span> : num1.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> product = (n1 * n2 + carry) % <span class="number">10</span>;</span><br><span class="line">                temp.append(product);</span><br><span class="line">                carry = (n1 * n2 + carry) / <span class="number">10</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 将当前结果与新计算的结果求和作为新的结果</span></span><br><span class="line">            res = addStrings(res, temp.reverse().toString());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">	}</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对两个字符串数字进行相加，返回字符串形式的和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>{</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>;</span><br><span class="line">             i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry != <span class="number">0</span>;</span><br><span class="line">             i--, j--) {</span><br><span class="line">            <span class="keyword">int</span> x = i &lt; <span class="number">0</span> ? <span class="number">0</span> : num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &lt; <span class="number">0</span> ? <span class="number">0</span> : num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = (x + y + carry) % <span class="number">10</span>;</span><br><span class="line">            builder.append(sum);</span><br><span class="line">            carry = (x + y + carry) / <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> builder.reverse().toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="💥分治"><a href="#💥分治" class="headerlink" title="💥分治"></a>💥分治</h5><p>对于大整数的乘法，我们可以利用分治法将其两个字符串从中间截断，将两字符串的后半部分，进行相乘</p>
<p>子串a1和子串a2，然后结果就是a1+0…000+a2。递归的边界条件就是当每个子串的长度都小于等于4的时候，就可以通过直接乘法运算返回结果。</p>
<p>大数乘法中必须用到大数加法（这里不用上面已经实现的字符串相加函数），而大数加法的思路和大数乘法也是大同小异的，将串a和串b的末尾都切出一段长度为8的子串出来，a从左到右子串分别是a1和a2，b亦然。之后就是考虑t=a2+b2的不同情况，有可能t.size&lt;8，那么这个时候我们就要通过补0的方式)凑够8位。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Multiple</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		System.out.println(multiply2(<span class="string">"23234845847839461464158174814792"</span>, <span class="string">"6457847285617487843234535"</span>));</span><br><span class="line">	}</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">multiply2</span><span class="params">(String num1, String num2)</span> </span>{</span><br><span class="line">    	<span class="keyword">if</span>(num1.length() &lt;= <span class="number">4</span> &amp;&amp; num2.length() &lt;= <span class="number">4</span>) {</span><br><span class="line">    		<span class="keyword">return</span> Integer.parseInt(num1) * Integer.parseInt(num2) + <span class="string">""</span>;</span><br><span class="line">    	}</span><br><span class="line">    	<span class="keyword">if</span>(num1.length() &gt; <span class="number">4</span>) {</span><br><span class="line">    		<span class="keyword">int</span> mid = num1.length() / <span class="number">2</span>;</span><br><span class="line">    		String s1 = num1.substring(<span class="number">0</span>, mid);</span><br><span class="line">    		String s2 = num1.substring(mid);</span><br><span class="line">    		<span class="keyword">return</span> add(multiply2(s1, num2) + add_zero(s2.length()), multiply2(s2, num2));</span><br><span class="line">    	}</span><br><span class="line">    	<span class="keyword">return</span> multiply2(num2, num1);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//补0</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">add_zero</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">    	<span class="keyword">if</span>(x == <span class="number">0</span>) {</span><br><span class="line">    		<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    	}</span><br><span class="line">    	<span class="keyword">if</span>(x == <span class="number">1</span>) {</span><br><span class="line">    		<span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    	}</span><br><span class="line">    	<span class="keyword">return</span> add_zero(x / <span class="number">2</span>) + add_zero(x / <span class="number">2</span>) + add_zero(x % <span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *大数相加</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">add</span><span class="params">(String num1, String num2)</span> </span>{</span><br><span class="line">    	<span class="keyword">if</span>(num1.length() &lt;= <span class="number">8</span> &amp;&amp; num2.length() &lt;= <span class="number">8</span>) {</span><br><span class="line">    		<span class="keyword">return</span> Integer.parseInt(num1) + Integer.parseInt(num2) + <span class="string">""</span>;</span><br><span class="line">    	}</span><br><span class="line">    	String a1 = <span class="string">"0"</span>;</span><br><span class="line">    	String a2 = num1;</span><br><span class="line">    	<span class="keyword">if</span>(num1.length() &gt; <span class="number">8</span>) { <span class="comment">//将num1的低八位分离</span></span><br><span class="line">    		a1 = num1.substring(<span class="number">0</span>, num1.length() - <span class="number">8</span>);</span><br><span class="line">    		a2 = num1.substring(num1.length() - <span class="number">8</span>);</span><br><span class="line">    	}</span><br><span class="line">    	String b1 = <span class="string">"0"</span>;</span><br><span class="line">    	String b2 = num2;</span><br><span class="line">    	<span class="keyword">if</span>(num2.length() &gt; <span class="number">8</span>) {</span><br><span class="line">    		b1 = num2.substring(<span class="number">0</span>, num2.length() - <span class="number">8</span>);</span><br><span class="line">    		b2 = num2.substring(num2.length() - <span class="number">8</span>);</span><br><span class="line">    	}</span><br><span class="line">    	String k = add(a2, b2);</span><br><span class="line">    	<span class="keyword">if</span>(k.length() &gt; <span class="number">8</span>) {</span><br><span class="line">    		<span class="keyword">return</span> add(add(a1, b1), <span class="string">"1"</span>) + k.substring(<span class="number">1</span>);</span><br><span class="line">    	}</span><br><span class="line">    	<span class="keyword">if</span>(k.length() &lt; <span class="number">8</span>) {</span><br><span class="line">    		<span class="keyword">return</span> add(a1, b1) + add_zero(<span class="number">8</span> - k.length()) + k;</span><br><span class="line">    	}</span><br><span class="line">    	<span class="keyword">return</span> add(a1, b1) + k;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🍁城墙刷漆"><a href="#🍁城墙刷漆" class="headerlink" title="🍁城墙刷漆"></a>🍁城墙刷漆</h2><p>X国的一段古城墙的顶端可以看成 2*N个格子组成的矩形(如图所示)</p>
<p><img src="https://img-blog.csdnimg.cn/20200307223421196.png" alt=""></p>
<p>现需要把这些格子刷上保护漆。</p>
<p>你可以从任意一个格子刷起，刷完一格，可以移动到和它相邻的格子（对角相邻也算数），但不能移动到较远的格子（因为油漆未干不能踩！）</p>
<p>比如：a d b c e f 就是合格的刷漆顺序。</p>
<p>c e f d a b 是另一种合适的方案。</p>
<p>当已知 N 时，求总的方案数。当N较大时，结果会迅速增大，请把结果对 1000000007 (十亿零七) 取模。</p>
<p>输入数据为一个正整数（不大于1000）</p>
<p>输出数据为一个正整数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">用户输入：</span><br><span class="line">2</span><br><span class="line">程序应该输出：</span><br><span class="line">24 </span><br><span class="line">再例如：</span><br><span class="line">用户输入：</span><br><span class="line">3</span><br><span class="line">程序应该输出：</span><br><span class="line">96</span><br><span class="line">再例如：</span><br><span class="line">户输入：</span><br><span class="line">22</span><br><span class="line">程序应该输出：</span><br><span class="line">359635897</span><br></pre></td></tr></tbody></table></figure>



<h4 id="🍂分析-1"><a href="#🍂分析-1" class="headerlink" title="🍂分析"></a>🍂分析</h4><p>本题的任务是在已知几个基本行走规则的前提下，求解遍历整个矩形的行走路线数量<br>很多同学的第一想法是搜索，但是搜索算法必然超时，因为本题的数据范围（n最大可取到1000）会使得递归树过深，因此我们不得不另寻思路。而实际上，这种走格子的题目往往和动态规划密切相关<br>对于题目给出的几类行走规则，我们可以很容易地联想到递推。因为对于某个格子，其走到当前可能有很多种走法，但是从另一个角度看来，以某个格子为出发点进行“刷漆”，其行走方式却是一个固定值。我们首先要做的，就是来推理这个过程，从而找到动态转移方程。<br>为了将整个矩形刷完，我们的起点主要分为以下两大类：</p>
<ol>
<li>从四个顶点之一出发</li>
<li>从中间某个点出发</li>
</ol>
<hr>
<p>（一）从顶点出发<br>① 第一步走同一列的另一个格子，然后再走下一列。接着重复这个过程。如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020030722492312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RoZV9aRUQ=,size_16,color_FFFFFF,t_70" alt="从顶点A出发"></p>
<p>比如：假设从顶点A出发，那么第一步没得选，只能走向B；接着在B点时，此时就有两种选择方案，要么走向C，要么走向D。假设走向了D，那么此时D点就只能选C，接着在C点时，其又可以选择E或F……然后重复上面这个过程，直到最终走到矩形的另一侧<br>这种情况（一趟过去，不再返回）用数组a来表示，则可以把问题规模由a[ i ]转换成a[ i-1]<br>于是得到状态转移方程：<code>a[ i ]=2×a[ i-1]</code>（乘2的原因是每次都有两种选择，如在B点可选C或D）</p>
<p>② 第一步走下一列，之后也还是不断地走下一列，当最终走到最后一列后再返回。返回时，由于格子的高度为2，那么在返回时，路径唯一，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200307225056189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RoZV9aRUQ=,size_16,color_FFFFFF,t_70" alt="从顶点A出发"></p>
<p>比如：假设从顶点A出发，那么第一步可以选C或D共两种方案，假设选的是C，那么接下来又可以选择E或F……当最后到了最后一列，比如到了I，那么此时返回的路线也就唯一确定了<br>这种情况（一趟过去，一趟回来）用数组b来表示，则可以把问题规模由b[i]转换成b[ i-1]<br>于是得到状态转移方程：<code>b[ i ]=2×b[ i-1]</code> （乘2的原因是每次都有两种选择，如在A点可选C或D）</p>
<p>③ 第一步走另一列,再由该列返回前一列，然后再从前一列走向另一列的另一个格子，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200307225329443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RoZV9aRUQ=,size_16,color_FFFFFF,t_70" alt="从顶点A出发"></p>
<p>比如：假设从顶点A出发，那么其有两条路线：A-&gt;C-&gt;B-&gt;D或A-&gt;D-&gt;B-&gt;C，假设到了点D，则D又可以有两种选择（要么到E要么到F），此时又可再重复在点A的行为，直到最终到达矩形的另一侧<br>显然这也属于“一趟过去，不再返回”的类型，因此也用数组a来表示，则可以把问题规模转换成a[ i-2 ]<br>于是得到状态转移方程：<code>a[ i ] = 2 × 2 × a[ i-2 ]</code> （第一个乘2是选C或D，二个乘2是选E或F）</p>
<p>综上便分析出了所有的从四个顶点出发的基础遍历方式<br>于是得到转移方程：<code>a[ i ] = 2 × a[ i-1] + b[ i ] + 2 × 2 × a[ i-2]</code><br>由于顶点有4个，于是最终的遍历方案为：<code>sum=4×a[ i ]</code></p>
<hr>
<p>（二）从中间出发<br><img src="https://img-blog.csdnimg.cn/20200307225620149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RoZV9aRUQ=,size_16,color_FFFFFF,t_70" alt="从中间出发"><br>假设我们从图中i=3(E点)处出发（以i为分割线，将图分为左边的ABCDEF以及右边的GHIJ），为了遍历所有格子，我们需要先走完左边的这个整体（特别注意：这里必须倒回到F才能继续走右边），然后再把右边视为以G或者H为起点的一组格子将其走完（因此这里需要乘以2，两种起点出发嘛）<br>分析上述的流程，可以得到从中间出发的方案数为：<code>( b[ i ] ) × ( 2 × a[ n-i ] )</code><br>同理，我们可以先走右边的EFGHIJ，然后再走左边的ABCD<br>这样的方案数为：<code>(b[ n-i+1]) × (2×a[ i - 1])</code><br>由于上面的所有起始点都是以E为出发点行走的，我们同理也可以以F为起点出发，那么从第i列开始刷漆的方法就有:<code>[ (b[ i ])×(2×a[ n-i ])+(b[ n-i+1])×(2×a[ i - 1]) ]×2</code></p>
<p>综合一二，便得出最终的方案数sum为：<code>sum = 4×a[n] + 2×2×( b[ i ]×a[ n-i ] + b[ n-i+1 ]×a[ i - 1] )</code><br>这便是本题的递推公式了，现在的问题是，初值呢？<br>由于在（一）中存在公式：<code>a[ i ] = 2×2×a[i-2]</code>，故我们需要将a[1]、a[2]、b[1]、b[2]都给定<br>所以下面我们需要手动地给出i=1和2的情况：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a[1]=1;		//n=1时，从顶点出发显然只有一种情况</span><br><span class="line">a[2]=6;		//n=2时，从顶点出发有三种情况：a[2]=2+2+2，分别是（一）中的①②③</span><br></pre></td></tr></tbody></table></figure>

<p>情况①：<br><img src="https://img-blog.csdnimg.cn/20200307230341459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RoZV9aRUQ=,size_16,color_FFFFFF,t_70" alt="情况①"></p>
<p>情况②：<br><img src="https://img-blog.csdnimg.cn/20200307230524857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RoZV9aRUQ=,size_16,color_FFFFFF,t_70" alt="情况②"></p>
<p>情况③：<br><img src="https://img-blog.csdnimg.cn/20200307230705575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RoZV9aRUQ=,size_16,color_FFFFFF,t_70" alt="情况③"></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">b[2]=2; 	//显然这种情况下只能是两种，对应上图的情况②</span><br><span class="line">b[1]=1;		//b这种刷漆方式至少需要两个格子（即最低i=2），所以b[1]严格意义上说来是0，但是由于b[2]=2，且存在公式b[i]=2*b[i-1]，故这里反推b[1]=1</span><br></pre></td></tr></tbody></table></figure>

<p>题解出自<a href="https://blog.csdn.net/the_ZED/article/details/104724184" target="_blank" rel="noopener">酱懵静</a></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lattice_brush_paint</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">		System.out.println(brush(n));</span><br><span class="line">		input.close();</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * https://blog.csdn.net/the_ZED/article/details/104724184</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">brush</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">1</span>) {</span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">long</span> a[] = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">1005</span>];</span><br><span class="line">		<span class="keyword">long</span>[] b = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">1005</span>];</span><br><span class="line">		a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		a[<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line">		b[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		b[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) {  <span class="comment">//从一个顶点出发</span></span><br><span class="line">			b[i] = (<span class="number">2</span> * b[i - <span class="number">1</span>]) % MOD;	<span class="comment">//边操作边取余</span></span><br><span class="line">			a[i] = (<span class="number">2</span> * a[i - <span class="number">1</span>] + b[i] + <span class="number">4</span> * a[i - <span class="number">2</span>]) % MOD;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">long</span> sum = <span class="number">4</span> * a[n] % MOD;	<span class="comment">//4个顶点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) {<span class="comment">//从中间出发，注意i的范围是大于1小于n </span></span><br><span class="line">			sum = (sum + <span class="number">4</span> * (b[i] * a[n - i] + b[n - i + <span class="number">1</span>] * a[i - <span class="number">1</span>])) % MOD;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">int</span>)sum;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🍁环形涂色"><a href="#🍁环形涂色" class="headerlink" title="🍁环形涂色"></a>🍁环形涂色</h2><p>如图，组成环形的格子需要涂3种颜色。</p>
<p>它们的编号分别是1~14</p>
<p>相邻的格子不能用相同的颜色。</p>
<p>涂色方案的数目是：24576</p>
<p>当格子数目为50的时候，求涂色方案总数。</p>
<p><a href="https://imgchr.com/i/dtcNNT" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/21/dtcNNT.png" alt="dtcNNT.png"></a></p>
<h4 id="🍂dp分析"><a href="#🍂dp分析" class="headerlink" title="🍂dp分析"></a>🍂dp分析</h4><ul>
<li><p>假设现在考虑最后一个格子填入什么颜色，如果它的前一个格子的颜色和第一个格子的颜色不一样，那么它有两种填法，此时，再看它前面的前面的格子如何填，因为这个格子的后面格子颜色和第一个格子颜色相同，所以相当于之前情况的一个缩小版，有<code>f(n-2)\*2</code>种，</p>
</li>
<li><p><em>再考虑最后一个格子的前一个格子的颜色和第一个格子的颜色一样，那么它有一种填法，而现在再来考虑这个格子之前应该如何涂颜色，也相当于之前情况的缩小版，于是有`f(n-1)\</em>1`种。</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ring_Painting</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">		System.out.println(paint(n));</span><br><span class="line">		input.close();</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">paint</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">		<span class="keyword">long</span>[] dp = <span class="keyword">new</span> <span class="keyword">long</span>[n + <span class="number">1</span>];</span><br><span class="line">		dp[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">		dp[<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line">		dp[<span class="number">3</span>] = <span class="number">6</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) {</span><br><span class="line">			dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span> * dp[i - <span class="number">2</span>];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> dp[n];</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h3><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>2020_java蓝桥_暑假训练_分治与动态规划</title>
    <url>/Divide_and_rule/</url>
    <content><![CDATA[<h2 id="🌸分治与动态规划训练"><a href="#🌸分治与动态规划训练" class="headerlink" title="🌸分治与动态规划训练"></a>🌸分治与动态规划训练</h2><p>贴在前面，想了解什么是分治，可查看我的这篇文章<a href="https://blog.csdn.net/weixin_45333934/article/details/107434256" target="_blank" rel="noopener">二分查找</a></p>
<h2 id="🍁有序列表搜索位置"><a href="#🍁有序列表搜索位置" class="headerlink" title="🍁有序列表搜索位置"></a>🍁有序列表搜索位置</h2><p>已知有序的序列,比如：<br>2,3,3,5,9,9,9,12,12,13,15,22,22,22,22,23,25,25,91,95<br>有整数x，比如： x=23<br>要求找到一个刚好比x稍微大一点的元素位置</p>
<p>当数组较大的时候，需要二分查找加快速度。</p>
<a id="more"></a>

<h4 id="🍂分析"><a href="#🍂分析" class="headerlink" title="🍂分析"></a>🍂分析</h4><p>一看此题，直接暴力（不要求复杂度的话），题中说明利用二分查找，就直接二分模板上吧</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Location_Search</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="comment">//		int n = input.nextInt();</span></span><br><span class="line"><span class="comment">//		int[] a = new int[n];</span></span><br><span class="line"><span class="comment">//		for(int i = 0; i &lt; a.length; i++) {</span></span><br><span class="line"><span class="comment">//			a[i] = input.nextInt();</span></span><br><span class="line"><span class="comment">//		}</span></span><br><span class="line">		<span class="keyword">int</span> x = input.nextInt();</span><br><span class="line">		System.out.println(search(<span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">22</span>,<span class="number">22</span>,<span class="number">22</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">25</span>,<span class="number">25</span>,<span class="number">91</span>,<span class="number">95</span>}, x));</span><br><span class="line">		input.close();</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> right = a.length - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(left &lt; right) {</span><br><span class="line">			<span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">//寻找中位数</span></span><br><span class="line">			<span class="keyword">if</span>(x &gt;= a[mid]) {<span class="comment">//中位数比目标值小或者等于，显然目标值的位置在右边，下一段搜索[mid + 1, right]</span></span><br><span class="line">				left = mid + <span class="number">1</span>;</span><br><span class="line">			}<span class="keyword">else</span> {<span class="comment">//同理</span></span><br><span class="line">				right = mid;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> left;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🍁最大子序和"><a href="#🍁最大子序和" class="headerlink" title="🍁最大子序和"></a>🍁最大子序和</h2><p>数组中整数有正有负</p>
<p>求一连续子段，使得和最大化</p>
<p>例如：</p>
<p><code>2,4,-7,5,2,-1,2,-4,3</code></p>
<p>最大连续段：</p>
<p><code>5,2,-1,2</code></p>
<p>其最大和为8</p>
<h4 id="🍂分析-1"><a href="#🍂分析-1" class="headerlink" title="🍂分析"></a>🍂分析</h4><h5 id="💥暴力"><a href="#💥暴力" class="headerlink" title="💥暴力"></a>💥暴力</h5><p>解题一步一步的来，首先先写好暴力解法，双层循环遍历判断最大和</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Max_sum_of_subsequences</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="comment">//int[] nums = { -2, 1, -3, 4, -1, 2, 1, -5, 4 };</span></span><br><span class="line">		<span class="keyword">int</span>[] nums = {<span class="number">2</span>,<span class="number">4</span>,-<span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>,-<span class="number">1</span>,<span class="number">2</span>,-<span class="number">4</span>,<span class="number">3</span>};</span><br><span class="line">		System.out.println(maxSubArray(nums));</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) {</span><br><span class="line">				<span class="keyword">int</span> sum = sumOfArray(nums, j, i);</span><br><span class="line">				res = Math.max(res, sum);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	}</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumOfArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++) {</span><br><span class="line">			sum += nums[i];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="💥暴力优化"><a href="#💥暴力优化" class="headerlink" title="💥暴力优化"></a>💥暴力优化</h5><p>优化：事实上，上面的代码有一些重复计算。这是因为相同前缀的区间求和，可以通过类似“状态转移”的方法得到。</p>
<p>例如：计算子区间 [1, 4] 的和可以在计算子区间 [1, 3] 的基础上，再加上 <code>nums[4]</code> 得到。 因此，只需要枚举子序的左端点，然后再扫描右端点，就可以减少一个级别的复杂度。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Max_sum_of_subsequences</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="comment">//int[] nums = { -2, 1, -3, 4, -1, 2, 1, -5, 4 };</span></span><br><span class="line">		<span class="keyword">int</span>[] nums = {<span class="number">2</span>,<span class="number">4</span>,-<span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>,-<span class="number">1</span>,<span class="number">2</span>,-<span class="number">4</span>,<span class="number">3</span>};</span><br><span class="line">		System.out.println(maxSubArray1(nums));</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">			<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nums.length; j++) {</span><br><span class="line">				sum += nums[j];</span><br><span class="line">				res = Math.max(sum, res);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="💥动态规划"><a href="#💥动态规划" class="headerlink" title="💥动态规划"></a>💥动态规划</h5><ul>
<li><p>第 1 步：定义状态 既然一个连续子数组一定要以一个数作为结尾，那么我们就将状态定义成如下。</p>
<ul>
<li>dp[i]：表示以 nums[i] 结尾的连续子数组的最大和。</li>
</ul>
</li>
</ul>
<ul>
<li><p>那么为什么这么定义呢？这是因为这样定义状态转移方程容易得到。</p>
<ul>
<li>第2 步：思考状态转移方程 根据状态的定义，由于 nums[i] 一定会被选取，并且 dp[i] 所表示的连续子序列与 dp[i - 1]所表示的连续子序列（有可能）就差一个 nums[i] 。假设数组 nums 全是正数，那么一定有 <code>dp[i] = dp[i - 1] + nums[i]。</code></li>
</ul>
<p>在一般情况下 dp[i - 1] 有可能是负数，例如前几个数都是负数，突然来了一个正数。</p>
<ul>
<li>于是分类讨论：</li>
</ul>
</li>
<li><p>如果 dp[i - 1] &gt;= 0，那么可以把 nums[i] 直接接在 dp[i - 1] 表示的那个数组的后面。</p>
</li>
<li><p>如果 dp[i - 1] &lt; 0，那么加上前面的数反而越来越小了，于是“另起炉灶”，单独的一个 nums[i]，就是 dp[i]。</p>
</li>
<li><p>以上两种情况的最大值就是 dp[i] 的值，写出如下状态转移方程：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">dp[i] = dp[i - 1] + nums[i],  if dp[i - 1] &gt;= 0 </span><br><span class="line"></span><br><span class="line">dp[i] = nums[i],  if  dp[i - 1] &lt; 0</span><br></pre></td></tr></tbody></table></figure>



</li>
</ul>
<ul>
<li>记为“状态转移方程 1”。</li>
</ul>
<ul>
<li>状态转移方程还可以这样写，反正求的是最大值，也不用分类讨论了，就这两种情况，取最大即可（即贪心思想，使每一步都能达到最优解），因此还可以写出状态转移方程如下：</li>
</ul>
   <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">dp[i] = max{nums[i], dp[i - 1] + nums[i]}</span><br></pre></td></tr></tbody></table></figure>



<ul>
<li><p>记为“状态转移方程 2”。</p>
</li>
<li><p>动态规划的问题经常要分类讨论，这是因为动态规划的问题本来就有最优子结构的特征，即大问题的最优解通常由小问题的最优解得到，那么我们就需要通过分类讨论，得到大问题的小问题究竟是哪些。</p>
</li>
</ul>
<ul>
<li>第 3 步：思考初始值 dp[0] 根据定义，一定以 nums[0] 结尾，因此 dp[0] = nums[0]。</li>
</ul>
<ul>
<li>第 4 步：思考输出 这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去。</li>
</ul>
<ul>
<li>输出应该是把所有的 dp[0]、dp[1]、……、dp[n - 1] 都看一遍，取最大值。 </li>
</ul>
<p>状态方程一代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Max_sum_of_subsequences</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="comment">//int[] nums = { -2, 1, -3, 4, -1, 2, 1, -5, 4 };</span></span><br><span class="line">		<span class="keyword">int</span>[] nums = {<span class="number">2</span>,<span class="number">4</span>,-<span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>,-<span class="number">1</span>,<span class="number">2</span>,-<span class="number">4</span>,<span class="number">3</span>};</span><br><span class="line">		System.out.println(maxSubArray2(nums));</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> len = nums.length;</span><br><span class="line">		<span class="keyword">if</span>(len == <span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">		dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) {</span><br><span class="line">			<span class="keyword">if</span>(dp[i - <span class="number">1</span>] &gt;= <span class="number">0</span>) {</span><br><span class="line">				dp[i] = dp[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">			}<span class="keyword">else</span> {</span><br><span class="line">				dp[i] = nums[i];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//最后寻找最大值</span></span><br><span class="line">		<span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) {</span><br><span class="line">			res = Math.max(res, dp[i]);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>💥状态方程2（贪心解法）</p>
<p>贪心 使用单个数组作为输入来查找最大（或最小）元素（或总和）的问题，</p>
<p>贪心算法是可以在线性时间解决的方法之一。</p>
<p>每一步都选择最佳方案，到最后就是全局最优的方案。  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Max_sum_of_subsequences</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="comment">//int[] nums = { -2, 1, -3, 4, -1, 2, 1, -5, 4 };</span></span><br><span class="line">		<span class="keyword">int</span>[] nums = {<span class="number">2</span>,<span class="number">4</span>,-<span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>,-<span class="number">1</span>,<span class="number">2</span>,-<span class="number">4</span>,<span class="number">3</span>};</span><br><span class="line">		System.out.println(maxSubArray3(nums));</span><br><span class="line">        System.out.println(maxSubArray4(nums));</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray3</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> len = nums.length;</span><br><span class="line">		<span class="keyword">if</span>(len == <span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">		dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) {</span><br><span class="line">			dp[i] = Math.max(nums[i] + dp[i - <span class="number">1</span>], nums[i]);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) {</span><br><span class="line">			res = Math.max(res, dp[i]);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray4</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> len = nums.length;</span><br><span class="line">		<span class="keyword">if</span>(len == <span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> pre = nums[<span class="number">0</span>]; <span class="comment">// 代表上一个状态的值</span></span><br><span class="line">		<span class="keyword">int</span> res = pre;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) {</span><br><span class="line">			pre = Math.max(pre + nums[i], nums[i]);</span><br><span class="line">			res = Math.max(res, pre);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="💥分治"><a href="#💥分治" class="headerlink" title="💥分治"></a>💥分治</h5><p>这个是使用分治法解决问题的典型的例子，并且可以用与合并排序相似的算法求解。</p>
<p>分治法的思路是这样的，其实也是分类讨论。 将问题分解为子问题并递归地解决它们。 合并子问题的解以获得原始问题的解</p>
<p>连续子序列的最大和主要由这三部分子区间里元素的最大和得到：</p>
<ul>
<li><p>第 1 部分：子区间 [left, mid]； </p>
</li>
<li><p>第 2 部分：子区间 [mid + 1, right]； </p>
</li>
<li><p>第 3 部分：包含子区间 <code>[mid , mid + 1]</code> 的子区间，即 <code>nums[mid]</code> 与 <code>nums[mid + 1]</code> 一定会被选取。</p>
<p>对它们三者求最大值即可。</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Max_sum_of_subsequences</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="comment">//int[] nums = { -2, 1, -3, 4, -1, 2, 1, -5, 4 };</span></span><br><span class="line">		<span class="keyword">int</span>[] nums = {<span class="number">2</span>,<span class="number">4</span>,-<span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>,-<span class="number">1</span>,<span class="number">2</span>,-<span class="number">4</span>,<span class="number">3</span>};</span><br><span class="line">        System.out.println(maxSubArray5(nums));</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray5</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> len = nums.length;</span><br><span class="line">		<span class="keyword">if</span>(len == <span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> maxSubArraySum(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">if</span>(left == right) {</span><br><span class="line">			<span class="keyword">return</span> nums[left];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> max3(maxSubArraySum(nums, left, mid), maxSubArraySum(nums, mid + <span class="number">1</span>, right), maxCrossingSum(nums, left, mid, right));</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxCrossingSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//一定会包含nums[mid]这个元素</span></span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> leftSum = Integer.MIN_VALUE;</span><br><span class="line">		<span class="comment">//左半边包含nums[mid]元素，最多可以到什么地方</span></span><br><span class="line">		<span class="comment">//走到最边界，看看最值是什么</span></span><br><span class="line">		<span class="comment">//计算一mid结尾的最大的子数组的和</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = mid; i &gt;= left; i--) {</span><br><span class="line">			sum += nums[i];</span><br><span class="line">			<span class="keyword">if</span>(sum &gt; leftSum) {</span><br><span class="line">				leftSum = sum;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> rightSum = Integer.MIN_VALUE;</span><br><span class="line">		<span class="comment">//右半边不包含nums[mid]元素，最多可以到什么地方</span></span><br><span class="line">		<span class="comment">//计算以mid+1开始的最大的子数组的和</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; i++) {</span><br><span class="line">			sum += nums[i];</span><br><span class="line">			<span class="keyword">if</span>(sum &gt; rightSum) {</span><br><span class="line">				rightSum = sum;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> leftSum + rightSum;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max3</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2, <span class="keyword">int</span> n3)</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> Math.max(n1, Math.max(n2, n3));</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注：</p>
<ul>
<li>此分治解法需要仔细推磨想想原理</li>
</ul>
<h2 id="🍁大数相乘"><a href="#🍁大数相乘" class="headerlink" title="🍁大数相乘"></a>🍁大数相乘</h2><p>用串的形式表示大数的乘法。<br>即求类似：<br>“23234845847839461464158174814792” * “6457847285617487843234535”<br>要求结果返回一个串。</p>
<h4 id="🍂分析-2"><a href="#🍂分析-2" class="headerlink" title="🍂分析"></a>🍂分析</h4><p>这道题既然写在分治里，那必然跟分治脱不了干系，当然一开始也还是想不到分治是怎么分治的（确实好难）。所谓万物皆暴力，一切能暴力出来就先暴力出来，在进行一步步优化升级。好在这道题没有要求不能使用乘法，要是那样的话就整个人都不好了</p>
<h5 id="💥利用大数类BigDecimal"><a href="#💥利用大数类BigDecimal" class="headerlink" title="💥利用大数类BigDecimal"></a>💥利用大数类BigDecimal</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Multiple</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		System.out.println(multiply(<span class="string">"23234845847839461464158174814792"</span>, <span class="string">"6457847285617487843234535"</span>));</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 利用大数类</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> num1</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> num2</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(num1).multiply(<span class="keyword">new</span> BigDecimal(num2)).toString();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="💥模拟人工乘法"><a href="#💥模拟人工乘法" class="headerlink" title="💥模拟人工乘法"></a>💥模拟人工乘法</h5><p>人工乘法在座的各位没有谁不会吧？？？手写的过程利用计算机去一步步实现罢了（对于大数不建议使用，复杂度较高）</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Multiple</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		System.out.println(multiply1(<span class="string">"23234845847839461464158174814792"</span>, <span class="string">"6457847285617487843234535"</span>));</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">multiply1</span><span class="params">(String num1, String num2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 保存计算结果</span></span><br><span class="line">        String res = <span class="string">"0"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// num2 逐位与 num1 相乘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num2.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 保存 num2 第i位数字与 num1 相乘的结果</span></span><br><span class="line">            StringBuilder temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="comment">// 补 0 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num2.length() - <span class="number">1</span> - i; j++) {</span><br><span class="line">                temp.append(<span class="number">0</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">int</span> n2 = num2.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// num2 的第 i 位数字 n2 与 num1 相乘</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = num1.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span> || carry != <span class="number">0</span>; j--) {</span><br><span class="line">                <span class="keyword">int</span> n1 = j &lt; <span class="number">0</span> ? <span class="number">0</span> : num1.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> product = (n1 * n2 + carry) % <span class="number">10</span>;</span><br><span class="line">                temp.append(product);</span><br><span class="line">                carry = (n1 * n2 + carry) / <span class="number">10</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 将当前结果与新计算的结果求和作为新的结果</span></span><br><span class="line">            res = addStrings(res, temp.reverse().toString());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">	}</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对两个字符串数字进行相加，返回字符串形式的和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>{</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>;</span><br><span class="line">             i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry != <span class="number">0</span>;</span><br><span class="line">             i--, j--) {</span><br><span class="line">            <span class="keyword">int</span> x = i &lt; <span class="number">0</span> ? <span class="number">0</span> : num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &lt; <span class="number">0</span> ? <span class="number">0</span> : num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = (x + y + carry) % <span class="number">10</span>;</span><br><span class="line">            builder.append(sum);</span><br><span class="line">            carry = (x + y + carry) / <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> builder.reverse().toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="💥分治-1"><a href="#💥分治-1" class="headerlink" title="💥分治"></a>💥分治</h5><p>对于大整数的乘法，我们可以利用分治法将其两个字符串从中间截断，将两字符串的后半部分，进行相乘</p>
<p>子串a1和子串a2，然后结果就是a1+0…000+a2。递归的边界条件就是当每个子串的长度都小于等于4的时候，就可以通过直接乘法运算返回结果。</p>
<p>大数乘法中必须用到大数加法（这里不用上面已经实现的字符串相加函数），而大数加法的思路和大数乘法也是大同小异的，将串a和串b的末尾都切出一段长度为8的子串出来，a从左到右子串分别是a1和a2，b亦然。之后就是考虑t=a2+b2的不同情况，有可能t.size&lt;8，那么这个时候我们就要通过补0的方式)凑够8位。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Multiple</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		System.out.println(multiply2(<span class="string">"23234845847839461464158174814792"</span>, <span class="string">"6457847285617487843234535"</span>));</span><br><span class="line">	}</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">multiply2</span><span class="params">(String num1, String num2)</span> </span>{</span><br><span class="line">    	<span class="keyword">if</span>(num1.length() &lt;= <span class="number">4</span> &amp;&amp; num2.length() &lt;= <span class="number">4</span>) {</span><br><span class="line">    		<span class="keyword">return</span> Integer.parseInt(num1) * Integer.parseInt(num2) + <span class="string">""</span>;</span><br><span class="line">    	}</span><br><span class="line">    	<span class="keyword">if</span>(num1.length() &gt; <span class="number">4</span>) {</span><br><span class="line">    		<span class="keyword">int</span> mid = num1.length() / <span class="number">2</span>;</span><br><span class="line">    		String s1 = num1.substring(<span class="number">0</span>, mid);</span><br><span class="line">    		String s2 = num1.substring(mid);</span><br><span class="line">    		<span class="keyword">return</span> add(multiply2(s1, num2) + add_zero(s2.length()), multiply2(s2, num2));</span><br><span class="line">    	}</span><br><span class="line">    	<span class="keyword">return</span> multiply2(num2, num1);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//补0</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">add_zero</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">    	<span class="keyword">if</span>(x == <span class="number">0</span>) {</span><br><span class="line">    		<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    	}</span><br><span class="line">    	<span class="keyword">if</span>(x == <span class="number">1</span>) {</span><br><span class="line">    		<span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    	}</span><br><span class="line">    	<span class="keyword">return</span> add_zero(x / <span class="number">2</span>) + add_zero(x / <span class="number">2</span>) + add_zero(x % <span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *大数相加</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">add</span><span class="params">(String num1, String num2)</span> </span>{</span><br><span class="line">    	<span class="keyword">if</span>(num1.length() &lt;= <span class="number">8</span> &amp;&amp; num2.length() &lt;= <span class="number">8</span>) {</span><br><span class="line">    		<span class="keyword">return</span> Integer.parseInt(num1) + Integer.parseInt(num2) + <span class="string">""</span>;</span><br><span class="line">    	}</span><br><span class="line">    	String a1 = <span class="string">"0"</span>;</span><br><span class="line">    	String a2 = num1;</span><br><span class="line">    	<span class="keyword">if</span>(num1.length() &gt; <span class="number">8</span>) { <span class="comment">//将num1的低八位分离</span></span><br><span class="line">    		a1 = num1.substring(<span class="number">0</span>, num1.length() - <span class="number">8</span>);</span><br><span class="line">    		a2 = num1.substring(num1.length() - <span class="number">8</span>);</span><br><span class="line">    	}</span><br><span class="line">    	String b1 = <span class="string">"0"</span>;</span><br><span class="line">    	String b2 = num2;</span><br><span class="line">    	<span class="keyword">if</span>(num2.length() &gt; <span class="number">8</span>) {</span><br><span class="line">    		b1 = num2.substring(<span class="number">0</span>, num2.length() - <span class="number">8</span>);</span><br><span class="line">    		b2 = num2.substring(num2.length() - <span class="number">8</span>);</span><br><span class="line">    	}</span><br><span class="line">    	String k = add(a2, b2);</span><br><span class="line">    	<span class="keyword">if</span>(k.length() &gt; <span class="number">8</span>) {</span><br><span class="line">    		<span class="keyword">return</span> add(add(a1, b1), <span class="string">"1"</span>) + k.substring(<span class="number">1</span>);</span><br><span class="line">    	}</span><br><span class="line">    	<span class="keyword">if</span>(k.length() &lt; <span class="number">8</span>) {</span><br><span class="line">    		<span class="keyword">return</span> add(a1, b1) + add_zero(<span class="number">8</span> - k.length()) + k;</span><br><span class="line">    	}</span><br><span class="line">    	<span class="keyword">return</span> add(a1, b1) + k;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>二分搜索</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>2020_java蓝桥_暑假训练_进制(补)+博弈问题</title>
    <url>/Game_problem/</url>
    <content><![CDATA[<h2 id="🌸博弈训练"><a href="#🌸博弈训练" class="headerlink" title="🌸博弈训练"></a>🌸博弈训练</h2><p>贴在前面，想了解什么是博弈论，博弈论的基本游戏和基本解法可查看<a href="https://blog.csdn.net/qq_40167327/article/details/99334507?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.edu_weight" target="_blank" rel="noopener">韦泽鑫の博客</a>和<a href="https://blog.csdn.net/Crystal_viv/article/details/79417137" target="_blank" rel="noopener">想要成为富婆的我每天都在努力の博客</a></p>
<a id="more"></a>

<h2 id="🍁Excel地址"><a href="#🍁Excel地址" class="headerlink" title="🍁Excel地址"></a>🍁Excel地址</h2><p>Excel单元格的地址表示很有趣，它使用字母来表示列号，比如：</p>
<p>A表示第1列，</p>
<p>B表示第2列，</p>
<p>Z表示第26列，</p>
<p>AA表示第27列，</p>
<p>AB表示第28列，</p>
<p>BA表示第53列，</p>
<p>….</p>
<p>当然Excel的最大列号是有限度的，所以转换起来不难。</p>
<p>如果我们想把这种表示法一般化，可以把很大的数字转换为很长的字母序列呢？</p>
<p>本题目既是要求对输入的数字, 输出其对应的Excel地址表示方式 </p>
<p>例如，</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">26</span><br><span class="line">程序应该输出：</span><br><span class="line">Z </span><br><span class="line">输入：</span><br><span class="line">2054</span><br><span class="line">则程序应该输出：</span><br><span class="line">BZZ</span><br></pre></td></tr></tbody></table></figure>



<p><strong>我们约定，输入的整数范围[1,2147483647]</strong></p>
<h4 id="🍂分析"><a href="#🍂分析" class="headerlink" title="🍂分析"></a>🍂分析</h4><p>此题是进制与整除的变种，需要理解题意有时甚至可以逆向思维推导</p>
<p>可找出以下规律</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a=1;</span><br><span class="line">	b=2;</span><br><span class="line">	z=26;</span><br><span class="line">	aa=1*26+1=27</span><br><span class="line">	ab=1*26+2=28;</span><br><span class="line">	az=1*26+26=52;</span><br><span class="line">	ba=2*26+1=53;</span><br><span class="line"> 	bb=2*26+2=54;</span><br><span class="line"> 	za=26*26+1=676;</span><br><span class="line"> 	zz=26*26+26=702</span><br><span class="line">	aaa=1*26*26+1*26+1=703;</span><br><span class="line">	aab=1*26*26+1*26+2=704;</span><br><span class="line">	aaz=1*26*26+1*26+26=728;</span><br><span class="line">	aba=1*26*26+2*26+1=729;</span><br><span class="line">	azz=1*26*26+26*26+26=1378;</span><br><span class="line">	baa=2*26*26+1*26+1=1379;</span><br><span class="line">bab=2*26*26+1*26+2=1379;</span><br><span class="line">baz=2*26*26+1*26+26=1404;</span><br><span class="line">bba=2*26*26+2*26+1=1405;</span><br><span class="line">....................</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Excel_address</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">		System.out.println(chage(n));</span><br><span class="line">		input.close();</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">chage</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">		StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">while</span>(n &gt; <span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">if</span>(n % <span class="number">26</span> == <span class="number">0</span>) { <span class="comment">//n除以26能整除说明最后一位必定是Z</span></span><br><span class="line">				str.append(<span class="string">"Z"</span>);</span><br><span class="line">				n /= <span class="number">26</span>;</span><br><span class="line">				n--; 	<span class="comment">//前面一行已经除过26了，所以要把那一份26减掉</span></span><br><span class="line">			}<span class="keyword">else</span> {</span><br><span class="line">				str.append((<span class="keyword">char</span>)(<span class="string">'A'</span> + n % <span class="number">26</span> - <span class="number">1</span>));</span><br><span class="line">				n /= <span class="number">26</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> str.reverse().toString();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🍁高僧斗法"><a href="#🍁高僧斗法" class="headerlink" title="🍁高僧斗法"></a>🍁高僧斗法</h2><p>古时丧葬活动中经常请高僧做法事。仪式结束后，有时会有“高僧斗法”的趣味节目，以舒缓压抑的气氛。  节目大略步骤为：先用粮食（一般是稻米）在地上“画”出若干级台阶（表示N级浮屠）。又有若干小和尚随机地“站”在某个台阶上。最高一级台阶必须站人，其它任意。</p>
<p>两位参加斗法的法师分别指挥某个小和尚向上走任意多级的台阶，但会被站在高级台阶上的小和尚阻挡，不能越过。</p>
<p>两个小和尚也不能站在同一台阶，也不能向低级台阶移动。</p>
<p> 两法师轮流发出指令，最后所有小和尚必然会都挤在高段台阶，再也不能向上移动。轮到哪个法师指挥时无法继续移动，则游戏结束，该法师认输。</p>
<p> 对于已知的台阶数和小和尚的分布位置，请你计算先发指令的法师该如何决策才能保证胜出。</p>
<p>输入数据为一行用空格分 尚的位置。台阶序号从1算起，所以最后一个小和尚的位置即是台阶的总数。（N&lt;100, 台阶总数&lt;1000）</p>
<p> 输出为一行用空格分开的两个整数: A B, 表示把A位置的小和尚移动到B位置。</p>
<p>若有多个解，输出A值较小的解，若无解则输出-1。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">用户输入：</span><br><span class="line">1 5 9</span><br><span class="line">则程序输出： </span><br><span class="line">1 4</span><br><span class="line">再如：</span><br><span class="line">用户输入：</span><br><span class="line">1 5 8 10</span><br><span class="line">则程序输出：</span><br><span class="line">1 3</span><br></pre></td></tr></tbody></table></figure>

<h4 id="🍂分析-1"><a href="#🍂分析-1" class="headerlink" title="🍂分析"></a>🍂分析</h4><h5 id="🍂尼姆博奕（Nimm-Game）"><a href="#🍂尼姆博奕（Nimm-Game）" class="headerlink" title="🍂尼姆博奕（Nimm Game）"></a>🍂尼姆博奕（Nimm Game）</h5><p>有三堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。这种情况最有意思，它与二进制有密切关系，我们用（a，b，c）表示某种局势，首先（0，0，0）显然是奇异局势，无论谁面对奇异局势，都必然失败。第二种奇异局势是（0，n，n），只要与对手拿走一样多的物品，最后都将导致（0，0，0）。仔细分析一下，（1，2，3）也是奇异局势，无论对手如何拿，接下来都可以变为（0，n，n）的情形。计算机算法里面有一种叫做按位模2加，也叫做异或的运算（相异为1,相同为0），我们用符号（+）表示这种运算。这种运算和一般加法不同的一点是1+1=0。先看（1，2，3）的按位模2加的结果：</p>
<p>1 =二进制01</p>
<p>2 =二进制10</p>
<p>3 =二进制11 （+）</p>
<p>———————</p>
<p>0 =二进制00 （注意不进位）</p>
<p>  对于奇异局势（0，n，n）也一样，结果也是0。</p>
<p>  任何奇异局势（a，b，c）都有a（+）b（+）c =0。</p>
<p>如果我们面对的是一个非奇异局势（a，b，c），要如何变为奇异局势呢？假设 a &lt; b&lt; c,我们只要将 c 变为 a（+）b,即可,因为有如下的运算结果:a（+）b（+）(a（+）b)=(a（+）a)（+）(b（+）b)=0（+）0=0。要将c 变为a（+）b，只要从 c中减去 c-（a（+）b）即可。</p>
<p>此题便是尼姆博弈的典型例子，<strong>只要找到怎样改变使可移动的台阶数之间异或相加之后结果为0就是必赢局面，如果没有移动之前异或相加的值就是0，那么是必输局面</strong>，先求出n个和尚中每个和尚可以向上移动的台阶数量，再将和尚两两分组，1和2、3和4、……、2i-1和2i，只需要求出两两分组之间台阶数的异或相加值就可以判断是否为必赢局面，因为移动3可以通过移动2达到同样的异或结果，同理移动4也可以通过移动5达到同样的异或结果，所以有影响的只有两两组合之间的台阶数。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Nimm_Game</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		String[] nim = input.nextLine().split(<span class="string">" "</span>);</span><br><span class="line">		<span class="keyword">int</span>[] address = <span class="keyword">new</span> <span class="keyword">int</span>[nim.length]; <span class="comment">// 用来存放和尚站的阶梯的位置</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; address.length; i++) {</span><br><span class="line">			address[i] = Integer.parseInt(nim[i]);</span><br><span class="line">		}</span><br><span class="line">		game(address);</span><br><span class="line">		input.close();</span><br><span class="line">	}	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">game</span><span class="params">(<span class="keyword">int</span>[] address)</span> </span>{</span><br><span class="line">		<span class="comment">//用于存放和尚之间的阶梯数量</span></span><br><span class="line">		<span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[address.length];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; address.length; i++) {</span><br><span class="line">			count[i - <span class="number">1</span>] = address[i] - address[i - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 用于记录走的步数的异或和</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length; i += <span class="number">2</span>) {</span><br><span class="line">			sum ^= count[i]; <span class="comment">//异或和</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(sum == <span class="number">0</span>) {<span class="comment">// 如果异或和结果为0，则必输</span></span><br><span class="line">			System.out.println(<span class="string">"必输！"</span>);</span><br><span class="line">		}<span class="keyword">else</span> {</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; address.length; i++) { <span class="comment">// 所有和尚的移动，一个一个的进行枚举</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= count[i]; j++) { <span class="comment">//从第一节台阶开始进行枚举</span></span><br><span class="line">					count[i] -= j;</span><br><span class="line">					<span class="keyword">if</span>(i &gt; <span class="number">0</span>) {</span><br><span class="line">						count[i - <span class="number">1</span>] += j;</span><br><span class="line">					}</span><br><span class="line">					sum = <span class="number">0</span>; <span class="comment">//每走一步重新计算异或值</span></span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; count.length; k += <span class="number">2</span>) {</span><br><span class="line">						sum ^= count[k];</span><br><span class="line">					}</span><br><span class="line">					<span class="keyword">if</span>(sum == <span class="number">0</span>) {</span><br><span class="line">						System.out.println(address[i] + <span class="string">" "</span> + (address[i] + j));</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					}</span><br><span class="line">					<span class="comment">//回溯</span></span><br><span class="line">					count[i] += j;</span><br><span class="line">					<span class="keyword">if</span>(i &gt; <span class="number">0</span>) {</span><br><span class="line">						count[i - <span class="number">1</span>] -= j;</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">if</span>(sum == <span class="number">0</span>) {<span class="comment">//特判，可加可不加</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🍁高斯日记"><a href="#🍁高斯日记" class="headerlink" title="🍁高斯日记"></a>🍁高斯日记</h2><p>大数学家高斯有个好习惯：无论如何都要记日记。</p>
<p>他的日记有个与众不同的地方，他从不注明年月日，而是用一个整数代替，比如：4210</p>
<p>后来人们知道，那个整数就是日期，它表示那一天是高斯出生后的第几天。这或许也是个好习惯，它时时刻刻提醒着主人：日子又过去一天，还有多少时光可以用于浪费呢 </p>
<p>高斯出生于：1777年4月30日。</p>
<p>在高斯发现的一个重要定理的日记上标注着：5343，因此可算出那天是：1791年12月15日。</p>
<p>高斯获得博士学位的那天日记上标着：8113  </p>
<p>请你算出高斯获得博士学位的年月日。</p>
<h4 id="🍂分析-2"><a href="#🍂分析-2" class="headerlink" title="🍂分析"></a>🍂分析</h4><p>此题没什么好分析的，单纯的暴力模拟日期，一天天的加上去就ok了（能用Excel首用Excel，能用API首用API）</p>
<p>利用API</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gauss_Diary</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		getDate();</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getDate</span><span class="params">()</span> </span>{</span><br><span class="line">		Calendar c = Calendar.getInstance();</span><br><span class="line">		c.set(<span class="number">1777</span>, <span class="number">04</span>, <span class="number">30</span>);</span><br><span class="line">		c.add(Calendar.DATE, <span class="number">8113</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">		<span class="keyword">int</span> month = c.get(Calendar.MONTH);</span><br><span class="line">		String m = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">if</span>(month &lt; <span class="number">10</span>) {</span><br><span class="line">			m = <span class="string">"0"</span> + month;</span><br><span class="line"> 		}<span class="keyword">else</span> {</span><br><span class="line"> 			m += month;</span><br><span class="line"> 		}</span><br><span class="line">		<span class="keyword">int</span> day = c.get(Calendar.DATE);</span><br><span class="line">		System.out.println(year + <span class="string">"-"</span> + m + <span class="string">"-"</span> + day);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gauss_Diary</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		getDate2();</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getDate2</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> year = <span class="number">1777</span>, month = <span class="number">4</span>, day = <span class="number">30</span>;</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(num &lt; <span class="number">8113</span>) {</span><br><span class="line">			<span class="keyword">if</span>(month == <span class="number">12</span> &amp;&amp; day == <span class="number">31</span>) {</span><br><span class="line">				year++;</span><br><span class="line">				month = <span class="number">1</span>;</span><br><span class="line">				day = <span class="number">1</span>;</span><br><span class="line">			}<span class="keyword">else</span> <span class="keyword">if</span>(day == getDays(year, month)) {</span><br><span class="line">				month++;</span><br><span class="line">				day = <span class="number">1</span>;</span><br><span class="line">			}<span class="keyword">else</span> {</span><br><span class="line">				day++;</span><br><span class="line">			}</span><br><span class="line">			num++;</span><br><span class="line">		}</span><br><span class="line">		String m = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">if</span>(month &lt; <span class="number">10</span>) {</span><br><span class="line">			m = <span class="string">"0"</span> + month;</span><br><span class="line"> 		}<span class="keyword">else</span> {</span><br><span class="line"> 			m += month;</span><br><span class="line"> 		}</span><br><span class="line">		System.out.println(year + <span class="string">"-"</span> + m + <span class="string">"-"</span> + day);</span><br><span class="line">	}</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断闰年</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> year</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isleap</span><span class="params">(<span class="keyword">int</span> year)</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || year % <span class="number">400</span> == <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 计算当年某月的天数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> year</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> month</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDays</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> days;</span><br><span class="line">		<span class="keyword">switch</span>(month) {</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: {</span><br><span class="line">			<span class="keyword">if</span>(isleap(year)) {</span><br><span class="line">				days = <span class="number">29</span>;</span><br><span class="line">			}<span class="keyword">else</span> {</span><br><span class="line">				days = <span class="number">28</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">11</span>: {</span><br><span class="line">			days = <span class="number">30</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">default</span> :</span><br><span class="line">			days = <span class="number">31</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> days;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🍁古代赌局"><a href="#🍁古代赌局" class="headerlink" title="🍁古代赌局"></a>🍁古代赌局</h2><p>俗话说：十赌九输。因为大多数赌局的背后都藏有阴谋。</p>
<p>不过也不尽然，有些赌局背后藏有的是：“阳谋”。</p>
<p>有一种赌局是这样的：桌子上放六个匣子，编号是1至6。</p>
<p>多位参与者（以下称玩家）可以把任意数量的钱押在某个编号的匣子上。</p>
<p>所有玩家都下注后，庄家同时掷出3个骰子（骰子上的数字都是1至6）。</p>
<p>输赢规则如下：</p>
<p>1.若只有1个骰子上的数字与玩家所押注的匣子号相同，则玩家拿回自己的押注，庄家按他押注的数目赔付（即1比1的赔率）。</p>
<p>2.若2个骰子上的数字与玩家所押注的匣子号相同，则玩家拿回自己的押注，庄家按他押注的数目的2倍赔付（即1比2的赔率）。</p>
<p>3.若3个骰子上的数字都与玩家押注的匣子号相同，则玩家拿回自己的押注，庄家按他押注的数目的10倍赔付（即1比10的赔率）。</p>
<p>乍一看起来，好像规则对玩家有利，庄家吃亏。但经过大量实战，会发现局面很难说，于是怀疑是否庄家做了手脚，庄家则十分爽快地说：可以由玩家提供骰子，甚至也可以由玩家来投掷骰子。</p>
<p>你的任务是：通过编程模拟该过程。模拟50万次，假定只有1个玩家，他每次的押注都是1元钱，其押注的匣子号是随机的。再假定庄家有足够的资金用于赔付。最后计算出庄家的盈率（庄家盈利金额/押注总金额）。</p>
<h4 id="🍂分析-3"><a href="#🍂分析-3" class="headerlink" title="🍂分析"></a>🍂分析</h4><p>直接模拟赌博过程</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ancient_Gambling</span> </span>{</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//押注总钱数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> m = <span class="number">1</span>;	<span class="comment">// 押注都是1元钱</span></span><br><span class="line">		<span class="keyword">int</span> n;		<span class="comment">// 押注匣子号</span></span><br><span class="line">		<span class="keyword">int</span> a;		<span class="comment">// 第一个骰子</span></span><br><span class="line">		<span class="keyword">int</span> b;		<span class="comment">// 第二个骰子</span></span><br><span class="line">		<span class="keyword">int</span> c;		<span class="comment">// 第三个骰子</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) {</span><br><span class="line">			n = (<span class="keyword">int</span>)(Math.random() * <span class="number">6</span> + <span class="number">1</span>);</span><br><span class="line">			a = (<span class="keyword">int</span>)(Math.random() * <span class="number">6</span> + <span class="number">1</span>);</span><br><span class="line">			b = (<span class="keyword">int</span>)(Math.random() * <span class="number">6</span> + <span class="number">1</span>);</span><br><span class="line">			c = (<span class="keyword">int</span>)(Math.random() * <span class="number">6</span> + <span class="number">1</span>);</span><br><span class="line">			gamble(m, n, a, b, c);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">double</span> f = sum / <span class="number">500000.0</span>;</span><br><span class="line">		System.out.println(f);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gamble</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span>(n == a &amp;&amp; n == b &amp;&amp; n == c) {</span><br><span class="line">			sum -= m * <span class="number">10</span>;</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>((n == a &amp;&amp; n == b) || (n == a &amp;&amp; n == c) || (n == b &amp;&amp; n == c)) {</span><br><span class="line">			sum -= m * <span class="number">2</span>;</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(n == a || n == b || n == c) {</span><br><span class="line">			sum -= m;</span><br><span class="line">		}<span class="keyword">else</span> {</span><br><span class="line">			sum += m;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🍁国庆节"><a href="#🍁国庆节" class="headerlink" title="🍁国庆节"></a>🍁国庆节</h2><p>1949年的国庆节（10月1日）是星期六。 </p>
<p>今年（2012）的国庆节是星期一。</p>
<p>那么，从建国到现在，有几次国庆节正好是星期日呢？</p>
<p>只要答案，不限手段！</p>
<p>可以用windows日历，windows计算器，Excel公式，。。。。。</p>
<p>当然，也可以编程！</p>
<h4 id="🍂普通解法"><a href="#🍂普通解法" class="headerlink" title="🍂普通解法"></a>🍂普通解法</h4><p>利用当年10月1日到1949年10月2日的总天数计算模以7是否为0，如果是则代表那天为星期日</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">National_day</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 1949年的国庆节（10月2日）是星期日。 </span></span><br><span class="line">		<span class="comment">// 得到这年10月2号后的的剩余天数</span></span><br><span class="line">		<span class="keyword">int</span> sum = getCal(<span class="number">1949</span>, <span class="number">12</span>, <span class="number">31</span>) - getCal(<span class="number">1949</span>, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1950</span>; i &lt; <span class="number">2012</span>; i++) {</span><br><span class="line">			sum += getCal(i, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(sum % <span class="number">7</span> == <span class="number">0</span>) {</span><br><span class="line">				System.out.println(i + <span class="string">"年10月1日"</span>);</span><br><span class="line">				count++;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		System.out.println(<span class="string">"总数："</span> + count);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断闰年</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> year</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isleap</span><span class="params">(<span class="keyword">int</span> year)</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || year % <span class="number">400</span> == <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 计算当年当日前的总天数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> year</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> month</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> day</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCal</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span>[][] days = {{<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>},{<span class="number">0</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>}};</span><br><span class="line">		<span class="keyword">int</span> run = <span class="number">0</span>;<span class="comment">//默认不是闰年</span></span><br><span class="line">		<span class="keyword">if</span>(isleap(year)) {</span><br><span class="line">			run = <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> sum = day;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; month; i++) {</span><br><span class="line">			sum += days[run][i];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="🍂解法二：基姆拉尔森计算公式"><a href="#🍂解法二：基姆拉尔森计算公式" class="headerlink" title="🍂解法二：基姆拉尔森计算公式"></a>🍂解法二：基姆拉尔森计算公式</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">National_day</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		search();</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  基姆拉尔森计算公式</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1950</span>; i &lt; <span class="number">2012</span>; i++) {</span><br><span class="line">			<span class="keyword">if</span>(jim(i, <span class="number">10</span>, <span class="number">1</span>) == <span class="number">6</span>) {</span><br><span class="line">				System.out.println(i + <span class="string">"年10月1日"</span>);</span><br><span class="line">				count++;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		System.out.println(<span class="string">"总数："</span> + count);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jim</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span>(month == <span class="number">1</span> || month == <span class="number">2</span>) {</span><br><span class="line">			month += <span class="number">12</span>;</span><br><span class="line">			year--;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> (day + <span class="number">2</span> * month + <span class="number">3</span> * (month + <span class="number">1</span>) / <span class="number">5</span> + year + year / <span class="number">4</span> - year / <span class="number">100</span> + year / <span class="number">400</span>) % <span class="number">7</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h2 id="🍁火柴游戏"><a href="#🍁火柴游戏" class="headerlink" title="🍁火柴游戏"></a>🍁火柴游戏</h2><p>这是一个纵横火柴棒游戏。</p>
<p>如表</p>
<table>
<thead>
<tr>
<th>3</th>
<th></th>
<th></th>
<th>—</th>
<th align="center">|</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>—</td>
<td></td>
<td></td>
<td align="center"></td>
</tr>
<tr>
<td>1</td>
<td></td>
<td>—</td>
<td></td>
<td align="center"></td>
</tr>
<tr>
<td></td>
<td>A</td>
<td>B</td>
<td>C</td>
<td align="center">D</td>
</tr>
</tbody></table>
<p>在3x4的格子中，游戏的双方轮流放置火柴棒。</p>
<p>其规则是：</p>
<ol>
<li><p>不能放置在已经放置了火柴棒的地方（即只能在空格中放置）。</p>
</li>
<li><p>火柴棒的方向只能是竖直或水平放置。</p>
</li>
<li><p>火柴棒不能与其它格子中的火柴“连通”。</p>
</li>
</ol>
<p>所谓连通是指两根火柴棒可以连成一条直线，且中间没有其它不同方向的火柴“阻拦”。</p>
<p>例如：</p>
<p>表所示的局面下，可以在C2位置竖直放置（为了方便描述格子位置，图中左、下都添加了标记），但不能水平放置，因为会与A2连通。</p>
<p>同样道理，B2，B3，D2此时两种方向都不可以放置。</p>
<p>但如果C2竖直放置后，D2就可以水平放置了，因为不再会与A2连通（受到了C2的阻挡）。</p>
<ol start="4">
<li>游戏双方轮流放置火柴，不可以弃权，也不可以放多根。</li>
</ol>
<p>如某一方无法继续放置，则该方为负（输的一方）。</p>
<p>游戏开始时可能已经放置了多根火柴。</p>
<p>你的任务是：编写程序，读入初始状态，计算出对自己最有利的放置方法并输出放置后的局面。</p>
<p>图1的局面表示为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">00-1</span><br><span class="line"></span><br><span class="line">-000</span><br><span class="line"></span><br><span class="line">0100</span><br><span class="line"></span><br><span class="line">即用“0”表示空闲位置，用“1”表示竖直放置，用“-”表示水平放置。</span><br></pre></td></tr></tbody></table></figure>

<p>解法不唯一，找到任意解法即可。</p>
<p>例如，局面：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0111</span><br><span class="line">-000</span><br><span class="line">-000</span><br><span class="line">的解：</span><br><span class="line">-111</span><br><span class="line">-000</span><br><span class="line">-000</span><br><span class="line"> </span><br><span class="line">再例如，局面：</span><br><span class="line">1111</span><br><span class="line">----</span><br><span class="line">0010</span><br><span class="line">的解：</span><br><span class="line">1111</span><br><span class="line">----</span><br><span class="line">0110</span><br></pre></td></tr></tbody></table></figure>

<h4 id="🍂分析-4"><a href="#🍂分析-4" class="headerlink" title="🍂分析"></a>🍂分析</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">思考中。。</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🍁取球游戏"><a href="#🍁取球游戏" class="headerlink" title="🍁取球游戏"></a>🍁取球游戏</h2><p>今盒里有n个小球，A、B两人轮流从盒中取球。</p>
<p>每个人都可以看到另一个人取了多少个，也可以看到盒中还剩下多少个。</p>
<p>两人都很聪明，不会做出错误的判断。</p>
<p>每个人从盒子中取出的球的数目必须是：1，3，7或者8个。</p>
<p>轮到某一方取球时不能弃权！</p>
<p>A先取球，然后双方交替取球，直到取完。</p>
<p>被迫拿到最后一个球的一方为负方（输方）</p>
<p>编程确定出在双方都不判断失误的情况下，对于特定的初始球数，A是否能赢？</p>
<h4 id="🍂分析-5"><a href="#🍂分析-5" class="headerlink" title="🍂分析"></a>🍂分析</h4><p>已知每人最多能取1，3，7或者8个,那么，球总数=乙必输的情况+甲拿（1，3，7或者8个），球为1时甲必输，以此类推（可以正向迭代和逆向递归），正向：将10000以内的输赢情况都存入数组，然后查表。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ball_Game</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">		List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">			list.add(input.nextInt());</span><br><span class="line">		}</span><br><span class="line">		ball(list);</span><br><span class="line">		input.close();</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ball</span><span class="params">(List&lt;Integer&gt; list)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span>[] take = {<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>};</span><br><span class="line">		<span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10010</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) {</span><br><span class="line">			<span class="keyword">if</span>(res[i] == <span class="number">0</span>) {</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) {</span><br><span class="line">					res[i + take[j]] = <span class="number">1</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) {</span><br><span class="line">			System.out.println(<span class="string">"结果："</span> + res[list.get(i)]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>逆向：球数是n时，只要满足n-1，n-3，n-7和n-8有一个数字对于乙玩家来说是必输的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ball_Game</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">		List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">			list.add(input.nextInt());</span><br><span class="line">		}</span><br><span class="line">		ball2(list);</span><br><span class="line">		input.close();</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ball2</span><span class="params">(List&lt;Integer&gt; list)</span> </span>{</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) {</span><br><span class="line">			<span class="keyword">if</span>(test(list.get(i))) {</span><br><span class="line">				System.out.println(<span class="number">1</span>);</span><br><span class="line">			}<span class="keyword">else</span> {</span><br><span class="line">				System.out.println(<span class="number">0</span>);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">if</span>(n &gt;= <span class="number">1</span>) {</span><br><span class="line">			<span class="keyword">switch</span>(n) {</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">// 剩1个球,则输</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">// 剩3个球,则输</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">// 剩7个球,则输</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">// 剩8个球,则赢</span></span><br><span class="line">			<span class="comment">// 如果不是不是1，3，7，8则 选择权交给B，B任然调用该函数，不过返回值需要取反</span></span><br><span class="line">			<span class="comment">// 而此时A可以选的只有 1 3 7 8 所以用num减去之 逐个测试即可</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">return</span> (!test(n - <span class="number">8</span>) || !test(n - <span class="number">7</span>) || !test(n - <span class="number">3</span>) || !test(n - <span class="number">1</span>));</span><br><span class="line">			}</span><br><span class="line">		}<span class="keyword">else</span> {</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁填字母游戏"><a href="#🍁填字母游戏" class="headerlink" title="🍁填字母游戏"></a>🍁填字母游戏</h3><p>K大师在纸上画了一行n个格子，要小明和他交替往其中填入字母。</p>
<ol>
<li><p>轮到某人填的时候，只能在某个空 格中填入L或O</p>
</li>
<li><p>谁先让字母组成了“LOL”的字样，谁获胜。</p>
</li>
<li><p>如果所有格子都填满了，仍无法组成LOL，则平局。</p>
</li>
</ol>
<p>小明试验了几次都输了，他很惭愧，希望你能用计算机帮他解开这个谜。</p>
<p>本题的输入格式为：</p>
<p>第一行，数字n（n&lt;10），表示下面有n个初始局面。</p>
<p>接下来，n行，每行一个串，表示开始的局面。</p>
<p> 比如：“<strong>**</strong>”, 表示有6个空格。“L** **”,  表示左边是一个字母L，它的右边是4个空格。</p>
<p>要求输出n个数字，表示对每个局面，如果小明先填，当K大师总是用最强着法的时候，小明的最好结果。</p>
<p>1 表示能赢</p>
<p>-1 表示必输</p>
<p>0 表示可以逼平</p>
<p>例如，</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">***</span><br><span class="line">L**L</span><br><span class="line">L**L***L</span><br><span class="line">L*****L </span><br><span class="line"></span><br><span class="line">则程序应该输出：</span><br><span class="line">0</span><br><span class="line">-1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure>

<h4 id="🍂分析-6"><a href="#🍂分析-6" class="headerlink" title="🍂分析"></a>🍂分析</h4><p>利用回溯，一步一步的进行递归尝试，每走一步进行一次递归，将结果放入哈希表（利用记忆化哈希表减少递归查找的时间复杂度）。具体详情可查看代码注释</p>
<h5 id="下面介绍带平局的博弈类解法魔板："><a href="#下面介绍带平局的博弈类解法魔板：" class="headerlink" title="下面介绍带平局的博弈类解法魔板："></a>下面介绍带平局的博弈类解法魔板：</h5><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">main函数里调用dfs (a)</span><br><span class="line">给定一个局面a,dfs(a)是计算我方通过最优步骤走是输还是赢还是平局。</span><br><span class="line">利用map容器记录局面胜负平的状态可减少重复局面的运算提高算法效率</span><br><span class="line">胜负平</span><br><span class="line">dfs (局面a) {</span><br><span class="line">	边界值处理</span><br><span class="line">    for (所有可走的局面) {</span><br><span class="line">        试着走一步，得到一个新局面b</span><br><span class="line">        交给对手走，即判断dfs (b)的返回值</span><br><span class="line">        恢复局面</span><br><span class="line">        如果返回值为负，则我必赢，即这步是我的最优走法</span><br><span class="line">        如果返回值为赢，则我必输，不可取</span><br><span class="line">        如果返回值为平，则我至少可以逼平对手，先存着这个结果</span><br><span class="line">    }</span><br><span class="line">    如果算的可以逼平，则返回平</span><br><span class="line">    否则返回负|</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>解法代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alphabet_Game</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">		input.nextLine();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">			String str = input.nextLine();</span><br><span class="line">			System.out.println(dfs(str.toCharArray()));</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//System.out.println(dfs("L**L".toCharArray()));</span></span><br><span class="line">		input.close();</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] a)</span> </span>{</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		String s = <span class="keyword">new</span> String(a);</span><br><span class="line">		<span class="keyword">if</span>(map.containsKey(s)) {</span><br><span class="line">			<span class="keyword">return</span> map.get(s);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(s.contains(<span class="string">"LOL"</span>)) { <span class="comment">//如果对手给我的局面是包含了”LOL"的情况，那我就输了</span></span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(!s.contains(<span class="string">"*"</span>)) { <span class="comment">//如果对手给我的局面是没有空格可以填的情况，那我没赢也没输，返回平局</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">boolean</span> ping = <span class="keyword">false</span>; <span class="comment">//先假设我跟对手之间不可能出现平局</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) { <span class="comment">//开始循环，对有空格进行试填</span></span><br><span class="line">			<span class="keyword">if</span>(a[i] == <span class="string">'*'</span>) { <span class="comment">//循环开始，先判断遍历到的地方是不是空格，这里是空格的情况，</span></span><br><span class="line">				a[i] = <span class="string">'L'</span>; <span class="comment">//自己进行尝试填写</span></span><br><span class="line">				<span class="comment">//自己下完后交给对手进行判断</span></span><br><span class="line">				<span class="comment">//此时switch()中传入的dfs(a)已经不是最开始传入的a数组了</span></span><br><span class="line">				<span class="comment">//而是试填L后的a数组</span></span><br><span class="line">				<span class="keyword">int</span> res = dfs(a);</span><br><span class="line">				<span class="comment">//存入哈希表</span></span><br><span class="line">				map.put(String.valueOf(a), res);</span><br><span class="line">				<span class="keyword">switch</span>(res) {</span><br><span class="line">				<span class="keyword">case</span> -<span class="number">1</span>: <span class="comment">//如果对手返回-1，那么就是我赢了，我就返回1</span></span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				<span class="comment">//如果对手返回0就是对手有可把我逼平的方法，此时我不是直接返回0是因为</span></span><br><span class="line">				<span class="comment">//我继续下下一个空格可能有将对手赢了的可能，所以我先将ping置为true</span></span><br><span class="line">				<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">					ping = <span class="keyword">true</span>;</span><br><span class="line">				}</span><br><span class="line">				<span class="comment">//回到我自己下</span></span><br><span class="line">				a[i] = <span class="string">'O'</span>;</span><br><span class="line">				<span class="comment">//交给对手</span></span><br><span class="line">				res = dfs(a);</span><br><span class="line">				map.put(String.valueOf(a), res);</span><br><span class="line">				<span class="comment">//回溯，因为你们操作的是同一个数组</span></span><br><span class="line">				a[i] = <span class="string">'*'</span>;</span><br><span class="line">				<span class="keyword">switch</span>(res) {</span><br><span class="line">				<span class="keyword">case</span> -<span class="number">1</span>:</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">					ping = <span class="keyword">true</span>;</span><br><span class="line">				}</span><br><span class="line"></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//最后返回如果对手没有返回输的话，就是我赢不了对手了，</span></span><br><span class="line">		<span class="comment">//这个时候我再来看看是否有平局的可能</span></span><br><span class="line">		<span class="keyword">if</span>(ping) {</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//平局都没有，那我就输了</span></span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>博弈论</tag>
        <tag>基姆拉尔森公式</tag>
      </tags>
  </entry>
  <entry>
    <title>2020_java蓝桥_暑假训练_进制与整除</title>
    <url>/System_and_division/</url>
    <content><![CDATA[<h2 id="🌸进制与整除训练"><a href="#🌸进制与整除训练" class="headerlink" title="🌸进制与整除训练"></a>🌸进制与整除训练</h2><h2 id="🍁Strange-Donation"><a href="#🍁Strange-Donation" class="headerlink" title="🍁Strange_Donation"></a>🍁Strange_Donation</h2><p>地产大亨Q先生临终的遗愿是：拿出100万元给X社区的居民抽奖，以稍慰藉心中愧疚。</p>
<p>麻烦的是，他有个很奇怪的要求：</p>
<ol>
<li><p>100万元必须被正好分成若干份（不能剩余）。 每份必须是7的若干元。 比如：1元, 7元，49元，343元，…</p>
</li>
<li><p>相同金额的份数不能超过5份。</p>
</li>
<li><p>在满足上述要求的情况下，分成的份数越多越好！</p>
</li>
</ol>
<p>请你帮忙计算一下，最多可以分为多少份？</p>
<a id="more"></a>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>换个角度考虑，如果拿出1234567890元分给居民，每份必须是10的若干次方元，<br>且相同金额份数不超过9份，那么最多可以分为多少份？ 那么只有1种情况，10元9份，100元8份，1000元7份，10000元6份….    可以看到，这实际上是进制的问题，即题目要求的是以7进制形式表示后的数字，然后把每位数字相加即可求出份数。题意。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strange_Donation</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		System.out.println(donate(<span class="number">1000</span> * <span class="number">1000</span>, <span class="number">7</span>));</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> m</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">donate</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{</span><br><span class="line">		String s = Integer.toString(n, m);</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line">			sum += s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🍁Weight-weighing"><a href="#🍁Weight-weighing" class="headerlink" title="🍁Weight_weighing"></a>🍁Weight_weighing</h2><p>用天平称重时，我们希望用尽可能少的砝码组合称出尽可能多的重量。如果只有5个砝码，重量分别是1，3，9，27，81则它们可以组合称出1到121之间任意整数重量（砝码允许放在左右两个盘中）。</p>
<p> 本题目要求编程实现：对用户给定的重量，给出砝码组合方案。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">用户输入：</span><br><span class="line"></span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">程序输出：</span><br><span class="line"></span><br><span class="line">9-3-1</span><br><span class="line"></span><br><span class="line">用户输入：</span><br><span class="line"></span><br><span class="line">19</span><br><span class="line"></span><br><span class="line">程序输出：</span><br><span class="line"></span><br><span class="line">27-9+1</span><br></pre></td></tr></tbody></table></figure>

<p><code>要求程序输出的组合总是大数在前小数在后。</code></p>
<p><code>可以假设用户的输入的数字符合范围1~121。</code></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><strong>暴力解法</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weight_weighing</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">		weight(n);</span><br><span class="line">		weight2(n);</span><br><span class="line">		input.close();</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span>[] sign = {-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>};</span><br><span class="line">		StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a : sign) {</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> b : sign) {</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> c : sign) {</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> d : sign) {</span><br><span class="line">						<span class="keyword">for</span>(<span class="keyword">int</span> e: sign) {</span><br><span class="line">							<span class="keyword">int</span> i = a * <span class="number">1</span>;</span><br><span class="line">							<span class="keyword">int</span> j = b * <span class="number">3</span>;</span><br><span class="line">							<span class="keyword">int</span> k = c * <span class="number">9</span>;</span><br><span class="line">							<span class="keyword">int</span> l = d * <span class="number">27</span>;</span><br><span class="line">							<span class="keyword">int</span> m = e * <span class="number">81</span>;</span><br><span class="line">							<span class="keyword">if</span>(i + j + k + l + m == n) {</span><br><span class="line">								str.append(m != <span class="number">0</span> ? (m &gt; <span class="number">0</span> ? <span class="string">"+"</span> + m : m) : <span class="string">""</span>);</span><br><span class="line">								str.append(l != <span class="number">0</span> ? (l &gt; <span class="number">0</span> ? <span class="string">"+"</span> + l : l) : <span class="string">""</span>);</span><br><span class="line">								str.append(k != <span class="number">0</span> ? (k &gt; <span class="number">0</span> ? <span class="string">"+"</span> + k : k) : <span class="string">""</span>);</span><br><span class="line">								str.append(j != <span class="number">0</span> ? (j &gt; <span class="number">0</span> ? <span class="string">"+"</span> + j : j) : <span class="string">""</span>);</span><br><span class="line">								str.append(i != <span class="number">0</span> ? (i &gt; <span class="number">0</span> ? <span class="string">"+"</span> + i : i) : <span class="string">""</span>);</span><br><span class="line">								str.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">								System.out.println(str);</span><br><span class="line">								<span class="keyword">return</span>;</span><br><span class="line">							}</span><br><span class="line">						}</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁解法二：利用进制"><a href="#🍁解法二：利用进制" class="headerlink" title="🍁解法二：利用进制"></a>🍁解法二：利用进制</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weight_weighing</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">		weight2(n);</span><br><span class="line">		input.close();</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weight2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">		<span class="comment">//转化为三进制</span></span><br><span class="line">		String x = Integer.toString(n, <span class="number">3</span>);<span class="comment">// 1000=27三进制 举例25 等于2 2 1</span></span><br><span class="line">		<span class="comment">// 翻转后转成字符数组 为什么翻转:好进位1 3 9</span></span><br><span class="line">		<span class="keyword">char</span>[] arr = <span class="keyword">new</span> StringBuffer(x).reverse().toString().toCharArray();<span class="comment">// 翻转变成了1 2 2</span></span><br><span class="line">		List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">// 变成了1 0 -1 1 从右到左插入</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {<span class="comment">// 数组 1 2 2</span></span><br><span class="line">			<span class="keyword">if</span>(arr[i] == <span class="string">'2'</span>) {</span><br><span class="line">				list.add(<span class="number">0</span>, -<span class="number">1</span>);<span class="comment">// -1插在开头</span></span><br><span class="line">				<span class="keyword">if</span>(i == arr.length - <span class="number">1</span>) {</span><br><span class="line">					list.add(<span class="number">0</span>, <span class="number">1</span>);<span class="comment">// 最后一个字符，进位 变成3</span></span><br><span class="line">				}<span class="keyword">else</span> {</span><br><span class="line">					++arr[i + <span class="number">1</span>];</span><br><span class="line">				}</span><br><span class="line">			}<span class="keyword">else</span> <span class="keyword">if</span>(arr[i] == <span class="string">'3'</span>) {</span><br><span class="line">				list.add(<span class="number">0</span>, <span class="number">0</span>);<span class="comment">// 插入0 &gt;&gt;&gt;&gt;1 0 -1 1</span></span><br><span class="line">				<span class="comment">// 更高位</span></span><br><span class="line">				<span class="keyword">if</span>(i == arr.length - <span class="number">1</span>) {</span><br><span class="line">					list.add(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">				}<span class="keyword">else</span> {</span><br><span class="line">					++arr[i + <span class="number">1</span>];</span><br><span class="line">				}</span><br><span class="line">			}<span class="keyword">else</span> {</span><br><span class="line">				list.add(<span class="number">0</span>, arr[i] - <span class="string">'0'</span>);<span class="comment">// 只有1 和0的情况 arr[i]-'0'&gt;&gt;&gt; 转化成数字</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		StringBuilder str = <span class="keyword">new</span> StringBuilder();<span class="comment">//恢复成十进制</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) {</span><br><span class="line">			<span class="keyword">if</span>(list.get(i) == <span class="number">1</span>) {</span><br><span class="line">				str.append(<span class="string">"+"</span>).append((<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, list.size() - i - <span class="number">1</span>));</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span>(list.get(i) == -<span class="number">1</span>) {</span><br><span class="line">				str.append(<span class="string">"-"</span>).append((<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, list.size() - i - <span class="number">1</span>));</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	System.out.println(str.substring(<span class="number">1</span>));</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🍁Nim-Pile"><a href="#🍁Nim-Pile" class="headerlink" title="🍁Nim_Pile"></a>🍁Nim_Pile</h2><p>有3堆硬币，分别是3,4,5</p>
<p>二人轮流取硬币。</p>
<p>每人每次只能从某一堆上取任意数量。</p>
<p>不能弃权。</p>
<p>取到最后一枚硬币的为赢家。 </p>
<p>求先取硬币一方有无必胜的招法。</p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>这个题有固定的解法，用二进制模2的加法/异或。<br>具体意思是：将所有堆的数目进行模2加法/异或，如果加起来全为0，那么将要抓堆的这个人就必输了；如果不全为0，那么这个人通过计算抓堆的数量就会让对方输。<br>举例来说：一共4堆：2,5,12,14<br>二进制对应：<br>0010<br>0101<br>1100<br>1110 </p>
<p>0101<br>对每个堆的数目进行异或后结果不为0，所以将要抓堆的这个人不会输，那么他如何让对方输呢？<br>就是在他抓取一次后给对方留的堆的数目异或起来为0，由0101-&gt;0000，将左起第2位和第4位变0，分析造成位结果为1的原因，把某一堆堆数量的对应位取反就可以了（0-&gt;1or1-&gt;0）<br>由异或运算性质，0异或任何数，其结果=任何数，1异或任何数，其结果=把该数取反。<br>这个异或运算的结果恰好就是我们想要达到的效果。所以我们可以将所有数异或运算后的结果再与某堆数目进行异或，得到的结果就是该堆剩下的数目。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Nim_Pile</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span>[] coin = {<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">		method(coin);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span>[] co)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; co.length; i++) {<span class="comment">//按位异或后的结果 </span></span><br><span class="line">			sum ^= co[i];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(sum == <span class="number">0</span>) {</span><br><span class="line">			System.out.println(<span class="string">"必输"</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; co.length; i++) {</span><br><span class="line">			<span class="keyword">int</span> x = sum ^ co[i]; <span class="comment">//x:在取了第i堆后剩下的 </span></span><br><span class="line">			<span class="keyword">if</span>(x &lt; co[i]) {</span><br><span class="line">				System.out.println(co[i] + <span class="string">"-&gt;"</span> + x);<span class="comment">//原先第i堆的个数-&gt;取后剩下的个数 </span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🍁The-Least-Multiple-of-Number"><a href="#🍁The-Least-Multiple-of-Number" class="headerlink" title="🍁The_Least_Multiple_of_Number"></a>🍁The_Least_Multiple_of_Number</h2><p>如果两个数很大，怎样求最大公约数，最小公倍数？</p>
<p>如果是n个数呢？比如1000个数的最小公倍数</p>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>求解n个数的最小公倍数一般有两种做法：</p>
<p>1.分解质因数法：先把这几个数分解质因数,再把它们一切公有的质因数和其中几个数公有的质因数以及每个数的独有的质因数全部连乘起来,所得的积就是它们的最小公倍数.</p>
<p>12   15      8        9</p>
<p>12=2<em>2</em>3</p>
<p>15=3*5</p>
<p>8=2<em>2</em>2</p>
<p>9=3*3</p>
<p>其中12和8公有两个2，而12,15,9则公有质因子3，剩下的15独自有一个5,8独自有一个2,9独自有一个3</p>
<p>因此：最小公倍数为2<em>2</em>3<em>5</em>2*3=360</p>
<p>这种方法个人觉得适合人去算，并不适合计算机去计算。计算机更适合采用第二种方法。</p>
<p>2.公式法两两运用</p>
<p>假设现在要求最小公倍数的两个数为x,y，他们的最大公约数为p,最小公倍数为q。则x<em>y=p</em>q,也就是说只要求得两个数的最大公约数就可求得这两个数的最小公倍数。</p>
<p>但是题目中要求的是n个数的 最小公倍数，这里只需要用最小公倍数代替原来的两个数即可。</p>
<p>例如：12      15        8         9</p>
<p>第一步：求得12和15的最小公倍数为60 </p>
<p>第二部：求得60和8的最小公倍数为120</p>
<p>第三步：求得120和9的最小公倍数为360</p>
<p>所以，原问题转换为求两个数的最大公约数。最大公约数有几种求法，第一种对于小整数的辗转相除，大整数用辗转相减，还有优化版本的辗转相减法，这里给定数字范围为int因此直接采用辗转相除法。</p>
<p>辗转相除求最大公约数O(lgn)<br>递归写法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">int gcd(int a,int b){</span><br><span class="line">	if(b==0)</span><br><span class="line">		return a;</span><br><span class="line">	else</span><br><span class="line">		return gcd(b,a%b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>非递归写法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">int gcd(int a,int b){</span><br><span class="line">	int c;</span><br><span class="line">	while(b){</span><br><span class="line">		c=a;</span><br><span class="line">		a=b;</span><br><span class="line">		b=c%b</span><br><span class="line">	}</span><br><span class="line">	return a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>利用x<em>y=q</em>p得到最小公倍数q=x*y/p;</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">The_Least_Multiple_of_Number</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">			arr[i] = input.nextInt();</span><br><span class="line">			<span class="keyword">if</span>(i != <span class="number">1</span>) {</span><br><span class="line">				arr[i] = arr[i - <span class="number">1</span>] / gcb(arr[i - <span class="number">1</span>], arr[i]) * arr[i];				</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		System.out.println(arr[n]);</span><br><span class="line">		input.close();</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcb</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span>(b == <span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">return</span> a;</span><br><span class="line">		}<span class="keyword">else</span> {</span><br><span class="line">			<span class="keyword">return</span> gcb(b, a % b);			</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🍁One-step-away"><a href="#🍁One-step-away" class="headerlink" title="🍁One_step_away"></a>🍁One_step_away</h2><p>从昏迷中醒来，小明发现自己被关在X星球的废矿车里。矿车停在平直的废弃的轨道上。他的面前是两个按钮，分别写着“F”和“B”。 小明突然记起来，这两个按钮可以控制矿车在轨道上前进和后退。按F，会前进97米。按B会后退127米。透过昏暗的灯光，小明看到自己前方1米远正好有个监控探头。他必须设法使得矿车正好停在摄像头的下方，才有机会争取同伴的援助。或许，通过多次操作F和B可以办到。 矿车上的动力已经不太足，黄色的警示灯在默默闪烁…每次进行 F 或 B 操作都会消耗一定的能量。小明飞快地计算，至少要多少次操作，才能把矿车准确地停在前方1米远的地方。 请填写为了达成目标，最少需要操作的次数。</p>
<h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One_step_away</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		operation(<span class="number">97</span>, <span class="number">127</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 暴力解法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> m</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; ; t++) {</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> x  = <span class="number">0</span>; x &lt; t; x++) {</span><br><span class="line">				<span class="keyword">int</span> y = t - x;</span><br><span class="line">				<span class="keyword">if</span>(n * x - m * y == <span class="number">1</span>) {</span><br><span class="line">					System.out.println(<span class="string">"走"</span> + n + <span class="string">" "</span> + x  + <span class="string">"步"</span> + m +<span class="string">" "</span> + y + <span class="string">"步"</span>);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="解法二：坐标"><a href="#解法二：坐标" class="headerlink" title="解法二：坐标"></a>解法二：坐标</h3><p>将轨道视为一条坐标轴，探头视为原点，由车指向探头方向为正方向，则车的初始坐标为-1，当车的坐标&lt;127米时，车前进一次，坐标+97，当车的坐标&gt;=127时，车后退一次，坐标 -127，</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One_step_away</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		operation1(<span class="number">97</span>, <span class="number">127</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> x = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; ; i++) {</span><br><span class="line">			x += n;<span class="comment">//往前走一次</span></span><br><span class="line">			<span class="keyword">if</span>(x &gt;= m) {<span class="comment">//如果车的位置距离探头超过127米，就往后回一次</span></span><br><span class="line">				x -= m;</span><br><span class="line">				i++;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span>(x == <span class="number">0</span>) {</span><br><span class="line">				<span class="comment">//正好在探头下</span></span><br><span class="line">				System.out.println(i);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			}</span><br><span class="line">			</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="解法三：扩展欧几里德算法"><a href="#解法三：扩展欧几里德算法" class="headerlink" title="解法三：扩展欧几里德算法"></a>解法三：扩展欧几里德算法</h3><p>详情可查看<a href="https://blog.csdn.net/weixin_45333934/article/details/107976993" target="_blank" rel="noopener">扩展欧几里德算法</a></p>
<p>当我们算出 <code>97x+127y=gcd（97,127）</code>的第一组解<code>（x0，y0）</code>后；</p>
<p>我们可以得到 <code>97x+127y=1</code>的第一组解：</p>
<p><code>x=x0*1/gcd（97,127）；</code></p>
<p><code>y=y0*1/gcd（97,127）；</code></p>
<p>然后我们输出 abs（x）+ abs（y）即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One_step_away</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> byue = operation2(<span class="number">97</span>, <span class="number">127</span>);<span class="comment">//调用后x，y作为 97x+127y=gcd(97,127)的第一组解</span></span><br><span class="line">		System.out.println(byue);</span><br><span class="line">		System.out.println(Math.abs(x * <span class="number">1</span> / byue) + <span class="string">" "</span> + Math.abs(y * <span class="number">1</span> / byue));</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">operation2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> d;</span><br><span class="line">		<span class="keyword">if</span>(m == <span class="number">0</span>){</span><br><span class="line">			x = <span class="number">1</span>;</span><br><span class="line">			y = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> {</span><br><span class="line">			d = operation2(m, n % m);</span><br><span class="line">			<span class="keyword">int</span> temp = x;</span><br><span class="line">			x = y;</span><br><span class="line">			y = temp - (n / m) * y;</span><br><span class="line">			<span class="keyword">return</span> d;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🍁Sum-of-Fractions"><a href="#🍁Sum-of-Fractions" class="headerlink" title="🍁Sum_of_Fractions"></a>🍁Sum_of_Fractions</h2><p>如果求 1/2 + 1/3 + 1/4 + 1/5 + 1/6 + …. + 1/100 = ? 要求绝对精确，不能有误差。</p>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>常规思路，要求绝对精确，所以利用API</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum_of_Fractions</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		BigDecimal s = <span class="keyword">new</span> BigDecimal(<span class="number">0</span>);</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">			s = s.add(<span class="keyword">new</span> BigDecimal(<span class="number">1.0</span> / i));</span><br><span class="line">		}</span><br><span class="line">		System.out.println(s);</span><br><span class="line">		input.close();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🍁Nth-Prime"><a href="#🍁Nth-Prime" class="headerlink" title="🍁Nth_Prime"></a>🍁Nth_Prime</h2><p>第1个素数是2，第2个素数是3，…</p>
<p>求第100002（十万零二）个素数</p>
<h3 id="利用API"><a href="#利用API" class="headerlink" title="利用API"></a>利用API</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Nth_Prime</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">		n_prime(n);</span><br><span class="line">		input.close();</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 利用API</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">n_prime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">		BigInteger in = <span class="keyword">new</span> BigInteger(<span class="string">"2"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">			in = in.nextProbablePrime();</span><br><span class="line">		}</span><br><span class="line">		System.out.println(in);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="常规方法，编写一个判断素数的方法，并将素数储存"><a href="#常规方法，编写一个判断素数的方法，并将素数储存" class="headerlink" title="常规方法，编写一个判断素数的方法，并将素数储存"></a>常规方法，编写一个判断素数的方法，并将素数储存</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Nth_Prime</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">		n_prime1(n);</span><br><span class="line">		input.close();</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">n_prime1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">		List&lt;Long&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">2</span>; list.size() &lt; n; i++) {</span><br><span class="line">			<span class="keyword">if</span>(prime(i)) {</span><br><span class="line">				list.add(i);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		System.out.println(list.get(n - <span class="number">1</span>));</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">prime</span><span class="params">(<span class="keyword">long</span> n)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span>(n &lt; <span class="number">2</span>) {</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">2</span>) {</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= n;i += <span class="number">2</span>) {</span><br><span class="line">			<span class="keyword">if</span>(n % i == <span class="number">0</span>) {</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Nth_Prime</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">		n_prime2(n);</span><br><span class="line">		input.close();</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">n_prime2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">			arr[i] = <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) {<span class="comment">//可以只用根号n之前的数字去筛选</span></span><br><span class="line">			<span class="keyword">if</span>(arr[i] == <span class="number">1</span>) { <span class="comment">//不加判断也是可以的，增加复杂度了，我们只需要在我们所认为的“素数”中筛选就可以了， 每个合数必有质因子</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = i * i; j &lt;= n; j += i) { <span class="comment">//比如j = i * k(k &lt; i),那么j肯定被k筛掉了</span></span><br><span class="line">					arr[j] = <span class="number">0</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">			<span class="keyword">if</span>(arr[i] == <span class="number">1</span>) {</span><br><span class="line">				<span class="keyword">if</span>(k == <span class="number">100002</span>) {</span><br><span class="line">					System.out.println(<span class="string">"-&gt;"</span>+i);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				}</span><br><span class="line">				k++;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>中心拓展</tag>
        <tag>进制</tag>
        <tag>整除</tag>
        <tag>欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title>2020_java蓝桥_暑假训练_递归2</title>
    <url>/Blue_bridge_recursion_2/</url>
    <content><![CDATA[<h2 id="🌸递归训练"><a href="#🌸递归训练" class="headerlink" title="🌸递归训练"></a>🌸递归训练</h2><h2 id="Traffic-Route"><a href="#Traffic-Route" class="headerlink" title="Traffic_Route"></a>Traffic_Route</h2><p><strong>1、某城市经常在高峰时段发生交通拥堵，因此市政府决定采取管制措施：在高峰时段，车辆只能向东或北行驶。所有的街道都是东西走向或者南北走向，形成下图所示网络。</strong></p>
<p><a href="https://imgchr.com/i/aLV5kV" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/11/aLV5kV.png" alt="aLV5kV.png"></a></p>
<p><strong>假设我们我们已经知道了一辆车的初始位置和目标位置，那么有多少种可以到达目标位置的路径呢？起点位置为E 终点位置为F （选做利用递归解决）</strong></p>
<a id="more"></a>

<h3 id="🍁分析"><a href="#🍁分析" class="headerlink" title="🍁分析"></a>🍁分析</h3><p>普通的跳格子问题，直接递归，没啥好说的</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Traffic_Route</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> path = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> s_x = input.nextInt();</span><br><span class="line">		<span class="keyword">int</span> s_y = input.nextInt();</span><br><span class="line">		<span class="keyword">int</span> e_x = input.nextInt();</span><br><span class="line">		<span class="keyword">int</span> e_y = input.nextInt();</span><br><span class="line">		fun(s_x, s_y, e_x, e_y);</span><br><span class="line">		System.out.println(path);</span><br><span class="line">		input.close();</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> endX, <span class="keyword">int</span> endY)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span>(startX == endX &amp;&amp; startY == endY) {</span><br><span class="line">			path++;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(startX &gt; endX) {</span><br><span class="line">			fun(startX - <span class="number">1</span>, startY, endX, endY);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(startY &lt; endY) {</span><br><span class="line">			fun(startX, startY + <span class="number">1</span>, endX, endY);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸Building-Blocks"><a href="#🌸Building-Blocks" class="headerlink" title="🌸Building_Blocks"></a>🌸Building_Blocks</h2><p><strong>2、小明最近喜欢搭数字积木。一共有10块积木，每个积木上有一个数字，0~9。</strong></p>
<p><strong>搭积木规则：</strong></p>
<p><strong>每个积木放到其它两个积木的上面，并且一定比下面的两个积木数字小。</strong></p>
<p><strong>最后搭成4层的金字塔形，必须用完所有的积木。</strong></p>
<p><strong>下面是两种合格的搭法：</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">   0</span><br><span class="line">  1 2</span><br><span class="line"> 3 4 5</span><br><span class="line">6 7 8 9</span><br><span class="line">   0</span><br><span class="line">  3 1</span><br><span class="line"> 7 5 2</span><br><span class="line">9 8 6 4</span><br></pre></td></tr></tbody></table></figure>

<p><strong>请你计算这样的搭法一共有多少种？</strong></p>
<h3 id="🍁分析-1"><a href="#🍁分析-1" class="headerlink" title="🍁分析"></a>🍁分析</h3><ul>
<li>1.用递归求出0-9的全排列</li>
<li>2.对每个排列进行判断，满足条件+1</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Building_Blocks</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span>[] arr = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>};</span><br><span class="line">		dfs(arr, <span class="number">0</span>);</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span>(start == arr.length - <span class="number">1</span>) {</span><br><span class="line">			<span class="keyword">if</span>(judge(arr)) {</span><br><span class="line">				count++;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; arr.length; i++) {</span><br><span class="line">			swap(arr, start, i);</span><br><span class="line">			dfs(arr, start + <span class="number">1</span>);</span><br><span class="line">			swap(arr, start, i);</span><br><span class="line">		}</span><br><span class="line">	} </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">		arr[i] = arr[j];</span><br><span class="line">		arr[j] = temp;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span>((a[<span class="number">0</span>]&lt;a[<span class="number">1</span>]&amp;&amp;a[<span class="number">0</span>]&lt;a[<span class="number">2</span>]) &amp;&amp; (a[<span class="number">1</span>]&lt;a[<span class="number">3</span>]&amp;&amp;a[<span class="number">1</span>]&lt;a[<span class="number">4</span>]) &amp;&amp; (a[<span class="number">2</span>]&lt;a[<span class="number">4</span>]&amp;&amp;a[<span class="number">2</span>]&lt;a[<span class="number">5</span>]) &amp;&amp; (a[<span class="number">3</span>]&lt;a[<span class="number">6</span>]&amp;&amp;a[<span class="number">3</span>]&lt;a[<span class="number">7</span>]) &amp;&amp; (a[<span class="number">4</span>]&lt;a[<span class="number">7</span>]&amp;&amp;a[<span class="number">4</span>]&lt;a[<span class="number">8</span>]) &amp;&amp; (a[<span class="number">5</span>]&lt;a[<span class="number">8</span>]&amp;&amp;a[<span class="number">5</span>]&lt;a[<span class="number">9</span>])) {</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸Mission-Mix"><a href="#🌸Mission-Mix" class="headerlink" title="🌸Mission_Mix"></a>🌸Mission_Mix</h2><p><strong>3、X星球要派出一个5人组成的观察团前往W星。</strong></p>
<p><strong>其中：</strong></p>
<p><strong>A国最多可以派出4人。</strong></p>
<p><strong>B国最多可以派出2人。</strong></p>
<p><strong>C国最多可以派出2人。</strong></p>
<p><strong>D国最多可以派出1人。</strong></p>
<p><strong>E国最多可以派出1人。</strong></p>
<p><strong>F国最多可以派出3人。</strong></p>
<p><strong>那么最终派往W星的观察团会有多少种国别的不同组合呢？</strong></p>
<h3 id="🍁分析-2"><a href="#🍁分析-2" class="headerlink" title="🍁分析"></a>🍁分析</h3><p> 数组a是用来存储各个国家可以派遣的人数， 方法 <code>func(int[] a, int k, int n, String s)</code> 其中<code>int[] a</code>指代数组a，变量k 指代国家索引，变量n 指代当前已经选出的人数，变量str 指代 一个选出的用字符串表示的情况for循环，循环当前国家（a[k]）的情况，并用s2存下来，然后k+1递归进入下一个国家（索引值），n-i 表示还需要派遣的人数，s表示存储的当前情况。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mission_Mix</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span>[] a = {<span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>};</span><br><span class="line">		fun(a, <span class="number">0</span>, <span class="number">5</span>, <span class="string">""</span>);</span><br><span class="line">		System.out.println(sum);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> k, <span class="keyword">int</span> n, String str)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span>(k == a.length) {</span><br><span class="line">			<span class="keyword">if</span>(n == <span class="number">0</span>) {</span><br><span class="line">				System.out.println(str);</span><br><span class="line">				sum++;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(n &lt; <span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		String s = str;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= a[k]; i++) {</span><br><span class="line">			fun(a, k + <span class="number">1</span>, n - i, s);</span><br><span class="line">			s += (<span class="keyword">char</span>)(k + <span class="string">'A'</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸Poker-Suquence"><a href="#🌸Poker-Suquence" class="headerlink" title="🌸Poker_Suquence"></a>🌸Poker_Suquence</h2><p><strong>4、A A 2 2 3 3 4 4， 一共4对扑克牌。请你把它们排成一行。</strong></p>
<p><strong>要求：两个A中间有1张牌，两个2之间有2张牌，两个3之间有3张牌，两个4之间有4张牌。</strong></p>
<p><strong>请填写出所有符合要求的排列中，字典序最小的那个。</strong></p>
<p><strong>例如：22AA3344 比 A2A23344 字典序小。当然，它们都不是满足要求的答案。</strong></p>
<h3 id="🍁分析-3"><a href="#🍁分析-3" class="headerlink" title="🍁分析"></a>🍁分析</h3><p>这道题就这么看，确实懵了一阵，索性直接全排列，寻找满足条件的组合</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poker_Suquence</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Set&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		String str = <span class="string">"AA223344"</span>;</span><br><span class="line">		dfs(str.toCharArray(), <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(String s : set) {</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] data, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span>(k == data.length) {</span><br><span class="line">			judge(data);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; data.length; i++) {</span><br><span class="line">			swap(data, i, k);</span><br><span class="line">			dfs(data, k + <span class="number">1</span>);</span><br><span class="line">			swap(data, i, k);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span>[] a)</span> </span>{</span><br><span class="line">		String s = <span class="keyword">new</span> String(a);</span><br><span class="line">		<span class="keyword">if</span>(s.lastIndexOf(<span class="string">'A'</span>) - s.indexOf(<span class="string">'A'</span>) != <span class="number">2</span>) {</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(s.lastIndexOf(<span class="string">'2'</span>) - s.indexOf(<span class="string">'2'</span>) != <span class="number">3</span>) {</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(s.lastIndexOf(<span class="string">'3'</span>) - s.indexOf(<span class="string">'3'</span>) != <span class="number">4</span>) {</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(s.lastIndexOf(<span class="string">'4'</span>) - s.indexOf(<span class="string">'4'</span>) != <span class="number">5</span>) {</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		set.add(s);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">		<span class="keyword">char</span> temp = a[i];</span><br><span class="line">		a[i] = a[j];</span><br><span class="line">		a[j] = temp;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="🍁全排列第二种写法"><a href="#🍁全排列第二种写法" class="headerlink" title="🍁全排列第二种写法"></a>🍁全排列第二种写法</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poker_Suquence</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"-------------"</span>);</span><br><span class="line">		<span class="keyword">char</span>[] str2 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8</span>];</span><br><span class="line">		dfs2(str2, <span class="number">0</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span>(k &gt;= a.length) {</span><br><span class="line">			<span class="keyword">if</span>(judge2(a)) {</span><br><span class="line">				show(a);</span><br><span class="line">			}</span><br><span class="line">		}<span class="keyword">else</span> {</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) {</span><br><span class="line">				a[k] = (<span class="keyword">char</span>) (i + <span class="string">'0'</span>);</span><br><span class="line">				dfs2(a, k + <span class="number">1</span>);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">char</span>[] a)</span> </span>{</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) {</span><br><span class="line">			<span class="keyword">if</span>(a[i] == <span class="string">'1'</span>) {</span><br><span class="line">				System.out.print(<span class="string">'A'</span>);</span><br><span class="line">			}<span class="keyword">else</span> {</span><br><span class="line">				System.out.print(a[i]);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		System.out.println();</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judge2</span><span class="params">(<span class="keyword">char</span>[] a)</span> </span>{</span><br><span class="line">		<span class="keyword">boolean</span>[] bool = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">5</span>];</span><br><span class="line">		<span class="keyword">int</span> sizeA = <span class="number">0</span>, size2 = <span class="number">0</span>, size3 = <span class="number">0</span>, size4 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) {</span><br><span class="line">			<span class="keyword">if</span>(a[i] == <span class="string">'1'</span>) {</span><br><span class="line">				sizeA++;</span><br><span class="line">				<span class="keyword">if</span>(i + <span class="number">2</span> &lt; a.length &amp;&amp; a[i] == a[i + <span class="number">2</span>] || i - <span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; a[i - <span class="number">2</span>] == a[i]) {</span><br><span class="line">					bool[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(a[i] == <span class="string">'2'</span>) {</span><br><span class="line">				size2++;</span><br><span class="line">				<span class="keyword">if</span>(i + <span class="number">3</span> &lt; a.length &amp;&amp; a[i] == a[i + <span class="number">3</span>] || i - <span class="number">3</span> &gt; <span class="number">0</span> &amp;&amp; a[i - <span class="number">3</span>] == a[i]) {</span><br><span class="line">					bool[<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(a[i] == <span class="string">'3'</span>) {</span><br><span class="line">				size3++;</span><br><span class="line">				<span class="keyword">if</span>(i + <span class="number">4</span> &lt; a.length &amp;&amp; a[i] == a[i + <span class="number">4</span>] || i - <span class="number">4</span> &gt; <span class="number">0</span> &amp;&amp; a[i - <span class="number">4</span>] == a[i]) {</span><br><span class="line">					bool[<span class="number">2</span>] = <span class="keyword">true</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(a[i] == <span class="string">'4'</span>) {</span><br><span class="line">				size4++;</span><br><span class="line">				<span class="keyword">if</span>(i + <span class="number">5</span> &lt; a.length &amp;&amp; a[i] == a[i + <span class="number">5</span>] || i - <span class="number">5</span> &gt; <span class="number">0</span> &amp;&amp; a[i - <span class="number">5</span>] == a[i]) {</span><br><span class="line">					bool[<span class="number">3</span>] = <span class="keyword">true</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(sizeA == <span class="number">2</span> &amp;&amp; size3 == <span class="number">2</span> &amp;&amp; size4 == <span class="number">2</span> &amp;&amp; size2 == <span class="number">2</span>) {</span><br><span class="line">			bool[<span class="number">4</span>] = <span class="keyword">true</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> bool[<span class="number">0</span>] &amp;&amp; bool[<span class="number">1</span>] &amp;&amp; bool[<span class="number">2</span>] &amp;&amp; bool[<span class="number">3</span>] &amp;&amp; bool[<span class="number">4</span>];	</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="🍁全排列第三种写法"><a href="#🍁全排列第三种写法" class="headerlink" title="🍁全排列第三种写法"></a>🍁全排列第三种写法</h4><p>将A当做1</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poker_Suquence</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a[]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>};</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b[]=<span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">8</span>];</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		fun(<span class="number">0</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(b[i]==<span class="number">0</span>&amp;&amp;(i+a[n]+<span class="number">1</span>)&lt;<span class="number">8</span>&amp;&amp;b[i+a[n]+<span class="number">1</span>]==<span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                b[i]=b[i+a[n]+<span class="number">1</span>]=a[n];</span><br><span class="line">                <span class="keyword">if</span>(n==<span class="number">3</span>)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)</span><br><span class="line">                    {</span><br><span class="line">                    	<span class="keyword">if</span>(b[j] == <span class="number">1</span>) {</span><br><span class="line">                    		System.out.print(<span class="string">'A'</span>);</span><br><span class="line">                    	}<span class="keyword">else</span> {                  		</span><br><span class="line">                    		System.out.print(b[j]);</span><br><span class="line">                    	}</span><br><span class="line">                    }</span><br><span class="line">                    System.out.println();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> fun(n+<span class="number">1</span>);</span><br><span class="line">                b[i]=b[i+a[n]+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸Full-Of-Permutation"><a href="#🌸Full-Of-Permutation" class="headerlink" title="🌸Full_Of_Permutation"></a>🌸Full_Of_Permutation</h2><p><strong>5、已知不同字母构成的串，求它的全排列</strong></p>
<p>  <strong>例如“ABCD”的全排列？</strong></p>
<h3 id="🍁分析-4"><a href="#🍁分析-4" class="headerlink" title="🍁分析"></a>🍁分析</h3><p>直接进行全排列，也没什么好说的，分为字符串和字符数组的全排列</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Full_Of_Permutation</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		String str = <span class="string">"ABCD"</span>;</span><br><span class="line">		System.out.println(dfs(str).toString());</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//字符串</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">dfs</span><span class="params">(String str)</span></span>{</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">		<span class="comment">//出口</span></span><br><span class="line">		<span class="keyword">if</span>(str.length() == <span class="number">1</span>) {</span><br><span class="line">			list.add(str);</span><br><span class="line">			<span class="keyword">return</span> list;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">// 下面是递归的相似性</span></span><br><span class="line">		<span class="comment">/* Vector非常类似ArrayList，但是Vector是同步的。 */</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) {</span><br><span class="line">			<span class="keyword">char</span> cur = str.charAt(i);</span><br><span class="line">			 <span class="comment">//用来临时存储 递归之后的全排列</span></span><br><span class="line">			List&lt;String&gt; lis = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">			<span class="comment">//lis为递归s串中除去i之后的各个元素的全排列</span></span><br><span class="line">			lis = dfs(str.substring(<span class="number">0</span>, i) + str.substring(i + <span class="number">1</span>));</span><br><span class="line">			<span class="comment">//然后把i的加在lis的前边就行</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; lis.size(); k++) {</span><br><span class="line">				list.add(<span class="string">""</span> + cur + lis.get(k));</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Full_Of_Permutation</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		String str = <span class="string">"ABCD"</span>;</span><br><span class="line">		</span><br><span class="line">		dfs2(str.toCharArray(), <span class="number">0</span>);<span class="comment">//k从第0个开始</span></span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//数组</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> a 待排列数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> k 数组下表</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">		<span class="comment">//出口</span></span><br><span class="line">		<span class="keyword">if</span>(k == a.length - <span class="number">1</span>) {</span><br><span class="line">			<span class="comment">//把数组类型的aa强制转换成字符串类型,并输出</span></span><br><span class="line">			System.out.println(String.valueOf(a));</span><br><span class="line">			<span class="keyword">return</span>;<span class="comment">//K达到上线，不能继续递归，程序返回</span></span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//递归相似性</span></span><br><span class="line">		<span class="comment">//从第k个数开始，到数组中的最后一个数为止，依次进行交换（k从第一个数开始）</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; a.length; i++) {<span class="comment">//i=k,即不能漏掉不交换的情况</span></span><br><span class="line">			<span class="comment">//试探</span></span><br><span class="line">			swap(a, i, k);</span><br><span class="line">			<span class="comment">//调用K+1；递归后面的元素</span></span><br><span class="line">			dfs2(a, k + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//回溯，再交换回来</span></span><br><span class="line">			swap(a, i, k);</span><br><span class="line">			 <span class="comment">//做试探，递归之后立即回溯</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">		<span class="keyword">char</span> temp = a[i];</span><br><span class="line">		a[i] = a[j];</span><br><span class="line">		a[j] = temp;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸Repeated-Letter-Combinations"><a href="#🌸Repeated-Letter-Combinations" class="headerlink" title="🌸Repeated_Letter_Combinations"></a>🌸Repeated_Letter_Combinations</h2><p><strong>6、有重复的字母中求取出m个所有组合</strong></p>
<p>​    <strong>例如： “AAABBCCCCCCDD” 中取3个字母的所有组合</strong></p>
<h3 id="🍁分析-5"><a href="#🍁分析-5" class="headerlink" title="🍁分析"></a>🍁分析</h3><p>无疑是从中拿出三个字母进行全排列，详情见代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Repeated_Letter_Combinations</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span>[] data = {<span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>};<span class="comment">//四种元素分别所占个数</span></span><br><span class="line">		<span class="keyword">int</span>[] x = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];<span class="comment">//每种元素取多少个</span></span><br><span class="line">		dfs(data, x, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">		System.out.println(sum);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span>[] x, <span class="keyword">int</span> loc, <span class="keyword">int</span> goal)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span>(loc == <span class="number">4</span>) {</span><br><span class="line">			<span class="keyword">if</span>(goal == <span class="number">0</span>) {</span><br><span class="line">				sum++;</span><br><span class="line">				print(x);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//i 为第loc种元素所取得个数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (goal &lt; data[loc] ? goal : data[loc]); i++) {</span><br><span class="line">			x[loc] = i;</span><br><span class="line">			dfs(data, x, loc + <span class="number">1</span>, goal - i);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] x)</span> </span>{</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x[i]; j++) {</span><br><span class="line">				System.out.print((<span class="keyword">char</span>)(<span class="string">'A'</span> + i));</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		System.out.println();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h3><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>回溯</tag>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title>2020_java蓝桥_暑假训练_递归</title>
    <url>/Blue_bridge_recursion_1/</url>
    <content><![CDATA[<h2 id="🌸递归训练"><a href="#🌸递归训练" class="headerlink" title="🌸递归训练"></a>🌸递归训练</h2><h2 id="🌸The-39-Steps"><a href="#🌸The-39-Steps" class="headerlink" title="🌸The_39_Steps"></a>🌸The_39_Steps</h2><p>🍁<strong>1、小明刚刚看完电影《第39级台阶》。离开电影院的时候，他数了数礼堂前的台阶数，恰好是39级!</strong></p>
<p><strong>站在台阶前，他突然又想着一个问题：</strong></p>
<p><strong>如果我每一步只能迈上1个或2个台阶。先迈左脚，然后左右交替，最后一步是迈右脚，也就是说一共要走偶数步。那么，上完39级台阶，有多少种不同的上法呢？</strong></p>
<p><strong>请你利用计算机的优势，帮助小明寻找答案。</strong></p>
<a id="more"></a>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据题目要求，一次只能，迈出一步或者两步，第一脚是左脚，最后一脚是右脚，这意味着自己走的步数只能是偶数，递归思想思考题目，39级台阶的走法应该是从37级台阶或者38级台阶走上来的，即39级走法等于37级走法加上38级走法的总和，以此一直倒推，……..走到第三级台阶是从第第一级和第二级上来的，当台阶只剩下2级，<strong>无论你之前走了奇数步还是偶数步，都能有一种走法实现总和步数是偶数步</strong>，所以这里可以作为递归出口之一，直接<code>return 1;</code>，当台阶只剩下一步，由于总步数只能是偶数步，所以之前的步数只能是奇数步才能满足条件，return 1，偶数步则走法不符合题意。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">The_39_Steps</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">		System.out.println(steps(n, <span class="number">0</span>));</span><br><span class="line">		input.close();</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">steps</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> count)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">1</span>) {</span><br><span class="line">			<span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">2</span>) {</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> steps(n - <span class="number">1</span>, count + <span class="number">1</span>) + steps(n - <span class="number">2</span>, count + <span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸Motorcade-checkpoint"><a href="#🌸Motorcade-checkpoint" class="headerlink" title="🌸Motorcade_checkpoint"></a>🌸Motorcade_checkpoint</h2><p><strong>🍁2、X星球特别讲究秩序，所有道路都是单行线。</strong></p>
<p><strong>一个甲壳虫车队，共16辆车，按照编号先后发车，夹在其它车流中，缓缓前行。</strong></p>
<p><strong>路边有个死胡同，只能容一辆车通过，是临时的检查站，如图所示。</strong></p>
<p><a href="https://imgchr.com/i/aoLxxA" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/09/aoLxxA.png" alt="aoLxxA.png"></a></p>
<p><strong>X星球太死板，要求每辆路过的车必须进入检查站，也可能不检查就放行，也可能仔细检查。</strong></p>
<p><strong>如果车辆进入检查站和离开的次序可以任意交错。那么，该车队再次上路后，可能的次序有多少种？</strong> </p>
<p><strong>为了方便起见，假设检查站可容纳任意数量的汽车。</strong></p>
<p><strong>显然，如果车队只有1辆车，可能次序1种；2辆车可能次序2种；3辆车可能次序5种。</strong></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这道题看似十分绕。但是把检查站看成一个这题就变成了一个列表求出栈的次序数问题，每一种操作有两种情况，进站和出站，一辆车在检查站没有车的情况下只能选择进站，一辆车在检查站有车的情况下有</p>
<ul>
<li>进站，检查站车辆数目加一</li>
<li>不进站，检查站检查车辆，车辆出站，检查站车辆数目减一</li>
</ul>
<p>出站次序数即上面；两种情况之和</p>
<p>利用n 代表正在等候进站的车辆数目，m代表检查站车辆数目，当n 为0时递归可结束详情见代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Motorcade_checkpoint</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">		System.out.println(check(n, <span class="number">0</span>));</span><br><span class="line">		input.close();</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">0</span>) {<span class="comment">//如果左边没有车</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(m == <span class="number">0</span>) {<span class="comment">//如果检查站没有车</span></span><br><span class="line">			<span class="keyword">return</span> check(n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(m &gt; <span class="number">0</span>) {<span class="comment">//如果检查站有车取决于车辆是入还是出</span></span><br><span class="line">			<span class="keyword">return</span> check(n - <span class="number">1</span>, m + <span class="number">1</span>) + check(n, m - <span class="number">1</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁解法二：回溯（DFS）"><a href="#🍁解法二：回溯（DFS）" class="headerlink" title="🍁解法二：回溯（DFS）"></a>🍁解法二：回溯（DFS）</h3><p>求解排列问题一把想到的就是回溯剪枝。题中，只有站中有车，车辆才会被允许出站，假设1代表进站，0代表出站，r代表进站的个数，l代表出站的个数，即只有当进站的个数大于等于出站的个数才可以进站或者出站，否则只能进站。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Motorcade_checkpoint</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">		dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		System.out.println(num);</span><br><span class="line">		input.close();</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r, <span class="keyword">int</span> l)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">32</span>) {</span><br><span class="line">			num++;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(r &gt; l) {</span><br><span class="line">			<span class="keyword">if</span>(r &lt; <span class="number">16</span>) {</span><br><span class="line">				dfs(n + <span class="number">1</span>, r + <span class="number">1</span>, l);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span>(l &lt; <span class="number">16</span>) {</span><br><span class="line">				dfs(n + <span class="number">1</span>, r, l + <span class="number">1</span>);</span><br><span class="line">			}</span><br><span class="line">		}<span class="keyword">else</span> {</span><br><span class="line">			<span class="keyword">if</span>(r == l || r &lt; <span class="number">16</span>) {</span><br><span class="line">				dfs(n + <span class="number">1</span>, r + <span class="number">1</span>, l);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁解法三：数学推理"><a href="#🍁解法三：数学推理" class="headerlink" title="🍁解法三：数学推理"></a>🍁解法三：数学推理</h3><p>我们把n个元素的出栈个数的记为f(n), 那么对于1,2,3, 我们很容易得出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">f(1)= 1   //即 1</span><br><span class="line">	</span><br><span class="line">f(2)= 2   //即 12、21</span><br><span class="line">	</span><br><span class="line">f(3)= 5   //即 123、132、213、321、231</span><br></pre></td></tr></tbody></table></figure>


<p>然后我们来考虑f(4), 我们给4个元素编号为a,b,c,d, 那么考虑：元素a只可能出现在1号位置，2号位置，3号位置和4号位置(很容易理解，一共就4个位置，比如abcd,元素a就在1号位置)。</p>
<h4 id="🍁分析："><a href="#🍁分析：" class="headerlink" title="🍁分析："></a>🍁分析：</h4><p>​     1) 如果元素a在1号位置，那么只可能a进栈，马上出栈，此时还剩元素b、c、d等待操作，就是子问题f(3)；<br>​<br>​     2) 如果元素a在2号位置，那么一定有一个元素比a先出栈，即有f(1)种可能顺序（只能是b），还剩c、d，即f(2)，  根据乘法原理，一共的顺序个数为f(1)* f(2)；<br>​<br>​     3) 如果元素a在3号位置，那么一定有两个元素比1先出栈，即有f(2)种可能顺序（只能是b、c），还剩d，即f(1)，<br>​<br>​    根据乘法原理，一共的顺序个数为f(2) * f(1)；<br>​<br>​     4) 如果元素a在4号位置，那么一定是a先进栈，最后出栈，那么元素b、c、d的出栈顺序即是此小问题的解，即    f(3)；<br>​<br>​    结合所有情况，即f(4) = f(3) +f(2) * f(1) + f(1) * f(2) + f(3);<br>​<br>​    为了规整化，我们定义f(0) = 1；于是f(4)可以重新写为：<br>​<br>​    f(4) = f(0) * f(3) + f(1) * f(2) + f(2) * f(1)+ f(3) * f(0)<br>​<br>​    然后我们推广到n，推广思路和n=4时完全一样，于是我们可以得到：<br>​<br>​    f(n) = f(0) * f(n-1) + f(1) * f(n-2) + … +f(n-1) * f(0)</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Motorcade_checkpoint</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">		System.out.println(catalan(n));</span><br><span class="line">		input.close();</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">catalan</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span>[] cal = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">		cal[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		cal[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		cal[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">		cal[<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) {</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i - <span class="number">1</span>; j++) {</span><br><span class="line">				cal[i] += cal[j] * cal[i - <span class="number">1</span> - j];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> cal[n];</span><br><span class="line">	}	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁解法四：卡塔兰序列"><a href="#🍁解法四：卡塔兰序列" class="headerlink" title="🍁解法四：卡塔兰序列"></a>🍁解法四：卡塔兰序列</h3><p>根据解法三，最后的序列其实是卡塔兰序列，</p>
<p>令<code>h(0)=1,h(1)=1</code>，卡塔兰数满足递归式:<br><code>h(n)= h(0)*h(n-1) + h(1)*h(n-2) + .. + h(n-1)h(0)</code> <strong>(其中n&gt;=2)</strong>,这是n阶递推关系;<br>还可以化简为1阶递推关系:如<code>h(n)=(4n-2)/(n+1)*h(n-1)(n&gt;1) h(0)=1</code><br>该递推关系的解为:<br>$$<br>h(n)=\frac{C(2n,n)}{n+1}=\frac{P(2n,n)}{(n+1)!}=\frac{(2n!)}{(n!*(n+1)!)}(n=1,2,3,…)<br>$$</p>
<p>$$<br>C_n = \frac{(2n)!}{(n+1)!n!}<br>$$</p>
<p>$$<br>C_0=1,        C_{n+1} = \frac{2(2n+1)}{n+2}C_n<br>$$</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Motorcade_checkpoint</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">		System.out.println(catalan2(n));</span><br><span class="line">		input.close();</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">catalan2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span>[] cal = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">		cal[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		cal[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">			cal[i] = cal[i - <span class="number">1</span>]*(<span class="number">4</span>*i - <span class="number">2</span>) / (i + <span class="number">1</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> cal[n];</span><br><span class="line">	}	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸Equation"><a href="#🌸Equation" class="headerlink" title="🌸Equation"></a>🌸Equation</h2><p><strong>3、匪警请拨110,即使手机欠费也可拨通！</strong></p>
<p><strong>为了保障社会秩序，保护人民群众生命财产安全，警察叔叔需要与罪犯斗智斗勇，因而需要经常性地进行体力训练和智力训练！</strong></p>
<p><strong>某批警察叔叔正在进行智力训练：</strong></p>
<p><strong>1 2 3 4 5 6 7 8 9 = 110</strong></p>
<p><strong>请看上边的算式，为了使等式成立，需要在数字间填入加号或者减号（可以不填，但不能填入其它符号）。之间没有填入符号的数字组合成一个数，例如：12+34+56+7-8+9 就是一种合格的填法；123+4+5+67-89 是另一个可能的答案。</strong></p>
<p><strong>请你利用计算机的优势，帮助警察叔叔快速找到所有答案。</strong></p>
<p><strong>每个答案占一行。形如：</strong></p>
<p><strong>12+34+56+7-8+9</strong></p>
<p><strong>123+4+5+67-89</strong></p>
<p><strong>……</strong></p>
<h3 id="🍁分析"><a href="#🍁分析" class="headerlink" title="🍁分析"></a>🍁分析</h3><p>用暴力思路去分析很好理解，就是从1开始逐渐往后面添加符号’+’或’-‘，直到添加到9时将整个式子进行检查，查看是否是我们需要的式子，如果是，则输出。否则跳过进行下一层的递归递归其实就是利用递归的方式去实现暴力解法详情看代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Equation</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		String str = <span class="string">"123456789"</span>;</span><br><span class="line">		func(str, <span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(String v, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">		<span class="comment">//递归结束条件修改到最后一位时输出</span></span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">9</span>) {</span><br><span class="line">			check(v);</span><br><span class="line">		}<span class="keyword">else</span> { <span class="comment">// 递归向后修改，数字中间加上符号</span></span><br><span class="line">			func(v.replace(n + <span class="string">""</span>, n + <span class="string">"+"</span>), n + <span class="number">1</span>);</span><br><span class="line">			func(v.replace(n + <span class="string">""</span>, n + <span class="string">"-"</span>), n + <span class="number">1</span>);</span><br><span class="line">			func(v, n + <span class="number">1</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 验证字符串函数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(String str)</span> </span>{</span><br><span class="line">		String[] s = str.split(<span class="string">"[\\+]"</span>);</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(String t : s) {</span><br><span class="line">			String[] sub = t.split(<span class="string">"[\\-]"</span>);</span><br><span class="line">			<span class="keyword">int</span> num = Integer.parseInt(sub[<span class="number">0</span>]);</span><br><span class="line">			<span class="comment">//计算负数</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sub.length; i++) {</span><br><span class="line">				num -= Integer.parseInt(sub[i]);</span><br><span class="line">			}</span><br><span class="line">			sum += num; <span class="comment">// 正数或负数结果加到总和上去</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(sum == <span class="number">110</span>) {</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁解法二：直接遍历（暴力解法）"><a href="#🍁解法二：直接遍历（暴力解法）" class="headerlink" title="🍁解法二：直接遍历（暴力解法）"></a>🍁解法二：直接遍历（暴力解法）</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Equation</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		String str = <span class="string">"123456789"</span>;</span><br><span class="line">		fun(str);</span><br><span class="line">	}</span><br><span class="line">    <span class="comment">// 遍历所有情况</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(String s)</span> </span>{</span><br><span class="line">		<span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">		StringBuffer sb = <span class="keyword">new</span> StringBuffer();	<span class="comment">// 记录 组成的式子</span></span><br><span class="line">		<span class="keyword">int</span> len = s.length()-<span class="number">1</span>;	<span class="comment">// 字符串长度 - 1	</span></span><br><span class="line">		<span class="keyword">int</span>[] sign = <span class="keyword">new</span> <span class="keyword">int</span>[len];	<span class="comment">// sign用来标记符号, 最多有（s的长度-1）个符号</span></span><br><span class="line">		<span class="comment">// 从后身前添加符号</span></span><br><span class="line">		<span class="keyword">while</span>(sign[<span class="number">0</span>]&lt;<span class="number">3</span>){	<span class="comment">// 最前面的判定符号的值若 &gt;=3 则结束循环	</span></span><br><span class="line">			sb.append(c[<span class="number">0</span>]);	<span class="comment">// 添加首元素</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">				<span class="keyword">if</span>(sign[i]==<span class="number">1</span>){		<span class="comment">// 值为1添加"+"号</span></span><br><span class="line">					sb.append(<span class="string">"+"</span>);</span><br><span class="line">				}<span class="keyword">else</span> <span class="keyword">if</span>(sign[i]==<span class="number">2</span>){<span class="comment">// 值为2添加"-"号</span></span><br><span class="line">					sb.append(<span class="string">"-"</span>);</span><br><span class="line">				}</span><br><span class="line">				sb.append(c[i+<span class="number">1</span>]);	<span class="comment">// 不管添加不添加+-号，都添加后一个元素</span></span><br><span class="line">			}</span><br><span class="line">			</span><br><span class="line">			check2(sb.toString());	<span class="comment">// 验证并输出</span></span><br><span class="line">			</span><br><span class="line">			sb.setLength(<span class="number">0</span>);	<span class="comment">// 清空sb</span></span><br><span class="line">			sign[len-<span class="number">1</span>]++;	<span class="comment">// 每循环一次，最后一个符号值加1</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--){	<span class="comment">//当值等于3时，实现逢3进位</span></span><br><span class="line">				<span class="keyword">if</span>(sign[i]==<span class="number">3</span>){</span><br><span class="line">					sign[i] = <span class="number">0</span>;	<span class="comment">// sign[i] 归零</span></span><br><span class="line">					sign[i-<span class="number">1</span>]++;	<span class="comment">// sign[i-1]进位</span></span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 验证并输出</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check2</span><span class="params">(String str)</span></span>{</span><br><span class="line">		String[] s = str.split(<span class="string">"[\\+]|[-]"</span>);	<span class="comment">// 得到全部数字</span></span><br><span class="line">		String sign = str.replaceAll(<span class="string">"\\d*"</span>, <span class="string">""</span>);	<span class="comment">// 得到全部符号（+-）</span></span><br><span class="line">		<span class="keyword">int</span> sum = Integer.parseInt(s[<span class="number">0</span>]);	<span class="comment">// 把第一个数字给sum</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length-<span class="number">1</span>;i++){</span><br><span class="line">			<span class="keyword">switch</span>(sign.charAt(i)){</span><br><span class="line">				<span class="keyword">case</span> <span class="string">'+'</span>: </span><br><span class="line">					sum += Integer.parseInt(s[i+<span class="number">1</span>]);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">'-'</span>: </span><br><span class="line">					sum -= Integer.parseInt(s[i+<span class="number">1</span>]);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(sum==<span class="number">110</span>){	<span class="comment">// 符合条件输出</span></span><br><span class="line">			System.out.println(str);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸Bus-Fare"><a href="#🌸Bus-Fare" class="headerlink" title="🌸Bus_Fare"></a>🌸Bus_Fare</h2><p><strong>4、公园票价为5角。假设每位游客只持有两种币值的货币：5角、1元。</strong></p>
<p><strong>再假设持有5角的有m人，持有1元的有n人。</strong></p>
<p><strong>由于特殊情况，开始的时候，售票员没有零钱可找。</strong></p>
<p><strong>我们想知道这m+n名游客以什么样的顺序购票则可以顺利完成购票过程。</strong></p>
<p><strong>显然，m &lt; n的时候，无论如何都不能完成；</strong></p>
<p><strong>m&gt;=n的时候，有些情况也不行。比如，第一个购票的乘客就持有1元。</strong></p>
<p><strong>请计算出这m+n名游客所有可能顺利完成购票的不同情况的组合数目。</strong></p>
<p><strong>注意：只关心5角和1元交替出现的次序的不同排列，持有同样币值的两名游客交换位置并不算做一种新的情况来计数。</strong></p>
<h3 id="🍁分析-1"><a href="#🍁分析-1" class="headerlink" title="🍁分析"></a>🍁分析</h3><p>这道题就这么看，确实难找，m, n 难找，那么就去找<code>fun(m - 1, n)</code>和<code>fun(m, n - 1)</code>逐个去分析，分别去掉一个拿5毛的和一个拿一元的，然后再将这两种情况相加，最后如果m&lt;n，说明无解，返回0如果n==0，那一定只有一种情况，因为所有人都拿5毛了，如果拿5毛的比拿1块的还要多或者相等，那可以继续递归下去，这样将所有的情况相加，就可以得到所有的可能了，其实这是一个模拟人来等车的过程，假如一开始一个人都没有，那么，每过一个时刻，我们让一个人来排队，这个人可能拿5毛，可能拿一块，最后总共来了m+n个人，而所有的情况相加就可以得到答案，可以看出，递归实际上是从结果到开始状态，也就是倒着递推，来找到所有的情况的</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bus_Fare</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> m = input.nextInt();</span><br><span class="line">		<span class="keyword">int</span> n = input.nextInt();</span><br><span class="line">		System.out.println(fun(m, n));</span><br><span class="line">		input.close();</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span>(m &lt; n) {</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> fun(m - <span class="number">1</span>, n) + fun(m, n - <span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸Jump-Lattice"><a href="#🌸Jump-Lattice" class="headerlink" title="🌸Jump_Lattice"></a>🌸Jump_Lattice</h2><p><strong>5、小明参加了学校的趣味运动会，其中的一个项目是：跳格子。</strong></p>
<p><strong>地上画着一些格子，每个格子里写一个字，如下所示：（也可参见下图）</strong></p>
<p><a href="https://imgchr.com/i/aTB8NF" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/09/aTB8NF.png" alt="aTB8NF.png"></a></p>
<p><strong>比赛时，先站在左上角的写着“从”字的格子里，可以横向或纵向跳到相邻的格子里，但不能跳到对角的格子或其它位置。一直要跳到“华”字结束。</strong></p>
<p><strong>要求跳过的路线刚好构成“从我做起振兴中华”这句话。</strong></p>
<p><strong>请你帮助小明算一算他一共有多少种可能的跳跃路线呢？</strong></p>
<h3 id="🍁分析-2"><a href="#🍁分析-2" class="headerlink" title="🍁分析"></a>🍁分析</h3><p>模拟遍历二维矩阵，从左上角落（0,0）出发，只能向右或者向下（向左向上不满足题意）直到右下角（3, 4）结束。由于此题并未用到矩阵中的任何数据而且矩阵具有特殊性，从左上角到右下角无论向右还是向下的任何一条路径都满足题意，只是求路径的个数。所以此题并不需要借助矩阵，只需要写个遍历方式即可，当矩阵x点小于目标x,使点向右移动，当点y小于目标y值，将点向下移动，当（x, y）等于目标的（x, y）则路径加1</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jump_Lattice</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> path = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">		System.out.println(path);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> endX, <span class="keyword">int</span> endY)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span>(startX == endX &amp;&amp; startY == endY) {</span><br><span class="line">			path++;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(startX &lt; endX) {</span><br><span class="line">			dfs(startX + <span class="number">1</span>, startY, endX, endY);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(startY &lt; endY) {</span><br><span class="line">			dfs(startX, startY + <span class="number">1</span>, endX, endY);</span><br><span class="line">		}</span><br><span class="line">	}	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁解法二：动态规划"><a href="#🍁解法二：动态规划" class="headerlink" title="🍁解法二：动态规划"></a>🍁解法二：动态规划</h3><p>同递归思路倒推，点（3, 4）的路径数来自点（2, 4）和（3, 3）；（其中边缘路径只能来自一个地方，所以需要初始化边缘路径数为1即<code>dp[0] [j] = 1</code>和<code>dp[i] [0] = 1</code>）</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jump_Lattice</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="comment">//dp</span></span><br><span class="line">		<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">			dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) {</span><br><span class="line">			dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">5</span>; j++) {</span><br><span class="line">				dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		System.out.println(dp[<span class="number">3</span>][<span class="number">4</span>]);</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h3><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>动态规划</tag>
        <tag>递归</tag>
        <tag>回溯</tag>
        <tag>卡塔兰序列</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串(马拉车)_leetcode.647.回文子串</title>
    <url>/Palindrome_substring/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<a id="more"></a>

<p>示例 1：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入："abc"</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: "a", "b", "c"</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入："aaa"</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"</span><br></pre></td></tr></tbody></table></figure>


<p>提示：</p>
<p>输入的字符串长度不会超过 1000 。</p>
<h2 id="🍁分析"><a href="#🍁分析" class="headerlink" title="🍁分析"></a>🍁分析</h2><p>计算有多少个回文子串的最朴素方法就是枚举出所有的回文子串，而枚举出所有的回文字串又有两种思路，分别是：</p>
<ul>
<li>枚举出所有的子串，然后再判断这些子串是否是文;</li>
<li>枚举每一个可能的回文中心，然后两个指针分别向左右两边拓展，当两个<br>指针指向的元素相同的时候就拓展，则停止拓展。</li>
</ul>
<p>假设字符串的长度为n。我们可以看出前者会用O(n2 )的时间枚举出所有的子串<br>s[li..ri],然后再用<code>O(r;- li + 1)</code>的时间检测当前的子串是否是文,整个<br>算法的时间复杂度是O(n3)。后者枚举文中心的是0(n)的,对于每个文<br>中心拓展的次数也是0(n)的，所以时间复杂度是O(n2)。所以我们选择第二种<br>方法来枚举所有的回文子串。</p>
<h2 id="🍁解法一：暴力优化（动态规划）"><a href="#🍁解法一：暴力优化（动态规划）" class="headerlink" title="🍁解法一：暴力优化（动态规划）"></a>🍁解法一：暴力优化（动态规划）</h2><p>🍂 直接暴力枚举这里就不贴了，这里贴暴力的优化利用动态规划。但是也同样是中心扩散思想。</p>
<p>暴力法主要浪费在判断回文串上，不能有效利用同中心的回文串的状态，简单来说就是此时我们假设前面的子串s[j,i]是回文串，那么，子串s[j-1,i+1]也有可能是回文串，不难想出当且仅当子串s[j,i]是回文串且s[j-1]=s[i+1]时，子串s[j-1,i+1]也是回文串，于是我们可以通过数组保存子串是否是回文串，然后通过递推上一次的状态，得到下一次的状态，属于动态规划的解法，令<code>dp[i][j]</code> 表示字符串<code>s</code>在<code>[i,j]</code>区间的子串是否是一个回文串，状态转移如下：</p>
<p><code>当 s[i] == s[j] &amp;&amp; (j - i &lt; 2 || dp[i + 1] [j - 1])时，dp[i] [j]=true，否则为false</code></p>
<ul>
<li>当只有一个字符时，比如a自然是一个回文串。</li>
<li>当有两个字符时，如果是相等的，比如aa，也是一个回文串。</li>
<li>当有三个及以上字符时，比如ababa 这个字符记作串1,把两边的a去掉,<br>也就是bab记作串2，可以看出只要串2是一个回文串,那么左右各多了一<br>个a的串1必定也是文串。所以当s[i]==s[j] 时,自然要看dp[i+1] [j- 1]是不是一个回文串。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings2</span><span class="params">(String s)</span> </span>{</span><br><span class="line">	<span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length(); j++) {</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= j; i++) {</span><br><span class="line">			<span class="keyword">if</span>(s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; <span class="number">2</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) {</span><br><span class="line">				dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">				res++;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🍁解法二：-中心拓展法"><a href="#🍁解法二：-中心拓展法" class="headerlink" title="🍁解法二： 中心拓展法"></a>🍁解法二： 中心拓展法</h2><p>🍂 比如对一个字符串ababa ,选择最中间的a作为中心点往两边扩散,第- -次扩 散发现left指向的是b，right 指向的也是b，所以回文串，继续扩散,同理ababa也回文串。<br>这个是确定了一一个中心后的寻找的路径，然后我们只要寻找到所有的中心点，问题就解决了。</p>
<p>中心点-共有多少个呢?看起来像是和字符串长度相等，但你会发现,如果是这样，上面的例子永远也搜不到 abab ，想象一下单个字符的哪个中心点扩展可以得到这个子串?似乎不可能。所以中心点不能只有单个字符构成，还要包括两个字符，比如上面这个子串abab ，就可以有中心点ba扩展一次得到，所以最终的中心2 * 1en- 1个，分别是len个单字符和len - 1个双字符。</p>
<p>如果上面看不太懂的话，还可以看看下面几个问题:</p>
<ul>
<li>为什么有2* len- 1个中心点?<ul>
<li>aba 5个中心点，分别是a、b、a、ab、ba</li>
<li>abba有7个中心点，分别是a、b、b、a、ab、bb、ba</li>
</ul>
</li>
<li>什么是中心点?<ul>
<li>中心点即left指针和right指针初始化指向的地方，可能是一个也可能是两个</li>
</ul>
</li>
<li>为什么不可能是三个或者更多?<ul>
<li>因为3个可以由1个扩展一次得到，4个可以由两个扩展一次得到</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>{</span><br><span class="line">	<span class="comment">//中心扩展</span></span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> center = <span class="number">0</span>; center &lt; <span class="number">2</span> * s.length() - <span class="number">1</span>; center++) {</span><br><span class="line">		<span class="comment">// 首先是left，有一个很明显的2倍关系的存在，其次是right，可能和left指向同一个（偶数时），也可能往后移动一个（奇数）</span></span><br><span class="line">		<span class="keyword">int</span> left = center / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> right = left + center % <span class="number">2</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) {</span><br><span class="line">			res++;</span><br><span class="line">			left--;</span><br><span class="line">			right++;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个解法也同样适用于<code>leetcode 5 最长回文子串</code>，按上述代码，稍作修改，即可得到，第五题的解法:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        <span class="comment">// ababa 求最长公共子串</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len * <span class="number">2</span> - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">int</span> left = i / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> right = left + i % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; len &amp;&amp; s.charAt(left) == s.charAt(right)) {</span><br><span class="line">                String tmp = s.substring(left, right + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (tmp.length() &gt; result.length()) {</span><br><span class="line">                    result = tmp;</span><br><span class="line">                }</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🍁解法三：Manacher-算法"><a href="#🍁解法三：Manacher-算法" class="headerlink" title="🍁解法三：Manacher 算法"></a>🍁解法三：Manacher 算法</h2><p>🍂 Manacher算法是在线性时间内求解最长文子串的算法。在本题中，我们要求解<br>回文串的个数，为什么也能使用Manacher算法呢?这里我们就需要理解一下<br>Manacher的基本原理。</p>
<p>Manacher算法也会面临方法一」中的奇数长度和偶数长度的问题， 它的处理方<br>式是在所有的相邻字符中间插入#,比如abaa会被处理成#a#b#a#a#，<br>这样可以保证所有找到的回文串都是奇数长度的，以任意一个字符为文中心,<br>既可以包含原来的奇数长度的情况，也可以包含原来偶数长度的情况。假设原字<br>符串为s,经过这个处理之后的字符串为s。</p>
<p>我们用f(i)来示以s的第i位为回文中心，可以拓展出的最大回文半径,那么<br>f(i)- 1就是以i为中心的最大文串长度(想-想为什么)</p>
<p>Manacher算法依旧需要枚举s的每一个位置并先假设它回文中心,但是它会利用经计算出来的状态来更新f(i),而不向「中心拓展| -样盲目地拓展。具体地说，假设我们已经计算好了[1,i- 1]区间内所有点的f (即我们知道[1,i- 1]这些点作为文中心时候的最大半径)，那么我们也就知道了[1,i一1]拓展出的回文达到最大半径时的回文右端点。例如i = 4的时候f(i)= 5,说明以第4个元素为回文中心，最大能拓展到的回文半径是5,此时右端为4+5-1= 8。所以当我们知道一 个i对应的f(i)的时候,我们就可以很容易.得到它的右端点为<code>i+ f(i)- 1。</code></p>
<p>Manacher算法如何通过已经计算出的状态来更新f(i)呢? Manacher算法要求<br>我们维护「当前最大的回文的右端点$$r_m$$」以及这个回文右端点对应的回文中心<br>$$i_m$$.我们需要顺序遍历s,假设当前遍历的下标为i。<strong>我们知道在求解f(i)之前</strong><br><strong>我们应当已经得到了从[1,i- 1] 所有的f,并且当前已经有了一个最大回文右端</strong><br>点$$r_m$$以及它对应的回文中心$$i_m$$.</p>
<ul>
<li><p>初始化 f(i)</p>
<ul>
<li>如果i &lt; rm,说明i被包含在当前最大回文子串内，假设j是i关于<br>这个最大回文的回文中心im的对称位置(即j+i=2 x im) ,我们<br>可以得到f(i)至少等于<code>min{f(j),rm-i+1</code>}.这里将f(j)和<br>rm-i+ 1取小，先要保证这个文串在当前最大文串内。(思<br>考:为什么f(j)有可能大于rm-i+1? )</li>
<li>如果i &gt; rm,那就先初始化f(i)= 1。</li>
</ul>
</li>
<li><p>中心拓展</p>
<ul>
<li>做完初始化之后，我们可以保证此时的 s[i + f(i) - 1] = s[i - f(i) + 1]，要继续拓展这个区间，我们就要继续判断 s[i + f(i)] 和 s[i - f(i)] 是否相等，如果相等将 f(i)自增；这样循环直到 s[i + f(i)]不等于  s[i - f(i)]，以此类推。<strong>我们可以看出循环每次结束时都能保证</strong> <code>s[i + f(i) - 1] = s[i - f(i) + 1]</code>，<strong>而循环继续（即可拓展的条件）一定是</strong> <code>s[i + f(i)] = s[i - f(i)]</code>。 这个时候我们需要注意的是不能让下标越界，有一个很简单的办法，就是在开头加一个 $，并在结尾加一个 !!，这样开头和结尾的两个字符一定不相等，循环就可以在这里终止。</li>
</ul>
</li>
</ul>
<p>这样我们可以得到 s所有点为中心的最大回文半径，也就能够得到 S 中所有可能的回文中心的的最大回文半径，把它们累加就可以得到答案。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings3</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    StringBuffer t = <span class="keyword">new</span> StringBuffer(<span class="string">"$#"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        t.append(s.charAt(i));</span><br><span class="line">        t.append(<span class="string">'#'</span>);</span><br><span class="line">    }</span><br><span class="line">    n = t.length();</span><br><span class="line">    t.append(<span class="string">'!'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> iMax = <span class="number">0</span>, rMax = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) {</span><br><span class="line">        <span class="comment">// 初始化 f[i]</span></span><br><span class="line">        f[i] = i &lt;= rMax ? Math.min(rMax - i + <span class="number">1</span>, f[<span class="number">2</span> * iMax - i]) : <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 中心拓展</span></span><br><span class="line">        <span class="keyword">while</span> (t.charAt(i + f[i]) == t.charAt(i - f[i])) {</span><br><span class="line">            ++f[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 动态维护 iMax 和 rMax</span></span><br><span class="line">        <span class="keyword">if</span> (i + f[i] - <span class="number">1</span> &gt; rMax) {</span><br><span class="line">            iMax = i;</span><br><span class="line">            rMax = i + f[i] - <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 统计答案, 当前贡献为 (f[i] - 1) / 2 上取整</span></span><br><span class="line">        ans += f[i] / <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>动态规划</tag>
        <tag>Manacher(马拉车)</tag>
        <tag>中心拓展</tag>
      </tags>
  </entry>
  <entry>
    <title>写树算法的套路框架</title>
    <url>/Tree_algorithm/</url>
    <content><![CDATA[<h2 id="🌸套路"><a href="#🌸套路" class="headerlink" title="🌸套路"></a>🌸套路</h2><p>二叉树算法的设计的总路线：明确一个节点要做的事情，然后剩下的事抛给框架。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="comment">// root 需要做什么？在这做。</span></span><br><span class="line">    <span class="comment">// 其他的不用 root 操心，抛给框架</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>举两个简单的例子体会一下这个思路，热热身。</p>
<a id="more"></a>

<h3 id="🍁1-如何把二叉树所有的节点中的值加一？"><a href="#🍁1-如何把二叉树所有的节点中的值加一？" class="headerlink" title="🍁1. 如何把二叉树所有的节点中的值加一？"></a><strong>🍁1. 如何把二叉树所有的节点中的值加一？</strong></h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">plusOne</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span>;</span><br><span class="line">    root.val += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    plusOne(root.left);</span><br><span class="line">    plusOne(root.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁2-如何判断两棵二叉树是否完全相同？"><a href="#🍁2-如何判断两棵二叉树是否完全相同？" class="headerlink" title="🍁2. 如何判断两棵二叉树是否完全相同？"></a><strong>🍁2. 如何判断两棵二叉树是否完全相同？</strong></h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>{</span><br><span class="line">    <span class="comment">// 都为空的话，显然相同</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == null &amp;&amp; root2 == null) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 一个为空，一个非空，显然不同</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == null || root2 == null) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 两个都非空，但 val 不一样也不行</span></span><br><span class="line">    <span class="keyword">if</span> (root1.val != root2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// root1 和 root2 该比的都比完了</span></span><br><span class="line">    <span class="keyword">return</span> isSameTree(root1.left, root2.left)</span><br><span class="line">        &amp;&amp; isSameTree(root1.right, root2.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>借助框架，上面这两个例子不难理解吧？如果可以理解，那么所有二叉树算法你都能解决。</p>
<p>🍂二叉搜索树（Binary Search Tree，简称 BST）是一种很常用的的二叉树。它的定义是：一个二叉树中，任意节点的值要大于等于左子树所有节点的值，且要小于等于右边子树的所有节点的值。</p>
<p>如下就是一个符合定义的 BST：</p>
<p><a href="https://imgchr.com/i/ahCc4S" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/07/ahCc4S.png" alt="ahCc4S.png"></a></p>
<p>下面实现 BST 的基础操作：判断 BST 的合法性、增、删、查。其中“删”和“判断合法性”略微复杂。</p>
<h3 id="零、🍁判断-BST-的合法性"><a href="#零、🍁判断-BST-的合法性" class="headerlink" title="零、🍁判断 BST 的合法性"></a><strong>零、🍁判断 BST 的合法性</strong></h3><p>这里是有坑的哦，我们按照刚才的思路，每个节点自己要做的事不就是比较自己和左右孩子吗？看起来应该这样写代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left != null &amp;&amp; root.val &lt;= root.left.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.right != null &amp;&amp; root.val &gt;= root.right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left)</span><br><span class="line">        &amp;&amp; isValidBST(root.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个算法出现了错误，BST 的每个节点应该要小于右边子树的所有节点，下面这个二叉树显然不是 BST，但是我们的算法会把它判定为 BST。</p>
<p><a href="https://imgchr.com/i/ahPVKA" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/07/ahPVKA.png" alt="ahPVKA.png"></a></p>
<p>出现错误，不要慌张，框架没有错，一定是某个细节问题没注意到。我们重新看一下 BST 的定义，root 需要做的不只是和左右子节点比较，而是要整个左子树和右子树所有节点比较。怎么办，鞭长莫及啊！</p>
<p>这种情况，我们可以使用辅助函数，增加函数参数列表，在参数中携带额外信息，请看正确的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (max != <span class="keyword">null</span> &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left, min, root) </span><br><span class="line">        &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="一、🍁在-BST-中查找一个数是否存在"><a href="#一、🍁在-BST-中查找一个数是否存在" class="headerlink" title="一、🍁在 BST 中查找一个数是否存在"></a><strong>一、🍁在 BST 中查找一个数是否存在</strong></h3><p>根据我们的指导思想，可以这样写代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isInBST(root.left, target)</span><br><span class="line">        || isInBST(root.right, target);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样写完全正确，充分证明了你的框架性思维已经养成。现在你可以考虑一点细节问题了：如何充分利用信息，把 BST 这个“左小右大”的特性用上？</p>
<p>很简单，其实不需要递归地搜索两边，类似二分查找思想，根据 target 和 root.val 的大小比较，就能排除一边。我们把上面的思路稍稍改动：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val == target)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) </span><br><span class="line">        <span class="keyword">return</span> isInBST(root.right, target);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target)</span><br><span class="line">        <span class="keyword">return</span> isInBST(root.left, target);</span><br><span class="line">    <span class="comment">// root 该做的事做完了，顺带把框架也完成了，妙</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>于是，我们对原始框架进行改造，抽象出一套<strong>针对 BST 的遍历框架</strong>：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root.val == target)</span><br><span class="line">        <span class="comment">// 找到目标，做点什么</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) </span><br><span class="line">        BST(root.right, target);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target)</span><br><span class="line">        BST(root.left, target);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="二、🍁在-BST-中插入一个数"><a href="#二、🍁在-BST-中插入一个数" class="headerlink" title="二、🍁在 BST 中插入一个数"></a><strong>二、🍁在 BST 中插入一个数</strong></h3><p>对数据结构的操作无非遍历 + 访问，遍历就是“找”，访问就是“改”。具体到这个问题，插入一个数，就是先找到插入位置，然后进行插入操作。</p>
<p>上一个问题，我们总结了 BST 中的遍历框架，就是“找”的问题。直接套框架，加上“改”的操作即可。一旦涉及“改”，函数就要返回 TreeNode 类型，并且对递归调用的返回值进行接收。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">    <span class="comment">// 找到空位置插入新节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    <span class="comment">// if (root.val == val)</span></span><br><span class="line">    <span class="comment">//     BST 中一般不会插入已存在元素</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; val) </span><br><span class="line">        root.right = insertIntoBST(root.right, val);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; val) </span><br><span class="line">        root.left = insertIntoBST(root.left, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="三、🍁在-BST-中删除一个数"><a href="#三、🍁在-BST-中删除一个数" class="headerlink" title="三、🍁在 BST 中删除一个数"></a><strong>三、🍁在 BST 中删除一个数</strong></h3><p>这个问题稍微复杂，不过你有框架指导，难不住你。跟插入操作类似，先“找”再“改”，先把框架写出来再说：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root.val == key) {</span><br><span class="line">        <span class="comment">// 找到啦，进行删除</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) {</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) {</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>找到目标节点了，比方说是节点 A，如何删除这个节点，这是难点。因为删除节点的同时不能破坏 BST 的性质。有三种情况，用图片来说明。</p>
<p>情况 1：A 恰好是末端节点，两个子节点都为空，那么它可以当场去世了。</p>
<p><a href="https://imgchr.com/i/ahF87q" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/07/ahF87q.png" alt=""></a></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left == null &amp;&amp; root.right == null)</span><br><span class="line">    <span class="keyword">return</span> null;</span><br></pre></td></tr></tbody></table></figure>

<p>情况 2：A 只有一个非空子节点，那么它要让这个孩子接替自己的位置。</p>
<p><a href="https://imgchr.com/i/ahF1ns" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/07/ahF1ns.png" alt="ahF1ns.png"></a></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 排除了情况 1 之后</span></span><br><span class="line"><span class="keyword">if</span> (root.left == null) <span class="keyword">return</span> root.right;</span><br><span class="line"><span class="keyword">if</span> (root.right == null) <span class="keyword">return</span> root.left;</span><br></pre></td></tr></tbody></table></figure>

<p>情况 3：A 有两个子节点，麻烦了，为了不破坏 BST 的性质，A 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我们以第二种方式讲解。</p>
<p><a href="https://imgchr.com/i/ahF3Bn" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/07/ahF3Bn.png" alt="ahF3Bn.png"></a></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) {</span><br><span class="line">    <span class="comment">// 找到右子树的最小节点</span></span><br><span class="line">    TreeNode minNode = getMin(root.right);</span><br><span class="line">    <span class="comment">// 把 root 改成 minNode</span></span><br><span class="line">    root.val = minNode.val;</span><br><span class="line">    <span class="comment">// 转而去删除 minNode</span></span><br><span class="line">    root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>三种情况分析完毕，填入框架，简化一下代码</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span> null;</span><br><span class="line">    <span class="keyword">if</span> (root.val == key) {</span><br><span class="line">        <span class="comment">// 这两个 if 把情况 1 和 2 都正确处理了</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == null) <span class="keyword">return</span> root.right;</span><br><span class="line">        <span class="keyword">if</span> (root.right == null) <span class="keyword">return</span> root.left;</span><br><span class="line">        <span class="comment">// 处理情况 3</span></span><br><span class="line">        TreeNode minNode = getMin(root.right);</span><br><span class="line">        root.val = minNode.val;</span><br><span class="line">        root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) {</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) {</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode <span class="title">getMin</span><span class="params">(TreeNode node)</span> </span>{</span><br><span class="line">    <span class="comment">// BST 最左边的就是最小的</span></span><br><span class="line">    <span class="keyword">while</span> (node.left != null) node = node.left;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>删除操作就完成了。注意一下，这个删除操作并不完美，因为我们一般不会通过 root.val = minNode.val 修改节点内部的值来交换节点，而是通过一系列略微复杂的链表操作交换 root 和 minNode 两个节点。因为具体应用中，val 域可能会很大，修改起来很耗时，而链表操作无非改一改指针，而不会去碰内部数据。</p>
<p>但这里忽略这个细节，旨在突出 BST 基本操作的共性，以及借助框架逐层细化问题的思维方式。</p>
<h3 id="四、🍁最后总结"><a href="#四、🍁最后总结" class="headerlink" title="四、🍁最后总结"></a><strong>四、🍁最后总结</strong></h3><p>🍂通过这篇文章，你学会了如下几个技巧：</p>
<ul>
<li><p>二叉树算法设计的总路线：把当前节点要做的事做好，其他的交给递归框架，不用当前节点操心。</p>
</li>
<li><p>如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。</p>
</li>
<li><p>在二叉树框架之上，扩展出一套 BST 遍历框架：</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root.val == target)</span><br><span class="line">        <span class="comment">// 找到目标，做点什么</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) </span><br><span class="line">        BST(root.right, target);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target)</span><br><span class="line">        BST(root.left, target);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>DFS</tag>
        <tag>深度优先搜索</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑广度_leetcode.207_课程表</title>
    <url>/Class_Schedule_Card/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p>
<p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p>
 <a id="more"></a>

<p>示例 1:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br></pre></td></tr></tbody></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></tbody></table></figure>


<p>提示：</p>
<p>输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。<br>你可以假定输入的先决条件中没有重复的边。<br><code>1 &lt;= numCourses &lt;= 10^5</code></p>
<h2 id="🌸分析思路"><a href="#🌸分析思路" class="headerlink" title="🌸分析思路"></a>🌸分析思路</h2><ul>
<li><strong>本题可约化为</strong>:课程安排图是否是<strong>有向无环图(DAG)</strong>。即课程间规定了前置条件，但不能构成任何环路，则课程前置条件将不成立。</li>
<li>思路是通过拓扑排序判断此课程安排图是否是<strong>有向无环图(DAG)</strong>。拓扑排<br>序原理:对DAG的顶点进行排序，使得对每一条有向边(u,),均有u(在排序记录中)比u先出现。可理解为对某点v而言,只有当v的所有<br>源点均出现了，v才能出现。</li>
<li>通过课程前置条件列表<code>prerequiisites</code> 可以得到课程安排图的邻接表<br><code>adjacency</code>，以降低算法时间复杂度,以下两种方法都会用到邻接表。</li>
</ul>
<h2 id="🌸方法：拓扑入度表（BFS）"><a href="#🌸方法：拓扑入度表（BFS）" class="headerlink" title="🌸方法：拓扑入度表（BFS）"></a>🌸方法：拓扑入度表（BFS）</h2><h3 id="🍁算法流程"><a href="#🍁算法流程" class="headerlink" title="🍁算法流程:"></a>🍁算法流程:</h3><ol>
<li>统计课程安排图中每个节点的入度,成入度表<code>indegrees.</code></li>
<li>借助-一个队列<code>queue</code> ，将所有入度为0的节点入队。</li>
<li>当 <code>queue</code>非空时，依次将队首节点出队，在课程安排图中删除此节点pre :。<ul>
<li>并不是真正从邻接表中删除此节点pre, 而是将此节点对应所有邻接节点cur 的入度-1,即<code>indegrees[cur] -= 1。</code></li>
<li>当入度-1后邻接节点cur 的入度为0,说明cur 所有的前驱节点已经被“删除”，此时将cur 入队。</li>
</ul>
</li>
<li>在每次pre 出队时，执行<code>numCourses-i</code><ul>
<li>若整个课程安排图是有向无环图(即可以安排)，则所有节点-定都入队并出队过,即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为0。</li>
<li>因此，拓扑排序出队次数等于课程个数，返回<code>numCourses == 0</code>判断课程是否可以成功安排。</li>
</ul>
</li>
</ol>
<h3 id="🍁复杂度分析"><a href="#🍁复杂度分析" class="headerlink" title="🍁复杂度分析:"></a>🍁复杂度分析:</h3><ul>
<li>时间复杂度O(N + M):遍历-个图需要访问所有节点和所有临边，N和M分别为节数量和临边数量;</li>
<li>空间复杂度O(N + M):为建立邻接表所需额外空间， <code>adjacency</code> 长度为N，存储M条临边的数据。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span>[] indegrees = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];<span class="comment">//入度表</span></span><br><span class="line">	List&lt;List&lt;Integer&gt;&gt; adjacency = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//领接表</span></span><br><span class="line">	Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//验证环的队列</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) { <span class="comment">//初始化领接表</span></span><br><span class="line">		adjacency.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> [] cp : prerequisites) {</span><br><span class="line">		indegrees[cp[<span class="number">0</span>]]++; <span class="comment">//初始化入度表</span></span><br><span class="line">		adjacency.get(cp[<span class="number">1</span>]).add(cp[<span class="number">0</span>]);<span class="comment">//初始化领接表</span></span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//将入度为0的插入到队列中</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) {</span><br><span class="line">		<span class="keyword">if</span>(indegrees[i] == <span class="number">0</span>) {</span><br><span class="line">			queue.add(i);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//BFS TopSort</span></span><br><span class="line">	<span class="keyword">while</span>(!queue.isEmpty()) {</span><br><span class="line">		<span class="keyword">int</span> pre = queue.poll();</span><br><span class="line">		numCourses--;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> cur : adjacency.get(pre)) {</span><br><span class="line">			<span class="keyword">if</span>(--indegrees[cur] == <span class="number">0</span>) {</span><br><span class="line">				queue.add(cur);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>python</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        indegrees = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">        adjacency = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="comment"># Get the indegree and adjacency of every course.</span></span><br><span class="line">        <span class="keyword">for</span> cur, pre <span class="keyword">in</span> prerequisites:</span><br><span class="line">            indegrees[cur] += <span class="number">1</span></span><br><span class="line">            adjacency[pre].append(cur)</span><br><span class="line">        <span class="comment"># Get all the courses with the indegree of 0.</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(indegrees)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> indegrees[i]: queue.append(i)</span><br><span class="line">        <span class="comment"># BFS TopSort.</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            pre = queue.popleft()</span><br><span class="line">            numCourses -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> cur <span class="keyword">in</span> adjacency[pre]:</span><br><span class="line">                indegrees[cur] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> indegrees[cur]: queue.append(cur)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> numCourses</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸方法-：DFS"><a href="#🌸方法-：DFS" class="headerlink" title="🌸方法 ：DFS"></a>🌸方法 ：DFS</h2><h4 id="🍁思路"><a href="#🍁思路" class="headerlink" title="🍁思路"></a>🍁思路</h4><p>原理是通过 DFS 判断图中是否有环。</p>
<h4 id="🍁算法流程-1"><a href="#🍁算法流程-1" class="headerlink" title="🍁算法流程"></a>🍁算法流程</h4><ol>
<li>借助一个标志列表<code>flags</code>, 于判断每个节点i (课程) 的状态:<ol>
<li>未被DFS访问:<code>i==0;</code></li>
<li>已被其他节点启动的DFS访问: <code>i == -1</code> ;</li>
<li>已被当前节点启动的DFS访问: <code>i == 1</code>。</li>
</ol>
</li>
<li>对<code>numCourses</code> 个节点依次执行DFS,判断每个节点起步DFS否存在环，若存在环直接返回False。DFS流程;<ol>
<li>终止条件:<ul>
<li>当<code>flag[i] = -1</code>，说明当前访问节点已被其他节点启动的DFS访问，无需再重复搜索,直接返回True。</li>
<li>当<code>flag[i] == 1</code>，说明在本轮DFS搜索中节点i被第2次访问，即课程安排图有环，直接返回False.</li>
</ul>
</li>
<li>将当前访问节点i对应flag[i] 置1, 即标琪被本轮DFS访问过;</li>
<li>递归访问当前节点i的所有邻接节点j，当发现环直接返回False;</li>
<li>当前节点所有邻接节点已被遍历，并没有发现环，则将当前节点flag 为- 1并返回True。</li>
</ol>
</li>
<li>若整个图DFS结束并未发现环,返回True。</li>
</ol>
<h4 id="🍁复杂度分析-1"><a href="#🍁复杂度分析-1" class="headerlink" title="🍁复杂度分析:"></a>🍁复杂度分析:</h4><ul>
<li>时间复杂度O(N + M):遍历一个图需要访问所有节点和所有临边, N和M分别为节点数量和临边数量;</li>
<li>空间复杂度O(N + M):为建立邻接表所需额外空间， adjacency 长度为N, 存储M条临边的数据。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish2</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>{</span><br><span class="line">	List&lt;List&lt;Integer&gt;&gt; adjacency = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//领接表</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) { <span class="comment">//初始化领接表</span></span><br><span class="line">		adjacency.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span>[] flags = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> [] cp : prerequisites) {</span><br><span class="line">		adjacency.get(cp[<span class="number">1</span>]).add(cp[<span class="number">0</span>]);<span class="comment">//初始化领接表</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) {</span><br><span class="line">		<span class="keyword">if</span>(!dfs(adjacency, flags, i)) {</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; adjacency, <span class="keyword">int</span>[] flags, <span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="keyword">if</span>(flags[i] == <span class="number">1</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(flags[i] == -<span class="number">1</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	}</span><br><span class="line">	flags[i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(Integer j : adjacency.get(i)) {</span><br><span class="line">		<span class="keyword">if</span>(!dfs(adjacency, flags, j)) {</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	flags[i] = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, adjacency, flags)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> flags[i] == <span class="number">-1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> flags[i] == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            flags[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> adjacency[i]:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> dfs(j, adjacency, flags): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            flags[i] = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        adjacency = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">        flags = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">        <span class="keyword">for</span> cur, pre <span class="keyword">in</span> prerequisites:</span><br><span class="line">            adjacency[pre].append(cur)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dfs(i, adjacency, flags): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>

<p>该题解学习来自<a href="https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/" target="_blank" rel="noopener">@Krahets</a></p>
<p><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>python</tag>
        <tag>DFS</tag>
        <tag>深度优先搜索</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>索引数组_leetcode.315.计算右侧小于当前元素的个数</title>
    <url>/Count_the_number_of_elements/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p>
<a id="more"></a>

<p>示例:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: [5,2,6,1]</span><br><span class="line">输出: [2,1,1,0]</span><br></pre></td></tr></tbody></table></figure>

<p>解释:</p>
<ul>
<li>5 的右侧有 2 个更小的元素 (2 和 1).</li>
<li>2 的右侧仅有 1 个更小的元素 (1).</li>
<li>6 的右侧有 1 个更小的元素 (1).</li>
<li>1 的右侧有 0 个更小的元素.</li>
</ul>
<h2 id="🌸分析"><a href="#🌸分析" class="headerlink" title="🌸分析"></a>🌸分析</h2><blockquote>
<p>这道题要用排序的思路来解决。快速查找和更新，使用递归或树的结构可以高效实现。</p>
</blockquote>
<h2 id="🌸解法一：冒泡-暴力解法"><a href="#🌸解法一：冒泡-暴力解法" class="headerlink" title="🌸解法一：冒泡/暴力解法"></a>🌸解法一：冒泡/暴力解法</h2><p>暴力求解，不解释。</p>
<p>稳定的排序方法都可求解这个问题。<br>冒泡排序每交换一次消除一对逆序，使用一个索引数组记录消除的次数。<br>时间复杂度O(n2),超时。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">	List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">		<span class="keyword">int</span> flag = nums[i];</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) {</span><br><span class="line">			<span class="keyword">if</span>(flag &gt; nums[j]) {</span><br><span class="line">				count++;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(count != <span class="number">0</span>) {</span><br><span class="line">			res.add(count);</span><br><span class="line">		}<span class="keyword">else</span> {</span><br><span class="line">			res.add(<span class="number">0</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法二：-插入排序"><a href="#🌸解法二：-插入排序" class="headerlink" title="🌸解法二： 插入排序"></a>🌸解法二： 插入排序</h2><p>从右往左进行插入排序，<br>根据插入的位置计算右边小于该元素的个数。</p>
<p>优化：先使用二分法查找位置，再插入。可以降低内循环查找的时间复杂度O(nlogn)，但是元素交换的次数还是O(n2)。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//使用链表头插法</span></span><br><span class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="comment">//反向插入排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--){</span><br><span class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>, temp = nums[i];</span><br><span class="line">        <span class="keyword">while</span>(j &lt; len &amp;&amp; nums[j] &gt;= temp){</span><br><span class="line">            nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        nums[j - <span class="number">1</span>] = temp;</span><br><span class="line">        <span class="comment">//len - j就表示计数个数</span></span><br><span class="line">        res.addFirst(len - j);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//添加最后一个数</span></span><br><span class="line">    res.add(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//LinkedList也是List</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法三：-归并排序-索引数组"><a href="#🌸解法三：-归并排序-索引数组" class="headerlink" title="🌸解法三： 归并排序+索引数组"></a>🌸解法三： 归并排序+索引数组</h2><p>求解 “逆序对” 的关键在于：当其中一个数字放进最终归并以后的有序数组中的时候，这个数字与之前看过的数字个数（或者是未看过的数字个数）可以直接统计出来，而不必一个一个数”。</p>
<p>回到本题，本题让我们求 “在一个数组的某个元素的右边，比自己小的元素的个数”，因此，我们就 应该在 “前有序数组” 的元素出列的时候，数一数 “后有序数组” 已经出列了多少元素，因为这些已经出列的元素都比当前出列的元素要小（或者等于）。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>不过题目中要求我们要具体计算到元素级别。“归并排序” 完成以后，原始数组的位置就已经变化了，因此如何定位元素是关键。</p>
<p><strong>一个元素在算法的执行过程中位置发生变化，我们还想定位它</strong>，就是最小索引堆，使用 “索引数组” 的关键在于：</p>
<ul>
<li><strong>“原始数组” 不变，用于比较两个元素的大小，真正位置变换的是 “索引数组”</strong>。</li>
</ul>
<p>为了完成 “索引数组” 的归并，我们还需要一个 “索引数组” 长度的临时数组，把索引数组的值复制过去，比较完成以后，再赋值回 “索引数组”。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>如果 “前有序数组” 和 “后有序数组” 直接合并的时候，就有序，就不必归并</li>
<li>在 “归并” 的时候，全局使用一个临时存储数组，而不必每一个归并都新建临时的存储空间。</li>
<li>出列一个元素的时候，马上得到右边比自己小的元素的个数，是通过不同的指针之间的距离得到的。</li>
</ul>
<p><strong>java</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] temp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] counter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] indexes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }</span><br><span class="line">        temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        counter = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        indexes = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">            indexes[i] = i;</span><br><span class="line">        }</span><br><span class="line">        mergeAndCountSmaller(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">            res.add(counter[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对数组 nums 指定的区间 [l, r] 进行归并排序，在排序的过程中完成统计任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeAndCountSmaller</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (l == r) {</span><br><span class="line">            <span class="comment">// 数组只有一个元素的时候，没有比较，不统计</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        mergeAndCountSmaller(nums, l, mid);</span><br><span class="line">        mergeAndCountSmaller(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// 归并排序的优化，同样适用于该问题</span></span><br><span class="line">        <span class="comment">// 如果索引数组有序，就没有必要再继续计算了</span></span><br><span class="line">        <span class="keyword">if</span> (nums[indexes[mid]] &gt; nums[indexes[mid + <span class="number">1</span>]]) {</span><br><span class="line">            mergeOfTwoSortedArrAndCountSmaller(nums, l, mid, r);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * [l, mid] 是排好序的</span></span><br><span class="line"><span class="comment">     * [mid + 1, r] 是排好序的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeOfTwoSortedArrAndCountSmaller</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>{</span><br><span class="line">        <span class="comment">// 3,4  1,2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) {</span><br><span class="line">            temp[i] = indexes[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> i = l;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 左边出列的时候，计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k++) {</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) {</span><br><span class="line">                indexes[k] = temp[j];</span><br><span class="line">                j++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; r) {</span><br><span class="line">                indexes[k] = temp[i];</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 此时 j 用完了，[7,8,9 | 1,2,3]</span></span><br><span class="line">                <span class="comment">// 之前的数就和后面的区间长度构成逆序</span></span><br><span class="line">                counter[indexes[k]] += (r - mid);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (nums[temp[i]] &lt;= nums[temp[j]]) {</span><br><span class="line">                indexes[k] = temp[i];</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 此时 [4,5, 6   | 1,2,3 10 12 13]</span></span><br><span class="line">                <span class="comment">//           mid          j</span></span><br><span class="line">                counter[indexes[k]] += (j - mid - <span class="number">1</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// nums[indexes[i]] &gt; nums[indexes[j]] 构成逆序</span></span><br><span class="line">                indexes[k] = temp[j];</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>};</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        List&lt;Integer&gt; countSmaller = solution.countSmaller(nums);</span><br><span class="line">        System.out.println(countSmaller);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>python</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSmaller</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        size = len(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        temp = [<span class="literal">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)]</span><br><span class="line">        indexes = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(size)]</span><br><span class="line">        res = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)]</span><br><span class="line"></span><br><span class="line">        self.__helper(nums, <span class="number">0</span>, size - <span class="number">1</span>, temp, indexes, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__helper</span><span class="params">(self, nums, left, right, temp, indexes, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算一下左边</span></span><br><span class="line">        self.__helper(nums, left, mid, temp, indexes, res)</span><br><span class="line">        <span class="comment"># 计算一下右边</span></span><br><span class="line">        self.__helper(nums, mid + <span class="number">1</span>, right, temp, indexes, res)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[indexes[mid]] &lt;= nums[indexes[mid + <span class="number">1</span>]]:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.__sort_and_count_smaller(nums, left, mid, right, temp, indexes, res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__sort_and_count_smaller</span><span class="params">(self, nums, left, mid, right, temp, indexes, res)</span>:</span></span><br><span class="line">        <span class="comment"># [left,mid] 前有序数组</span></span><br><span class="line">        <span class="comment"># [mid+1,right] 后有序数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先拷贝，再合并</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(left, right + <span class="number">1</span>):</span><br><span class="line">            temp[i] = indexes[i]</span><br><span class="line"></span><br><span class="line">        l = left</span><br><span class="line">        r = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(left, right + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> l &gt; mid:</span><br><span class="line">                <span class="comment"># l 用完，就拼命使用 r</span></span><br><span class="line">                <span class="comment"># [1,2,3,4] [5,6,7,8]</span></span><br><span class="line">                indexes[i] = temp[r]</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> r &gt; right:</span><br><span class="line">                <span class="comment"># r 用完，就拼命使用 l</span></span><br><span class="line">                <span class="comment"># [6,7,8,9] [1,2,3,4]</span></span><br><span class="line">                indexes[i] = temp[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 注意：此时前面剩下的数，比后面所有的数都大</span></span><br><span class="line">                res[indexes[i]] += (right - mid)</span><br><span class="line">            <span class="keyword">elif</span> nums[temp[l]] &lt;= nums[temp[r]]:</span><br><span class="line">                <span class="comment"># [3,5,7,9] [4,6,8,10]</span></span><br><span class="line">                indexes[i] = temp[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 注意：</span></span><br><span class="line">                res[indexes[i]] += (r - mid - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">assert</span> nums[temp[l]] &gt; nums[temp[r]]</span><br><span class="line">                <span class="comment"># 上面两种情况只在其中一种统计就可以了</span></span><br><span class="line">                <span class="comment"># [3,5,7,9] [4,6,8,10]</span></span><br><span class="line">                indexes[i] = temp[r]</span><br><span class="line">                r += <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法四：-二叉搜索树"><a href="#🌸解法四：-二叉搜索树" class="headerlink" title="🌸解法四： 二叉搜索树"></a>🌸解法四： 二叉搜索树</h2><p>使用二叉搜索树也可以完成插入并统计的功能，从右往左构建二叉树。<br>递归实现：<br>当走到右节点时，</p>
<ul>
<li>统计根节点和左节点的个数，</li>
<li>继续插入并统计右边是否还有较小值；</li>
</ul>
<p>当走到左节点或者根节点时，</p>
<ul>
<li>计数器加一</li>
<li>继续插入并统计左边是否还有较小值。</li>
</ul>
<p>遍历一遍就可以完成搜索，时间复杂度O(nlogn)。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        Integer[] res = <span class="keyword">new</span> Integer[nums.length];</span><br><span class="line">        Arrays.fill(res, <span class="number">0</span>);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//反向构造二叉树，统计右边的较小数</span></span><br><span class="line">        TreeNode root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--){</span><br><span class="line">            root = addAndCount(root, <span class="keyword">new</span> TreeNode(nums[i]), res, i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(res);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">addAndCount</span><span class="params">(TreeNode root, TreeNode node, Integer[] res, <span class="keyword">int</span> i)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>){</span><br><span class="line">            root = node;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//根节点的左边保存不大于根节点的元素</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt;= node.val){ </span><br><span class="line">            <span class="comment">//统计左节点的元素个数</span></span><br><span class="line">            root.count++;</span><br><span class="line">            root.left = addAndCount(root.left, node, res, i);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">//走到右边获取该元素左边的个数（根节点 1 + 左节点 root.count）</span></span><br><span class="line">            res[i] += <span class="number">1</span> + root.count;</span><br><span class="line">            <span class="comment">//统计右边是否还有更小的元素</span></span><br><span class="line">            root.right = addAndCount(root.right, node, res, i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>{</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        left = <span class="keyword">null</span>;</span><br><span class="line">        right = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法五：-树状数组"><a href="#🌸解法五：-树状数组" class="headerlink" title="🌸解法五： 树状数组"></a>🌸解法五： 树状数组</h2><h3 id="🍁前言"><a href="#🍁前言" class="headerlink" title="🍁前言"></a>🍁前言</h3><ul>
<li>「树状数组」属于高级的数据结构，如果是非竞赛选手和普通公司面试，可以不用掌握</li>
<li><strong>「树状数组」这个数据结构用于高效地解决「前缀和查询」与「单点更新」问题</strong></li>
</ul>
<h3 id="🍁离散化"><a href="#🍁离散化" class="headerlink" title="🍁离散化"></a>🍁离散化</h3><p>首先对数组元素做预处理，这一步叫「离散化」。</p>
<ul>
<li>考虑到「树状数组」的底层是数组（线性结构），为了避免开辟多余的「树状数组」空间，需要进行「离散化」</li>
<li>「离散化」的作用是：针对数值的大小做一个排名的「映射」，把原始数据映射到 <code>[1, len]</code> 这个区间，这样「树状数组」底层的数组空间会更紧凑，更易于维护。</li>
</ul>
<h3 id="🍁分析"><a href="#🍁分析" class="headerlink" title="🍁分析"></a>🍁分析</h3><p>因为我们关心「<strong>当前位置的右边比当前数值小的元素的个数</strong>」，因此可以设计如下的算法流程：</p>
<ul>
<li>从右向左读取排名；</li>
<li>先查询<strong>严格小于</strong>当前排名的「前缀和」，这里「前缀和」指的是，严格小于当前排名的元素的个数，这一步对应「前缀和查询」；</li>
<li>然后给「当前排名」加 11，这一步对应「单点更新」。</li>
</ul>
<p>我们根据上面的步骤，针对 [5, 2, 6, 1] 得到排名 [3, 2, 4, 1] ，把具体的计算过程写一下：</p>
<blockquote>
<ul>
<li>第 1 步：读到 1 。<br>1 的排名是 1 ，首先先在「树状数组」的下标 1 位置更新，执行的操作是 +1，很明显，在排名 1 之前肯定没有数了（查询排名在 1 之前的数有多少个），所以在结果数组的最后一个位置填 0。</li>
<li>第 2 步：读到 6。<br>6 的排名是 4，首先先在「树状数组」的下标 4 位置更新，执行的操作是 +1，接下来在「树状树组」里面执行一次查询，查询在排名 4 之前的元素个数有多少，结果是 1，所以在结果数组的倒数第 2 个位置填 0；</li>
<li>第 3 步：读到 2。<br>2 的排名是 2，首先先在「树状数组」的下标 2 位置更新，执行的操作是 +1+1，接下来在「树状树组」里面执行一次查询，查询在排名 2 之前的元素个数有多少，结果是 1，所以在结果数组的倒数第 3 个位置填 11；</li>
<li>第 4 步：读到 5。<br>5 的排名是 3，首先先在「树状数组」的下标 3 位置更新，执行的操作是 +1+1，接下来在「树状树组」里面执行一次查询，查询在排名 3 之前的元素个数有多少，结果是 2，所以在结果数组的倒数第 4 个位置填 2。</li>
<li>于是 [2, 1, 1, 0] 即为所求。</li>
</ul>
</blockquote>
<p>🍁参考代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用二分搜索树方便排序</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排名表</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> rank = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer num : set) {</span><br><span class="line">            map.put(num, rank);</span><br><span class="line">            rank++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        FenwickTree fenwickTree = <span class="keyword">new</span> FenwickTree(set.size() + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 从后向前填表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="comment">// 1、查询排名</span></span><br><span class="line">            rank = map.get(nums[i]);</span><br><span class="line">            <span class="comment">// 2、在树状数组排名的那个位置 + 1</span></span><br><span class="line">            fenwickTree.update(rank, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 3、查询一下小于等于“当前排名 - 1”的元素有多少</span></span><br><span class="line">            res.add(fenwickTree.query(rank - <span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FenwickTree</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] tree;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FenwickTree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.len = n;</span><br><span class="line">            tree = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单点更新：将 index 这个位置 + 1</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>{</span><br><span class="line">            <span class="comment">// 从下到上，最多到 size，可以等于 size</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= <span class="keyword">this</span>.len) {</span><br><span class="line">                tree[i] += delta;</span><br><span class="line">                i += lowbit(i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 区间查询：查询小于等于 index 的元素个数</span></span><br><span class="line">        <span class="comment">// 查询的语义是"前缀和"</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">            <span class="comment">// 从右到左查询</span></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &gt; <span class="number">0</span>) {</span><br><span class="line">                sum += tree[i];</span><br><span class="line">                i -= lowbit(i);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>};</span><br><span class="line">        Solution4 solution4 = <span class="keyword">new</span> Solution4();</span><br><span class="line">        List&lt;Integer&gt; countSmaller = solution4.countSmaller(nums);</span><br><span class="line">        System.out.println(countSmaller);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>python</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSmaller</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">FenwickTree</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">                self.size = n</span><br><span class="line">                self.tree = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__lowbit</span><span class="params">(self, index)</span>:</span></span><br><span class="line">                <span class="keyword">return</span> index &amp; (-index)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 单点更新：将 index 这个位置 + 1</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, index, delta)</span>:</span></span><br><span class="line">                <span class="comment"># 从下到上，最多到 size，可以等于 size</span></span><br><span class="line">                <span class="keyword">while</span> index &lt;= self.size:</span><br><span class="line">                    self.tree[index] += delta</span><br><span class="line">                    index += self.__lowbit(index)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 区间查询：查询小于等于 index 的元素个数</span></span><br><span class="line">            <span class="comment"># 查询的语义是"前缀和"</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, index)</span>:</span></span><br><span class="line">                res = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 从上到下，最少到 1，可以等于 1</span></span><br><span class="line">                <span class="keyword">while</span> index &gt; <span class="number">0</span>:</span><br><span class="line">                    res += self.tree[index]</span><br><span class="line">                    index -= self.__lowbit(index)</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 特判</span></span><br><span class="line">        size = len(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 去重，方便离散化</span></span><br><span class="line">        s = list(set(nums))</span><br><span class="line"></span><br><span class="line">        s_len = len(s)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 离散化，借助堆</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heapq.heapify(s)</span><br><span class="line"></span><br><span class="line">        rank_map = dict()</span><br><span class="line">        rank = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(s_len):</span><br><span class="line">            num = heapq.heappop(s)</span><br><span class="line">            rank_map[num] = rank</span><br><span class="line">            rank += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        fenwick_tree = FenwickTree(s_len)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从后向前填表</span></span><br><span class="line">        res = [<span class="literal">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)]</span><br><span class="line">        <span class="comment"># 从后向前填表</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(size - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># 1、查询排名</span></span><br><span class="line">            rank = rank_map[nums[index]]</span><br><span class="line">            <span class="comment"># 2、在树状数组排名的那个位置 + 1</span></span><br><span class="line">            fenwick_tree.update(rank, <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 3、查询一下小于等于“当前排名 - 1”的元素有多少</span></span><br><span class="line">            res[index] = fenwick_tree.query(rank - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    nums = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>]</span><br><span class="line">    solution = Solution()</span><br><span class="line">    result = solution.countSmaller(nums)</span><br><span class="line">    print(result)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h3><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>python</tag>
        <tag>树状数组</tag>
        <tag>冒泡排序</tag>
        <tag>插入排序</tag>
        <tag>归并排序</tag>
        <tag>索引数组</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>算法_数据结构_树状数组基础简介</title>
    <url>/Tree_array/</url>
    <content><![CDATA[<h2 id="🌸树状数组简介"><a href="#🌸树状数组简介" class="headerlink" title="🌸树状数组简介"></a>🌸树状数组简介</h2><hr>
<blockquote>
<p>「树状数组」也叫 Binary Indexed Tree，二进制索引树，很好地表示了「树状数组」处理数据的思路：「树状数组」里某个元素管理了原始输入数组多少数据是由下标决定的。</p>
</blockquote>
<a id="more"></a>

<h2 id="前缀和数组🌸"><a href="#前缀和数组🌸" class="headerlink" title="前缀和数组🌸"></a>前缀和数组🌸</h2><ul>
<li><p>知道前缀和就可以求区间和，这是因为不同规模的区间和有重复的部分，相减以后就得到了区间和</p>
<p><img src="D:%5C%E6%A1%8C%E9%9D%A2%E6%96%87%E4%BB%B6%5C%E5%88%98%E7%AC%83%E5%AF%8C181106010%5Cself_study%5C%E5%8A%9B%E6%89%A3%5C%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%5C%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%5C1.png" alt="1"></p>
</li>
</ul>
<p>🍁如图所示：<strong>红色部分的和 = 绿色部分的和 - 黄色部分的和</strong>。</p>
<ul>
<li><p>可以定义：前缀和<code>preSum[i]</code> 表示 <code>nums[0, i]</code> 的和，则区间和 <code>sumRange[from, to]</code> = <code>preSum[to] - preSum[from - 1]</code>；</p>
</li>
<li><p>注意到 <code>preSum[from - 1]</code> 有下标越界的风险，通常的做法是：让前缀和数组多设置一位，为此修改定义：<code>preSum[i]</code>表示 <code>nums[0, i)</code> 的和，初始化的时候 <code>preSum[0] = 0</code>，则： <code>sumRange[from, to] = preSum[to + 1] - preSum[from]</code>。</p>
</li>
<li><p>预先计算出「前缀和」使得计算「区间和」的时间复杂度成为 O(1)。</p>
</li>
</ul>
<p>「前缀和」数组的思路是：将原始数组进行预处理，将来需要查询数据的时候，只需要查询预处理数组的某些值即可。</p>
<p>要优化「修改操作」造成的线性时间复杂度，预处理数据组织成线性结构肯定是不行的，因此一种方案是把预处理的数据组织成「树形结构」，有两种数据结构：</p>
<ul>
<li>线段树：高效处理「区间和」查询（不仅仅可以处理和、还可以处理区间最值等），单点修改；</li>
<li>树状数组：高效处理「前缀和」查询，单点修改。</li>
</ul>
<p>说明：</p>
<ul>
<li>事实上，「区间修改」也是支持的，但涉及的知识比较复杂，感兴趣的朋友可以自行查阅相关资料进行学习；</li>
<li>「线段树」能做的事情的范围大于「树状数组」能做的事情，「树状数组」做的事情更少、更专一，代码层面相对较简单。</li>
</ul>
<p>线段树」和「树状数组」一样，都是对原始输入数组进行了预处理，使得在真正需要查询数据的时候，我们只需要看「预处理数组」的部分信息即可，由于组织成树形结构，「修改」和「查询」的时间复杂度都是 O(\log N)O(logN)。</p>
<p>思想：空间换时间。<br>注意：「线段树」和「树状数组」不能处理输入数组的长度有增加或者减少的情况。</p>
<ul>
<li>线段树是一棵二叉树</li>
</ul>
<p>红色部分表示预处理数组，蓝色部分是原始输入数组，箭头表示当前值是哪些结点的值的和。</p>
<p><img src="D:%5C%E6%A1%8C%E9%9D%A2%E6%96%87%E4%BB%B6%5C%E5%88%98%E7%AC%83%E5%AF%8C181106010%5Cself_study%5C%E5%8A%9B%E6%89%A3%5C%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%5C%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%5C2.png" alt="2"></p>
<ul>
<li>树状数组是多叉树</li>
</ul>
<p>红色部分表示预处理数组，蓝色部分是原始输入数组，箭头表示当前值是哪些结点的值的和。</p>
<p><img src="D:%5C%E6%A1%8C%E9%9D%A2%E6%96%87%E4%BB%B6%5C%E5%88%98%E7%AC%83%E5%AF%8C181106010%5Cself_study%5C%E5%8A%9B%E6%89%A3%5C%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%5C%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%5C3.png" alt="3"></p>
<h2 id="🌸「树状数组」如何组织原始输入数据的结构"><a href="#🌸「树状数组」如何组织原始输入数据的结构" class="headerlink" title="🌸「树状数组」如何组织原始输入数据的结构"></a>🌸「树状数组」如何组织原始输入数据的结构</h2><p>注意：和「堆」一样，树状数组的 00 号下标不放置元素，从 11 号下标开始使用。从上图可以观察到，与数组 C 的某个结点有关的数组 A 的某些结点，它们的下标之间有如下关系。</p>
<table>
<thead>
<tr>
<th align="left"><strong>数组</strong> <code>C</code> <strong>的值由数组</strong> <code>A</code> <strong>的哪些元素而来</strong></th>
<th><strong>数组</strong> <code>A</code> <strong>的元素个数</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>C[1] = A[1]</code></td>
<td>1</td>
</tr>
<tr>
<td align="left"><code>C[2] = A[1] + A[2]</code></td>
<td>2</td>
</tr>
<tr>
<td align="left"><code>C[3] = A[3]</code></td>
<td>1</td>
</tr>
<tr>
<td align="left"><code>C[4] = A[1] + A[2] + A[3] + A[4]</code></td>
<td>4</td>
</tr>
<tr>
<td align="left"><code>C[5] = A[5]</code></td>
<td>1</td>
</tr>
<tr>
<td align="left"><code>C[6] = A[5] + A[6]</code></td>
<td>2</td>
</tr>
<tr>
<td align="left"><code>C[7] = A[7]</code></td>
<td>1</td>
</tr>
<tr>
<td align="left"><code>C[8] = A[1] + A[2] + A[3] + A[4] + A[5] + A[6] + A[7] + A[8]</code></td>
<td>8</td>
</tr>
</tbody></table>
<p>这件事情是由下标数值的二进制决定的，把下标写成二进制的形式，最低位的 11 以及后面的 00 表示了预处理数组 C 管理了多少输入数组 A 的元素。我们看一下下面的图：</p>
<p><img src="D:%5C%E6%A1%8C%E9%9D%A2%E6%96%87%E4%BB%B6%5C%E5%88%98%E7%AC%83%E5%AF%8C181106010%5Cself_study%5C%E5%8A%9B%E6%89%A3%5C%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%5C%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%5C4.png" alt=""></p>
<p>例如：66 的二进制表示为 01100110，这里只保留最低 4 位。将 66 进行二级制分解得到：</p>
<p>​                                                        6=1×2^2^+1×2^1^</p>
<p>最后的这部分 1 x  2^1^ 决定了 C[6] 管理了多少个输入数组 A 的数据，这里是 2 个，即从下标 6 开始（包括 6）向前数 2 个数，因此 <code>C[6] = A[5] +A[6]</code>，其它同理。</p>
<p>这就是开头所说的：「树状数组」里某个元素管理了原始输入数组多少数据是由下标决定的。</p>
<p>我们看到：</p>
<ul>
<li>「树状数组」组织成的树是有层级的，<strong>下标的二进制表示的最低位 1 后面的 0 的个数决定了，当前结点在第几层</strong>；</li>
<li>这样组织数据，从叶子结点到父结点是可以通过一个叫做 lowbit 的函数计算出来，并且可以知道小于等于当前下标的同一层结点的所有结点，为了说清楚这一点，需要有一定的篇幅。</li>
</ul>
<h2 id="🌸lowbit-函数"><a href="#🌸lowbit-函数" class="headerlink" title="🌸lowbit 函数"></a>🌸lowbit 函数</h2><p>这样命名的含义是截取一个正整数的二进制表示里的最低位的 11 和它后面的所有的 00。<code>lowbit</code> 的定义如下：</p>
<blockquote>
<p>lowbit(x) = x &amp; (-x);</p>
</blockquote>
<p>说明： </p>
<ul>
<li>这里 x 一定是正整数，即 x &gt;= 1；</li>
<li>这里 &amp; 表示按位与运算；</li>
<li>-x 也可以写成 (<del>x + 1) ，这里 ~ 表示「按位取反」。这是负数的定义，负数用补码表示，它的值等于这个负数的绝对值按位取反以后再加 11，因此 lowbit(x) = x &amp; (</del>x + 1);</li>
</ul>
<p>下面是一些关于负数和补码的知识，如果您比较熟悉的话，可以忽略</p>
<h2 id="🌸复习负数和补码的相关知识"><a href="#🌸复习负数和补码的相关知识" class="headerlink" title="🌸复习负数和补码的相关知识"></a>🌸复习负数和补码的相关知识</h2><ul>
<li>计算机底层存储整数使用 32 位；</li>
<li>最高位表示符号位：1 表示负数， 0 表示正数；</li>
<li>负数使用补码表示。</li>
</ul>
<p>补码按照如下规则定义：</p>
<ul>
<li>正数的补码是它自己；</li>
<li>负数的补码是它对应正整数按位取反以后再加 1。</li>
</ul>
<p>例如：计算 -5−5 的二进制表示：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th><strong>二进制表示</strong></th>
</tr>
</thead>
<tbody><tr>
<td>第 1 步：写出 5 的二进制表示；</td>
<td><code>00000000 00000000 00000000 00000101</code></td>
</tr>
<tr>
<td>第 2 步：将 5 的二进制表示按位取反；</td>
<td><code>11111111 11111111 11111111 11111010</code></td>
</tr>
<tr>
<td>第 3 步：在第 2 步的基础上再加 1。</td>
<td>1<code>1111111 11111111 11111111 11111011</code></td>
</tr>
</tbody></table>
<p>这样设计的好处是：<strong>符号位参与计算，并且保证了结果正确</strong>，我们再看一个例子。</p>
<p>例 2：计算 16 - 8</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th><strong>二进制表示</strong></th>
</tr>
</thead>
<tbody><tr>
<td>第 1 步：写出16 的二进制表示；</td>
<td><code>00000000 00000000 00000000 00010000</code></td>
</tr>
<tr>
<td>第 2 步：写出 -8 的二进制表示；</td>
<td><code>11111111 11111111 11111111 11111000</code></td>
</tr>
<tr>
<td>第 3 步：计算 16 - 8。</td>
<td><code>00000000 00000000 00000000 00001000</code></td>
</tr>
</tbody></table>
<p>计算 16 - 816−8，直接加，高位溢出，但不影响结果。</p>
<h2 id="🌸lowbit-运算解释："><a href="#🌸lowbit-运算解释：" class="headerlink" title="🌸lowbit 运算解释："></a>🌸lowbit 运算解释：</h2><ul>
<li>先按位取反正好让最低位的 1变成 0，最低位的 1 后面的 0 变成 1，最低位的 1 前面的 1 变成 0，0 变成 1；</li>
<li>再加 1 使得低位的 1 全变成 0，原来变成 0 的 1 由于进位又变回了 1；</li>
<li>再按位取余，正好就留下了一个 1。</li>
</ul>
<h2 id="🌸「单点更新」与「前缀和查询」"><a href="#🌸「单点更新」与「前缀和查询」" class="headerlink" title="🌸「单点更新」与「前缀和查询」"></a><strong>🌸「单点更新」与「前缀和查询」</strong></h2><h3 id="🍁单点更新"><a href="#🍁单点更新" class="headerlink" title="🍁单点更新"></a><strong>🍁单点更新</strong></h3><ul>
<li>「单点更新」从孩子结点到父亲结点，沿途所有的结点都需要更新；</li>
<li>从孩子结点到父亲结点，就是不断加上当前下标的 lowbit 值，产生进位。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单点更新</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i     原始数组索引 i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delta 变化值 = 更新以后的值 - 原始值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>{</span><br><span class="line">    <span class="comment">// 从下到上更新，注意，预处理数组，比原始数组的 len 大 1，故 预处理索引的最大值为 len</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= len) {</span><br><span class="line">        tree[i] += delta;</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="🍁前缀和查询"><a href="#🍁前缀和查询" class="headerlink" title="🍁前缀和查询"></a><strong>🍁前缀和查询</strong></h3><p>我们使用记号 preSum[7] 表示查询 A[1] + A[2] + … + A[7]。依然是考虑 7 的二进制 (0111)<del>2</del>分解：</p>
<p>​                                                               <strong>7=1×2^2^+1×2^1^+1×2^0^</strong></p>
<p>这三部分可以看成 (0100)<del>2</del>、(0010) <del>2</del> 、(0001)<del>2</del><br>  这 3 部分之和，分别表示 4 个元素 + 2 个元素 + 1 个元素，正好是 lowbit 值一直减，减到 0 为止，<strong>每减去一个 lowbit 值，消去一个 1</strong>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询前缀和</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 前缀的最大索引，即查询区间 [0, i] 的所有元素之和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">    <span class="comment">// 从右到左查询</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) {</span><br><span class="line">        sum += tree[i];</span><br><span class="line">        i -= lowbit(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🍁树状数组的初始化"><a href="#🍁树状数组的初始化" class="headerlink" title="🍁树状数组的初始化"></a>🍁树状数组的初始化</h2><p>这里要说明的是，初始化前缀和数组应该交给调用者来决定。下面是一种初始化的方式。树状数组的初始化可以通过「单点更新」来实现，因为最开始的时候，数组的每个元素的值都为 0，每个都对应地加上原始数组的值，就完成了预处理数组 C 的创建。</p>
<p>这里要特别注意，update 操作的第 2个参数是一个变化值，而不是变化以后的值。因为我们的操作是逐层向上汇报，汇报变更值会让我们的操作更加简单。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FenwickTree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.len = nums.length + <span class="number">1</span>;</span><br><span class="line">    tree = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.len + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) {</span><br><span class="line">        update(i, nums[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>🍁「树状数组」的完整代码</strong>：</p>
<p><strong>java</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FenwickTree</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预处理数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] tree;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FenwickTree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.len = n;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单点更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i     原始数组索引 i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 变化值 = 更新以后的值 - 原始值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>{</span><br><span class="line">        <span class="comment">// 从下到上更新，注意，预处理数组，比原始数组的 len 大 1，故 预处理索引的最大值为 len</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= len) {</span><br><span class="line">            tree[i] += delta;</span><br><span class="line">            i += lowbit(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询前缀和</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 前缀的最大索引，即查询区间 [0, i] 的所有元素之和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">        <span class="comment">// 从右到左查询</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) {</span><br><span class="line">            sum += tree[i];</span><br><span class="line">            i -= lowbit(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>python</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FenwickTree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.size = n</span><br><span class="line">        self.tree = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lowbit</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> index &amp; (-index)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单点更新：从下到上，最多到 size，可以取等</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, index, delta)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> index &lt;= self.size:</span><br><span class="line">            self.tree[index] += delta</span><br><span class="line">            index += self.__lowbit(index)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 区间查询：从上到下，最少到 1，可以取等</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &gt; <span class="number">0</span>:</span><br><span class="line">            res += self.tree[index]</span><br><span class="line">            index -= self.__lowbit(index)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>python</tag>
        <tag>树状数组</tag>
        <tag>前缀和数组</tag>
      </tags>
  </entry>
  <entry>
    <title>双栈_leetcode.678.有效地括号字符串</title>
    <url>/Valid_bracket_string/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p>
<ul>
<li>任何左括号 ( 必须有相应的右括号 )。</li>
<li>任何右括号 ) 必须有相应的左括号 ( 。</li>
<li>左括号 ( 必须在对应的右括号之前 )。</li>
<li>*可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。</li>
<li>一个空字符串也被视为有效字符串。</li>
</ul>
<a id="more"></a>

<p>示例:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: "()"</span><br><span class="line">输出: True</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: "(*)"</span><br><span class="line">输出: True</span><br><span class="line">示例 3:*</span><br><span class="line"></span><br><span class="line">*输入: "( *))"</span><br><span class="line">输出: True</span><br></pre></td></tr></tbody></table></figure>

<p>注意:<code>字符串大小将在 [1，100] 范围内。</code></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote>
<p>这道题是经典的括号型，第一想到的应该是双栈</p>
</blockquote>
<h2 id="🌸解法一：DFS"><a href="#🌸解法一：DFS" class="headerlink" title="🌸解法一：DFS"></a>🌸解法一：DFS</h2><ul>
<li>先编写无 * 情况的代码<ul>
<li>count 记录左括号个数</li>
<li>遇左则增，遇右则减</li>
<li>若不够减则 return false</li>
</ul>
</li>
<li>补充有 * 的情况<ul>
<li>分别开出三种可能继续探索</li>
<li>任何一种成了即可</li>
</ul>
</li>
<li>时间复杂度分析<ul>
<li>代码结构涉及循环，可能有递归，故可用最好、最好、加权平均时间- 复杂度表示</li>
<li>若不考虑中途提前结束（递归终止 或 左括号不足匹配右括号的终止）<ul>
<li>最好 O(n)，无星号的情况</li>
<li>最坏 O(3^n^),全是星号的情况</li>
</ul>
</li>
<li>若考虑中途提前结束<ul>
<li>最好 O(1)，右括号开头<br>最坏 O(3^n^),全星号的情况</li>
<li>求和各情况的 概率 * 此情况要遍历的元素个数</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValidString</span><span class="params">(String s)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span>(s.isEmpty()) {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> check(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> count)</span> </span>{</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="keyword">if</span>(count &lt; <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// count记录（ 的个数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; s.length(); i++) {</span><br><span class="line">		<span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">		<span class="keyword">if</span>(c == <span class="string">'('</span>) {</span><br><span class="line">			count++;</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">')'</span>) {</span><br><span class="line">			<span class="keyword">if</span>(count-- == <span class="number">0</span>) { <span class="comment">//若（ 为0，表示右括号多了，没有多余的左括号进行匹配</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			}</span><br><span class="line">		}<span class="keyword">else</span> {</span><br><span class="line">			<span class="keyword">return</span> check(s, i + <span class="number">1</span>, count + <span class="number">1</span>) || <span class="comment">//*作为(</span></span><br><span class="line">					check(s, i + <span class="number">1</span>, count - <span class="number">1</span>) || <span class="comment">//*作为)</span></span><br><span class="line">					check(s, i + <span class="number">1</span>, count);		<span class="comment">//*作为null</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法二：-贪心"><a href="#🌸解法二：-贪心" class="headerlink" title="🌸解法二： 贪心"></a>🌸解法二： 贪心</h2><ul>
<li>与方法一神似</li>
<li>无需每种情况都细分考虑，只需关注 左括号至少几个、至多几个</li>
<li>遇左则至多/至少都增加</li>
<li>遇右则至多/至少都减少<ul>
<li>若至多 <code>max</code> 都不够抵右括号，则 <code>return false</code></li>
</ul>
</li>
<li>遇 *则可能减少/不变/增多，即 <code>min--</code>; <code>max++</code>;<ul>
<li>若至少 <code>min</code> 小于 0 ，说明此分支走不通，需剪枝</li>
<li>类似方法一中的递归终止条件 <code>if (count &lt; 0) return false</code>;</li>
</ul>
</li>
<li>最终要求左括号必须无剩余 <code>min == 0;</code><ul>
<li><code>min &lt; 0</code> 的情况在上一条思路中剪枝了</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValidString2</span><span class="params">(String s)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> min = <span class="number">0</span>, max = <span class="number">0</span>; <span class="comment">// 维护左括号的数量范围[min,max]</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray()) {</span><br><span class="line">		<span class="keyword">if</span>(c == <span class="string">'('</span>) {</span><br><span class="line">			min++;</span><br><span class="line">			max++;</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">')'</span>){</span><br><span class="line">			<span class="keyword">if</span>(min &gt; <span class="number">0</span>) { <span class="comment">//至少值 的左括号 大于0，则至少值减一</span></span><br><span class="line">				min--;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span>(max-- == <span class="number">0</span>) { <span class="comment">//最大左括号数量不够匹配右括号</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			}</span><br><span class="line">		}<span class="keyword">else</span> {</span><br><span class="line">			<span class="keyword">if</span>(min &gt; <span class="number">0</span>) { <span class="comment">//*作为右括号进行抵消</span></span><br><span class="line">				min--;</span><br><span class="line">			}</span><br><span class="line">			max++;	<span class="comment">//*作为左括号，至大值加一</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> min == <span class="number">0</span>; <span class="comment">//只需要判断至少的左括号有多余不</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法三：-双向遍历"><a href="#🌸解法三：-双向遍历" class="headerlink" title="🌸解法三： 双向遍历"></a>🌸解法三： 双向遍历</h2><ul>
<li>极端假设替换为全左或全右，双向遍历验证</li>
<li>假设所有<code>*</code>为 <code>(</code><ul>
<li>因左括号必须在配对的左边，故从左向右遍历，看是否足够覆盖所有 <code>')'</code></li>
</ul>
</li>
<li>假设所有 <code>*</code>都为 <code>')'</code><ul>
<li>因右括号必须在配对的右边，故从右向左遍历，看是否足够覆盖所有 <code>'('</code></li>
</ul>
</li>
</ul>
<p><strong>java</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValidString3</span><span class="params">(String s)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line">		<span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">		<span class="keyword">if</span>(c != <span class="string">')'</span>) {</span><br><span class="line">			l++;</span><br><span class="line">		}<span class="keyword">else</span> {</span><br><span class="line">			<span class="keyword">if</span>(l-- == <span class="number">0</span>) { <span class="comment">//意味着右括号多了，没有多余的左括号进行匹配</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//进行提前特判，若能够匹配则退出</span></span><br><span class="line">	<span class="keyword">if</span>(l == <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//*全部作为右括号，从右往左进行遍历匹配</span></span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">		<span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">		<span class="keyword">if</span>(c != <span class="string">'('</span>) {</span><br><span class="line">			r++;</span><br><span class="line">		}<span class="keyword">else</span> {</span><br><span class="line">			<span class="keyword">if</span>(r-- == <span class="number">0</span>) { <span class="comment">//意味着左括号多了，无法完成匹配</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//此时左括号没有富余</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法四：-双栈"><a href="#🌸解法四：-双栈" class="headerlink" title="🌸解法四： 双栈"></a>🌸解法四： 双栈</h2><ul>
<li>括号匹配问题的经典解法</li>
<li>栈存放的是索引</li>
<li>一栈存左括号，一栈存星号</li>
<li>遍历过程中，同时判断是否有足够的右括号使他们出栈<ul>
<li>优先抵消左括号（贪心思想）</li>
</ul>
</li>
<li>两栈同时出栈并判断，要求所有左括号，都有 其右边索引的星号 能使其抵消</li>
<li>左括号不能还有富余</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValidString4</span><span class="params">(String s)</span> </span>{</span><br><span class="line">	<span class="comment">//定义双栈储存（、*的下标</span></span><br><span class="line">	Stack&lt;Integer&gt; left = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">	Stack&lt;Integer&gt; star = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line">		<span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">		<span class="keyword">if</span>(c == <span class="string">'('</span>) {</span><br><span class="line">			left.push(i);</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'*'</span>) {</span><br><span class="line">			star.push(i);</span><br><span class="line">		}<span class="keyword">else</span> {</span><br><span class="line">			<span class="keyword">if</span>(!left.isEmpty()) { <span class="comment">//优先出栈左括号</span></span><br><span class="line">				left.pop();</span><br><span class="line">			}<span class="keyword">else</span> <span class="keyword">if</span>(!star.isEmpty()) {</span><br><span class="line">				star.pop();</span><br><span class="line">			}<span class="keyword">else</span> {</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//若左栈和星栈扔不为空，则将双栈同时出栈，用*代替）匹配（</span></span><br><span class="line">	<span class="keyword">while</span>(!left.isEmpty() &amp;&amp; !star.isEmpty()) {</span><br><span class="line">		<span class="keyword">if</span>(left.pop() &gt; star.pop()) { <span class="comment">//若左栈的下标在星栈的右边，无法进行匹配</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> left.isEmpty();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>java</tag>
        <tag>DFS</tag>
        <tag>深度优先搜索</tag>
        <tag>双栈</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟_leetcode.415_字符串相加</title>
    <url>/String_addition/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p>
<p>注意：</p>
<ul>
<li>num1 和num2 的长度都小于 5100.</li>
<li>num1 和num2 都只包含数字 0-9.</li>
<li>num1 和num2 都不包含任何前导零。</li>
</ul>
<p>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。</p>
<a id="more"></a>

<h2 id="🌸方法：模拟横竖加减法"><a href="#🌸方法：模拟横竖加减法" class="headerlink" title="🌸方法：模拟横竖加减法"></a>🌸方法：模拟横竖加减法</h2><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><ul>
<li>利用双指针<code>i</code>, <code>j</code>分别指向<code>num1</code>和<code>num2</code> 的末尾，模拟人工加法</li>
<li>计算进位：计算<code>carry = temp // 2,</code> 代表当前位相加是否需要进位</li>
<li>添加当前位：计算<code>temp = n1 + n2 + carry</code>，并将当前位<code>temp % 10</code>添加到<code>res</code>的头部</li>
<li>索引溢出：当指针i，j走过数字首部，给<code>n1</code>，<code>n2</code>赋值为0,，相当于给<code>num1</code>，<code>num2</code>长度较短的数字前面填0，以便后续计算</li>
<li>当遍历完<code>num1,num2</code>后跳出循环，并根据carry值决定是否在头部添加进位1，最终返回res</li>
</ul>
<p><strong>复杂度</strong></p>
<ul>
<li>时间复杂度 O(max(M,N))：其中 M，N 为 2数字长度，按位遍历一遍数字（以较长的数字为准）；</li>
<li>空间复杂度 O(1)：指针与变量使用常数大小空间。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>{</span><br><span class="line">	StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">int</span> n1 = i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> n2 = j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> temp = n1 + n2 + carry;</span><br><span class="line">		carry = temp / <span class="number">10</span>;</span><br><span class="line">		res.append(temp % <span class="number">10</span>);</span><br><span class="line">		i--;</span><br><span class="line">		j--;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(carry == <span class="number">1</span>) {</span><br><span class="line">		res.append(<span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>python</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addString</span><span class="params">(self, num1: str, num2: str)</span> -&gt; str:</span></span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        i, j, carry =len(num1) - <span class="number">1</span>, len(num2) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            n1 = int(num1[i]) <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span> </span><br><span class="line">            n2 = int(num2[j]) <span class="keyword">if</span> j &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            temp = n1 + n2 + carry</span><br><span class="line">            carry = temp // <span class="number">10</span></span><br><span class="line">            res = str(temp % <span class="number">10</span>) + res</span><br><span class="line">            i, j = i - <span class="number">1</span>, j - <span class="number">1</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"1"</span> + res <span class="keyword">if</span> carry <span class="keyword">else</span> res</span><br></pre></td></tr></tbody></table></figure>

<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟_leetcode.415_字符串相乘</title>
    <url>/String_multiplication/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<a id="more"></a>

<p>示例 1:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: num1 = "2", num2 = "3"</span><br><span class="line">输出: "6"</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: num1 = "123", num2 = "456"</span><br><span class="line">输出: "56088"</span><br></pre></td></tr></tbody></table></figure>

<p>说明：</p>
<ul>
<li>num1 和 num2 的长度小于110。</li>
<li>num1 和 num2 只包含数字 0-9。</li>
<li>num1 和 num2 均不以零开头，除非是数字 0 本身。</li>
<li>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</li>
</ul>
<h2 id="🍁方法：模拟横竖乘法"><a href="#🍁方法：模拟横竖乘法" class="headerlink" title="🍁方法：模拟横竖乘法"></a>🍁方法：模拟横竖乘法</h2><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>竖式运算思想，以num1为123，    num2为456 为例分析:<br>    num2每一位与num1进行相乘,每一步的结果进行 累加。<br>    注意:</p>
<ul>
<li>num2除了第一位的其他位与</li>
<li>num1运算的结果需要 补0</li>
<li>计算字符串数字累加其实就是415.字符串相加</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 保存计算结果</span></span><br><span class="line">    String res = <span class="string">"0"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// num2 逐位与 num1 相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num2.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 保存 num2 第i位数字与 num1 相乘的结果</span></span><br><span class="line">        StringBuilder temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 补 0 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num2.length() - <span class="number">1</span> - i; j++) {</span><br><span class="line">            temp.append(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> n2 = num2.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// num2 的第 i 位数字 n2 与 num1 相乘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = num1.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span> || carry != <span class="number">0</span>; j--) {</span><br><span class="line">            <span class="keyword">int</span> n1 = j &lt; <span class="number">0</span> ? <span class="number">0</span> : num1.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> product = (n1 * n2 + carry) % <span class="number">10</span>;</span><br><span class="line">            temp.append(product);</span><br><span class="line">            carry = (n1 * n2 + carry) / <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 将当前结果与新计算的结果求和作为新的结果</span></span><br><span class="line">        res = addStrings(res, temp.reverse().toString());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对两个字符串数字进行相加，返回字符串形式的和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>{</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>;</span><br><span class="line">         i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry != <span class="number">0</span>;</span><br><span class="line">         i--, j--) {</span><br><span class="line">        <span class="keyword">int</span> x = i &lt; <span class="number">0</span> ? <span class="number">0</span> : num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> y = j &lt; <span class="number">0</span> ? <span class="number">0</span> : num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = (x + y + carry) % <span class="number">10</span>;</span><br><span class="line">        builder.append(sum);</span><br><span class="line">        carry = (x + y + carry) / <span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> builder.reverse().toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🍁竖式优化"><a href="#🍁竖式优化" class="headerlink" title="🍁竖式优化"></a>🍁竖式优化</h2><p>该算法是通过两数相乘时，乘数某位与被乘数某位相乘，与产生结果的位置的规<br>律来完成。具体规如下:</p>
<ul>
<li>乘数num1位数为M,被乘数num2位数为N,</li>
<li>num1 x num2结果</li>
<li>res大总位数为M+N</li>
<li>numl[i] x num2[j]的结果为tmp (位数为两位, “0x” ,”xy”的形式),第一位位于res[i+j] ，第二位位于res[i+j+1] 。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">multiply2</span><span class="params">(String num1, String num2)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num1.length() + num2.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num1.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">int</span> n1 = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = num2.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) {</span><br><span class="line">            <span class="keyword">int</span> n2 = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = (res[i + j + <span class="number">1</span>] + n1 * n2);</span><br><span class="line">            res[i + j + <span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">            res[i + j] += sum / <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; res[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        result.append(res[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>卡塔兰序列_leetcode.96.不同的二叉搜索树</title>
    <url>/Different_binary_search_trees/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p> 🍁给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<a id="more"></a>

<p>示例:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line"> 1         3     3      2      1</span><br><span class="line">  \       /     /      / \      \</span><br><span class="line">   3     2     1      1   3      2</span><br><span class="line">  /     /       \                 \</span><br><span class="line"> 2     1         2                 3</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸分析"><a href="#🌸分析" class="headerlink" title="🌸分析"></a>🌸分析</h2><blockquote>
<p>给定一个有序序列1..n,为了构建出一棵二叉搜索树，我们可以遍历每个数字<br>i,将该数字作为树根，所以如果求1..n的所有可能。</p>
<ul>
<li><p>我们只需要把1作为根节点, [] 空作为左子树, [2 .. n]的所有可能作为右<br>子树。</p>
</li>
<li><p>2作为根节点，[1] 作伪左子树, [3..n]的所有可能作为右子树。</p>
</li>
<li><p>3作为根节点，[1， 2 ]的所有可能作为左子树，[4 … n]的所有可能作为右子树，然后左子树和右子树两两组合。</p>
</li>
<li><p>4作为根节点[1 ，2，3]的所有可能作为佐子树，[5 .. n]的所有可能作为右子树,然后佐子树和右子树两两组合。</p>
</li>
<li><p>…….</p>
</li>
<li><p>n作为根节点，[ 1…. n]的所有可能作为左子树，[]作为右子树。</p>
</li>
</ul>
<p>由此可见，原问题可以分解成规模较小的两个子问题，子问题的解可以复用。<br>因此，我们可以想到使用递归、动态规划来求解本题。</p>
</blockquote>
<h2 id="🌸解法一：递归搜索"><a href="#🌸解法一：递归搜索" class="headerlink" title="🌸解法一：递归搜索"></a>🌸解法一：递归搜索</h2><blockquote>
<p>按照以上分析的思路，假设n个节点存在二叉排序树的个数是G(n),令f(i)为以i为根的二叉搜索树的个数,当找到其中一个数<code>i</code>的左子树可能的数量G(i - 1),右子树可能的数量是G(n - i),那么<code>f(i) = G(i - 1)  * G(n - i)</code></p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> dfs(n);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;	<span class="comment">//保存可能的个数</span></span><br><span class="line">	<span class="comment">//递归要素：终止条件</span></span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将[1..n]作为根节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">		<span class="comment">//拿到所有可能的左子树[]、[1..i)区间内个数</span></span><br><span class="line">		<span class="keyword">int</span> leftCount = dfs(i - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//拿到所有可能的右子树[]、(i...n]区间内个数</span></span><br><span class="line">		<span class="keyword">int</span> rightCount = dfs(n - i);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将个数进行排列组合</span></span><br><span class="line">		res += leftCount * rightCount;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法二：-记忆化递归搜索"><a href="#🌸解法二：-记忆化递归搜索" class="headerlink" title="🌸解法二： 记忆化递归搜索"></a>🌸解法二： 记忆化递归搜索</h2><blockquote>
<p>由于递归的分叉，所以会导致很多重复解的计算，所以使用 <code>memoization</code> 技术，把递归过程中求出的解保存起来，第二次需要的时候直接拿即可。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	Map&lt;Integer, Integer&gt; memory = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="keyword">return</span> dfs2(n, memory);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> n, Map&lt;Integer, Integer&gt; memory)</span> </span>{</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="comment">//如果已经被计算过的数，直接取出返回</span></span><br><span class="line">	<span class="keyword">if</span>(memory.containsKey(n)) {</span><br><span class="line">		<span class="keyword">return</span> memory.get(n);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;	<span class="comment">//保存可能的个数</span></span><br><span class="line">	<span class="comment">//递归要素：终止条件</span></span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将[1..n]作为根节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">		<span class="comment">//拿到所有可能的左子树[]、[1..i)区间内个数</span></span><br><span class="line">		<span class="keyword">int</span> leftCount = dfs2(i - <span class="number">1</span>, memory);</span><br><span class="line">		<span class="comment">//拿到所有可能的右子树[]、(i...n]区间内个数</span></span><br><span class="line">		<span class="keyword">int</span> rightCount = dfs2(n - i, memory);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将个数进行排列组合</span></span><br><span class="line">		res += leftCount * rightCount;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//记录保存的值</span></span><br><span class="line">	memory.put(<span class="keyword">null</span>, res);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法三：动态规划"><a href="#🌸解法三：动态规划" class="headerlink" title="🌸解法三：动态规划"></a>🌸解法三：动态规划</h2><blockquote>
<p>根据前面的解法一定义：</p>
<p><code>G(n)= f(1)+ f(2)+ f(3)+ f(4)+...+ f(n)</code></p>
<p><code>f(i)=G(i-1)*G(n-i)</code></p>
<p>G(n) 从f(1…n)得到，f(i) 递归依赖于G(n)，)<em>G</em>(<em>n</em>) 和序列的内容无关，只和序列的长度有关</p>
<p>到此，我们从小到大计算G函数即可,因为G(n)的值依赖于G(0)…G(n- 1)。</p>
</blockquote>
<p><strong>java</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}		</span><br><span class="line">	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将[1..n]作为根节点,已记录dp[1]=1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) {</span><br><span class="line">			<span class="comment">//记算左边j - 1个数可能的个数，右边i-j个数可能的个数</span></span><br><span class="line">			dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> dp[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法三：动态规划空间优化"><a href="#🌸解法三：动态规划空间优化" class="headerlink" title="🌸解法三：动态规划空间优化"></a>🌸解法三：动态规划空间优化</h2><p>源自<a href="https://leetcode.com/problems/unique-binary-search-trees/discuss/31815/A-0-ms-c%2B%2B-solution-with-my-explanation" target="_blank" rel="noopener"></a><a href="https://leetcode.com/heii0w0rid" target="_blank" rel="noopener">HeII0W0rId</a>，可移步</p>
<h2 id="🌸解法四：-卡塔兰公式"><a href="#🌸解法四：-卡塔兰公式" class="headerlink" title="🌸解法四： 卡塔兰公式"></a>🌸解法四： 卡塔兰公式</h2><blockquote>
<p>综合G(n)、f(i) 的 公式可以得到</p>
<p><code>G(n)= G(0)* G(n-1)+G(1)*(n-2)+...+ G(n-1)*G(0)</code></p>
<p>这就觉得这个公式挺眼熟的。</p>
<p>下面给出卡塔兰公式的定义</p>
<p>令<code>h(0)=1,h(1)=1</code>，卡塔兰数满足递归式:<br><code>h(n)= h(0)*h(n-1) + h(1)*h(n-2) + .. + h(n-1)h(0)</code> <strong>(其中n&gt;=2)</strong>,这是n阶递推关系;<br>还可以化简为1阶递推关系:如<code>h(n)=(4n-2)/(n+1)*h(n-1)(n&gt;1) h(0)=1</code><br>该递推关系的解为:<br>$$<br>h(n)=\frac{C(2n,n)}{n+1}=\frac{P(2n,n)}{(n+1)!}=\frac{(2n!)}{(n!*(n+1)!)}(n=1,2,3,…)<br>$$</p>
<p>$$<br>C_n = \frac{(2n)!}{(n+1)!n!}<br>$$</p>
<p>$$<br>C_0=1,        C_{n+1} = \frac{2(2n+1)}{n+2}C_n<br>$$</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees5</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> catalan = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">    	catalan = catalan * <span class="number">2</span> * (<span class="number">2</span> * i + <span class="number">1</span>) / (i + <span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) catalan;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>DFS</tag>
        <tag>动态规划</tag>
        <tag>卡塔兰公式</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯_leetcode.17.电话号码的字母组合</title>
    <url>/Alphabetic_combination_of_telephone_numbers/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<a id="more"></a>

<p>示例:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入："23"</span><br><span class="line">输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].</span><br></pre></td></tr></tbody></table></figure>

<p>说明:<br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
<h2 id="🌸分析"><a href="#🌸分析" class="headerlink" title="🌸分析"></a>🌸分析</h2><p>对于打印”2345”这样的字符串：<br>第一次递归就是上图中最下面的方格，然后处理完第一个字符2之后，将输入的字符改变成”345”并调用第二个递归函数<br>第二次递归处理3，将字符串改变成”45”后再次递归<br>第三次递归处理4，将字符串改变成”5”后继续递归<br>第四次递归处理5，将字符串改变成””后继续递归<br>最后发现字符串为空了，将结果放到列表中并返回<br>上面是从函数调用的角度去看的，而每次调用下一层递归时，都需要将本层的一些处理结果放到一个临时变量中，再传递给下一层，从这个变量层层传递的变化看，就像一棵树一样，这个算法的时间复杂度很高，是O(3^n)这个级别的，空间复杂度是O(n)</p>
<h2 id="🌸解法一：回溯"><a href="#🌸解法一：回溯" class="headerlink" title="🌸解法一：回溯"></a>🌸解法一：回溯</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">	<span class="comment">//一个映射表，第二个位置是"abc“,第三个位置是"def"。。。</span></span><br><span class="line">	<span class="comment">//这里也可以用map，用数组可以更节省点内存</span></span><br><span class="line">	String[] letter_map = {<span class="string">" "</span>,<span class="string">"*"</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>};</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>{</span><br><span class="line">		<span class="comment">//注意边界条件</span></span><br><span class="line">		<span class="keyword">if</span>(digits==<span class="keyword">null</span> || digits.length()==<span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		}</span><br><span class="line">		iterStr(digits, <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//最终输出结果的list</span></span><br><span class="line">	List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//递归函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">iterStr</span><span class="params">(String str, String letter, <span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">		<span class="comment">//递归的终止条件，注意这里的终止条件看上去跟动态演示图有些不同，主要是做了点优化</span></span><br><span class="line">		<span class="comment">//动态图中是每次截取字符串的一部分，"234"，变成"23"，再变成"3"，最后变成""，这样性能不佳</span></span><br><span class="line">		<span class="comment">//而用index记录每次遍历到字符串的位置，这样性能更好</span></span><br><span class="line">		<span class="keyword">if</span>(index == str.length()) {</span><br><span class="line">			res.add(letter);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//获取index位置的字符，假设输入的字符是"234"</span></span><br><span class="line">		<span class="comment">//第一次递归时index为0所以c=2，第二次index为1所以c=3，第三次c=4</span></span><br><span class="line">		<span class="comment">//subString每次都会生成新的字符串，而index则是取当前的一个字符，所以效率更高一点</span></span><br><span class="line">		<span class="keyword">char</span> c = str.charAt(index);</span><br><span class="line">		<span class="comment">//map_string的下表是从0开始一直到9， c-'0'就可以取到相对的数组下标位置</span></span><br><span class="line">		<span class="comment">//比如c=2时候，2-'0'，获取下标为2,letter_map[2]就是"abc"</span></span><br><span class="line">		<span class="keyword">int</span> pos = c - <span class="string">'0'</span>;</span><br><span class="line">		String map_string = letter_map[pos];</span><br><span class="line">		<span class="comment">//遍历字符串，比如第一次得到的是2，页就是遍历"abc"</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;map_string.length();i++) {</span><br><span class="line">			<span class="comment">//调用下一层递归，用文字很难描述，请配合动态图理解</span></span><br><span class="line">			iterStr(str, letter+map_string.charAt(i), index+<span class="number">1</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># python    </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">		<span class="string">"""</span></span><br><span class="line"><span class="string">		:type digits: str</span></span><br><span class="line"><span class="string">		:rtype: List[str]</span></span><br><span class="line"><span class="string">		"""</span></span><br><span class="line">		<span class="comment"># 注意边界条件</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">			<span class="keyword">return</span> []</span><br><span class="line">		<span class="comment"># 一个映射表，第二个位置是"abc“,第三个位置是"def"。。。</span></span><br><span class="line">		<span class="comment"># 这里也可以用map，用数组可以更节省点内存</span></span><br><span class="line">		d = [<span class="string">" "</span>,<span class="string">"*"</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>]</span><br><span class="line">		<span class="comment"># 最终输出结果的list</span></span><br><span class="line">		res = []</span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 递归函数</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(tmp,index)</span>:</span></span><br><span class="line">			<span class="comment"># 递归的终止条件，注意这里的终止条件看上去跟动态演示图有些不同，主要是做了点优化</span></span><br><span class="line">			<span class="comment"># 动态图中是每次截取字符串的一部分，"234"，变成"23"，再变成"3"，最后变成""，这样性能不佳</span></span><br><span class="line">			<span class="comment"># 而用index记录每次遍历到字符串的位置，这样性能更好</span></span><br><span class="line">			<span class="keyword">if</span> index==len(digits):</span><br><span class="line">				res.append(tmp)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="comment"># 获取index位置的字符，假设输入的字符是"234"</span></span><br><span class="line">			<span class="comment"># 第一次递归时index为0所以c=2，第二次index为1所以c=3，第三次c=4</span></span><br><span class="line">			<span class="comment"># subString每次都会生成新的字符串，而index则是取当前的一个字符，所以效率更高一点</span></span><br><span class="line">			c = digits[index]</span><br><span class="line">			<span class="comment"># map_string的下表是从0开始一直到9， ord(c)-48 是获取c的ASCII码然后-48,48是0的ASCII</span></span><br><span class="line">			<span class="comment"># 比如c=2时候，2-'0'，获取下标为2,letter_map[2]就是"abc"</span></span><br><span class="line">			letters = d[ord(c)<span class="number">-48</span>]</span><br><span class="line">			</span><br><span class="line">			<span class="comment"># 遍历字符串，比如第一次得到的是2，页就是遍历"abc"</span></span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> letters:</span><br><span class="line">				<span class="comment"># 调用下一层递归，用文字很难描述，请配合动态图理解</span></span><br><span class="line">				dfs(tmp+i,index+<span class="number">1</span>)</span><br><span class="line">		dfs(<span class="string">""</span>,<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>





<h2 id="🌸解法二：暴力法（队列）"><a href="#🌸解法二：暴力法（队列）" class="headerlink" title="🌸解法二：暴力法（队列）"></a>🌸解法二：暴力法（队列）</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span>(digits==<span class="keyword">null</span> || digits.length()==<span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//一个映射表，第二个位置是"abc“,第三个位置是"def"。。。</span></span><br><span class="line">		<span class="comment">//这里也可以用map，用数组可以更节省点内存</span></span><br><span class="line">		String[] letter_map = {</span><br><span class="line">			<span class="string">" "</span>,<span class="string">"*"</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span></span><br><span class="line">		};</span><br><span class="line">		List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="comment">//先往队列中加入一个空字符</span></span><br><span class="line">		res.add(<span class="string">""</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;digits.length();i++) {</span><br><span class="line">			<span class="comment">//由当前遍历到的字符，取字典表中查找对应的字符串</span></span><br><span class="line">			String letters = letter_map[digits.charAt(i)-<span class="string">'0'</span>];</span><br><span class="line">			<span class="keyword">int</span> size = res.size();</span><br><span class="line">			<span class="comment">//计算出队列长度后，将队列中的每个元素挨个拿出来</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++) {</span><br><span class="line">				<span class="comment">//每次都从队列中拿出第一个元素</span></span><br><span class="line">				String tmp = res.remove(<span class="number">0</span>);</span><br><span class="line">				<span class="comment">//然后跟"def"这样的字符串拼接，并再次放到队列中</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;letters.length();k++) {</span><br><span class="line">					res.add(tmp+letters.charAt(k));</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">		<span class="string">"""</span></span><br><span class="line"><span class="string">		:type digits: str</span></span><br><span class="line"><span class="string">		:rtype: List[str]</span></span><br><span class="line"><span class="string">		"""</span>	</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">			<span class="keyword">return</span> []</span><br><span class="line">		<span class="comment"># 一个映射表，第二个位置是"abc“,第三个位置是"def"。。。</span></span><br><span class="line">		<span class="comment"># 这里也可以用map，用数组可以更节省点内存</span></span><br><span class="line">		d = [<span class="string">" "</span>,<span class="string">"*"</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>]</span><br><span class="line">		<span class="comment"># 先往队列中加入一个空字符</span></span><br><span class="line">		res = [<span class="string">""</span>]</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> digits:</span><br><span class="line">			size = len(res)</span><br><span class="line">			<span class="comment"># 由当前遍历到的字符，取字典表中查找对应的字符串</span></span><br><span class="line">			letters = d[ord(i)<span class="number">-48</span>]</span><br><span class="line">			<span class="comment"># 计算出队列长度后，将队列中的每个元素挨个拿出来</span></span><br><span class="line">			<span class="keyword">for</span> _ <span class="keyword">in</span> xrange(size):</span><br><span class="line">				<span class="comment"># 每次都从队列中拿出第一个元素</span></span><br><span class="line">				tmp = res.pop(<span class="number">0</span>)</span><br><span class="line">				<span class="comment"># 然后跟"def"这样的字符串拼接，并再次放到队列中</span></span><br><span class="line">				<span class="keyword">for</span> j <span class="keyword">in</span> letters:</span><br><span class="line">					res.append(tmp+j)</span><br><span class="line">		<span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>递归</tag>
        <tag>回溯</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>滑窗_leetcode.713.乘积小于K的子数组</title>
    <url>/Subarray_with_product_less_than_k/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁Your are given an array of positive integers nums.</p>
<p>Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.</p>
<a id="more"></a>

<p>Example 1:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Input: nums = [10, 5, 2, 6], k = 100</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].</span><br><span class="line">Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.</span><br></pre></td></tr></tbody></table></figure>


<p>Note:</p>
<p><code>0 &lt; nums.length &lt;= 50000.</code><br><code>0 &lt; nums[i] &lt; 1000.</code><br><code>0 &lt;= k &lt; 10^6.</code></p>
<p>译：</p>
<p>给定一个正整数数组 nums。</p>
<p>找出该数组内乘积小于 k 的连续的子数组的个数。</p>
<p>示例 1:</p>
<p><code>输入: nums = [10,5,2,6], k = 100</code><br><code>输出: 8</code><br><code>解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。</code><br><code>需要注意的是 [10,5,2] 并不是乘积小于100的子数组。</code><br>说明:</p>
<p><code>0 &lt; nums.length &lt;= 50000</code><br><code>0 &lt; nums[i] &lt; 1000</code><br><code>0 &lt;= k &lt; 10^6</code></p>
<h2 id="🌸解法一：二分查找"><a href="#🌸解法一：二分查找" class="headerlink" title="🌸解法一：二分查找"></a>🌸解法一：二分查找</h2><h3 id="🍁分析"><a href="#🍁分析" class="headerlink" title="🍁分析"></a>🍁分析</h3><p>我们可以使用二分查找解决这道题目，即对于固定的 i，二分查找出最大的 j 满足 nums[i] 到 nums[j] 的乘积小于 k。但由于乘积可能会非常大（在最坏情况下会达到 $$1000^{50000}$$ ），会导致数值溢出，因此我们需要对nums 数组取对数，将乘法转换为加法，即$$log(∏<em>inums[i]) = \sum</em>{i}lognums[i]$$ 这样就不会出现数值溢出的问题了。</p>
<h3 id="🍁算法"><a href="#🍁算法" class="headerlink" title="🍁算法"></a>🍁算法</h3><p>对 nums 中的每个数取对数后，我们存储它的前缀和prefix，即$$prefix[i + 1] = \sum_{x=0}^inums[x]$$，这样在二分查找时，对于 i和 j，我们可以用 prefix[j + 1] - prefix[i] 得到 nums[i] 到 nums[j] 的乘积的对数。对于固定的 i，当找到最大的满足条件的 j后，它会包含 j−i+1 个乘积小于 k 的连续子数组。</p>
<p>下面的代码和算法中下标的定义略有不同。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">double</span> logk = Math.log(k);</span><br><span class="line">	<span class="keyword">double</span>[] prefix = <span class="keyword">new</span> <span class="keyword">double</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">		prefix[i + <span class="number">1</span>] = prefix[i] + Math.log(nums[i]);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length; i++) {</span><br><span class="line">		<span class="keyword">int</span> lo = i + <span class="number">1</span>, hi = prefix.length;</span><br><span class="line">		<span class="keyword">while</span> (lo &lt; hi) {</span><br><span class="line">			<span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (prefix[mi] &lt; prefix[i] + logk - <span class="number">1e-9</span>)</span><br><span class="line">				lo = mi + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				hi = mi;</span><br><span class="line">		}</span><br><span class="line">		ans += lo - i - <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法二：-Sliding-Window-滑动窗口"><a href="#🌸解法二：-Sliding-Window-滑动窗口" class="headerlink" title="🌸解法二： Sliding Window 滑动窗口"></a>🌸解法二： Sliding Window 滑动窗口</h2><h3 id="🍁分析-1"><a href="#🍁分析-1" class="headerlink" title="🍁分析"></a>🍁分析</h3><p>对应每个right, 找到满足从(left,right)之间乘积小于k的最小的left。比如(2,6) 也满足，(3,6) 也满足,我们要找的left是2。不过其实这句话不说也行还容易让人误解，因为我们的判断是让right逐渐向右走，当(left, right) 之间的乘积小于k我们就不找了，因此肯定就是最小的left。</p>
<h3 id="🍁核心思想"><a href="#🍁核心思想" class="headerlink" title="🍁核心思想:"></a>🍁核心思想:</h3><p>始终保证当前窗口中乘积小于k。当前窗口下的乘积小于k等价于当前窗口下子数组的各个连续子数组乘积也小于k。举个例子:当窗口为[10,5,2]时, 10,5,2&lt;k, 那么随便从其中拿出两个或一个或三个是不是都小于k。<br>接下来这里有个很重要的条件是要连续的子数组也就是说[10,5,2]中不能取[10,2]因为不连续。<br>思路很明显了:</p>
<ol>
<li>使用变量count存储个数</li>
<li>我们让右指针不断前进，当窗口 乘积小于k时,就让count+=窗口连续子数组个数</li>
<li>当窗口乘积大于等于k时,我们就让乘积去除左指针对应的值，然后左指针右移,直至乘积小于k。</li>
</ol>
<p>那么窗口中连续子数组的个数是多少呢?<br><code>count+=right-left+1</code> (此如例子中[10, 5, 2, 6],初始情况窗口中只有10,所以count+1, 之后窗口中加上了5,变成[10,5],其中连续子数组有: ((10),(5),(10,5)，, 之前的10已经加过了，因此每次加进去的连续子数组是以当前right对应的数为首的连续子数组，再以[10,5,2], 以2为首就是(2,2,5,2,5,10),对应为<code>right-left+1.</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">	 <span class="keyword">if</span>(k &lt;= <span class="number">1</span>) {</span><br><span class="line">		 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	 }</span><br><span class="line">	 <span class="keyword">int</span> now = <span class="number">1</span>, left = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">	 <span class="keyword">for</span>(<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; nums.length; right++) {</span><br><span class="line">		 now *= nums[right];</span><br><span class="line">		 <span class="keyword">while</span>(now &gt;= k) {</span><br><span class="line">			 now /= nums[left++];</span><br><span class="line">		 }</span><br><span class="line">		 count += right - left + <span class="number">1</span>;</span><br><span class="line">	 }</span><br><span class="line">	 <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>二分搜索</tag>
        <tag>java</tag>
        <tag>滑窗</tag>
      </tags>
  </entry>
  <entry>
    <title>分治_面试题.08.03_魔术索引</title>
    <url>/Magic_index/</url>
    <content><![CDATA[<h3 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h3><p>🍁魔术索引。 在数组A[0…n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。</p>
<p>示例1:</p>
<a id="more"></a>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [0, 2, 3, 4, 5]</span><br><span class="line">输出：0</span><br><span class="line">说明: 0下标的元素为0</span><br><span class="line">示例2:</span><br><span class="line"></span><br><span class="line">输入：nums = [1, 1, 1]</span><br><span class="line">输出：1</span><br></pre></td></tr></tbody></table></figure>

<p>提示:</p>
<p><code>nums长度在[1, 1000000]之间</code></p>
<h2 id="🌸方法：暴力剪枝"><a href="#🌸方法：暴力剪枝" class="headerlink" title="🌸方法：暴力剪枝"></a>🌸方法：暴力剪枝</h2><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><ul>
<li>不做详细介绍，简单的代码一看就懂</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(res &lt; nums.length) {</span><br><span class="line">        <span class="keyword">if</span>(res == nums[res]) {</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(res &lt; nums[res]) {</span><br><span class="line">            res = nums[res];</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            res++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>python</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMagicIndex</span><span class="params">(self, nums: list[int])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> res &lt; len(nums):</span><br><span class="line">            <span class="keyword">if</span> res == nums[res]:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">elif</span> res &lt; nums[res]:</span><br><span class="line">                res = nums[res]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法二：分治剪枝"><a href="#🌸解法二：分治剪枝" class="headerlink" title="🌸解法二：分治剪枝"></a>🌸解法二：分治剪枝</h2><h4 id="🍁思路与算法"><a href="#🍁思路与算法" class="headerlink" title="🍁思路与算法"></a>🍁思路与算法</h4><p>本方法会进行一定程度的剪枝，在一些情况下会达到较优的时间复杂度，在最差情况下仍会退化成线性的时间复杂度，这里我们分两种情况讨论。</p>
<p>第一种情况是数组中只有一个满足条件的答案。我们假设这个答案为i,那<br>么意味着[0…- 1]的值均小于自身的下标，[i+ 1…n- 1]的值均大于自身的下标。我们将整个数组每个元素减去其自身所在的下标，那么最后的答案即为0所在的下标，且脏0之前的元素均为负数，0之后的元素均为正数。以[-1,0,2,4,5] 为例，减去自身下标以后以后得到[-1,-1,0,1,1]， 整个数组是具有单调性的，直接二分查找即能在O(log n)的时间内找到答案0所在的下标。</p>
<p>第二种情况是数组中存在多个满足条件的答案，此时我们发现整个数组不具有任何性质。以[0, 0, 2, 2, 5]为例,我们仍进行次将每个元素减去其自身下标的操作，得到[0,-1,0,-1,1]。目标是要找到第一个出现的 0,而由于数组没有单调性,这里无法使用二分查找,但是我们可以依据此来进行一定程度的剪枝，我们剪枝的策略为:</p>
<ul>
<li>每次我们选择数组的中间元素,如果当前中间元素是满足条件的答案，那么这个位置往后的元素我们都不再考虑，只要寻找左半部分是否有满<br>条件的答案即呵。</li>
<li>否则我们需要查看左半部分是否有满足条件的答案,如果没有的话我们仍然需要在右半边寻找，使用的策略同上。</li>
</ul>
<p>我们可以依靠此策略定义-个递归函数: <code>getAnswer(nums， 1eft, right)</code>返回数组<code>nums</code>的下标范围<code>[left, right]</code> 中第一个满足条件的答案， 如果没有返回-1。每次选择中间的位置mid,此时直接先递归调用数组左半部分<code>getAnswer (nums，left, mid 一1)</code>得到返回值<code>leftAnswer,</code>如果存在则直接返回，如果不存在则此较<code>nums[mid]</code>和mid否相等，如果相等则返回mid,否则需要递归调用<code>getAnswer (nums, mid + 1，right)</code></p>
<p>显然，此剪枝策略在[- 1, 0, 1,2, 4]这种答案为数组的最后一个元素的情况下会退化成线性的时间复杂度，但是在一些情况下会有不错的表现。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> getAnswer(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">    <span class="keyword">int</span> leftAnswer = getAnswer(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (leftAnswer != -<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> leftAnswer;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == mid) {</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> getAnswer(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMagicIndex</span><span class="params">(self, nums: list[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getAnser</span><span class="params">(nums: list[int], left: int, right: int)</span> -&gt; int:</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span>;</span><br><span class="line">            leftAnswer = getAnser(nums, left, mid - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> leftAnswer != <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> leftAnswer</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] == mid:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">return</span> getAnser(nums, mid + <span class="number">1</span>, right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> getAnser(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法三：二分剪枝"><a href="#🌸解法三：二分剪枝" class="headerlink" title="🌸解法三：二分剪枝"></a>🌸解法三：二分剪枝</h2><h4 id="🍁思路与算法-1"><a href="#🍁思路与算法-1" class="headerlink" title="🍁思路与算法"></a>🍁思路与算法</h4><p>对于[0, 1,4, 4, 4]这个数组，使用二分法拿出位于中间的<code>idx</code>为2的数字<br>4,然后我们发现<code>nums[idx] &gt; idx</code>此刻我们除了可以确认<code>idx2</code>不是魔术索引|外,还可以确定<code>idx3</code>也肯定不是魔术索引。因为假如<code>idx3</code>是魔术索的话那<code>idx3</code>的值就必须是3, 0这将导致<code>nums[idx3] &lt; nums[dx2],</code>和题目的递增数组”矛盾。<br>所以，此刻魔术索引只可能出现在<code>[0, mid - 1</code>]和<code>[nums[mid], nums.length -1]</code>这两个范围里。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="keyword">if</span> (i &gt; j) {</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> mid = (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (nums[mid] &lt; mid) {</span><br><span class="line">		<span class="keyword">int</span> ans1 = helper(nums, i, nums[i]);</span><br><span class="line">		<span class="keyword">int</span> ans2 = helper(nums, mid + <span class="number">1</span>, j);</span><br><span class="line">		<span class="keyword">return</span> ans1 != -<span class="number">1</span> ? ans1 : ans2;</span><br><span class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; mid) {</span><br><span class="line">		<span class="keyword">int</span> ans1 = helper(nums, i, mid - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> ans2 = helper(nums, nums[mid], j);</span><br><span class="line">		<span class="keyword">return</span> ans1 != -<span class="number">1</span> ? ans1 : ans2;</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="keyword">int</span> ans = helper(nums, <span class="number">0</span>, mid - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> ans != -<span class="number">1</span> ? ans : mid;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>二分搜索</tag>
        <tag>java</tag>
        <tag>python</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找_模板学习(减治思想)</title>
    <url>/Binary_search_template/</url>
    <content><![CDATA[<h2 id="🌸首先用一个题进行二分查找的引入"><a href="#🌸首先用一个题进行二分查找的引入" class="headerlink" title="🌸首先用一个题进行二分查找的引入"></a>🌸首先用一个题进行二分查找的引入</h2><p>🍁给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p>示例 1:</p>
<p><code>输入: [1,3,5,6], 5</code><br><code>输出: 2</code><br>示例 2:</p>
<a id="more"></a>

<p><code>输入: [1,3,5,6], 2</code><br><code>输出: 1</code><br>示例 3:</p>
<p><code>输入: [1,3,5,6], 7</code><br><code>输出: 4</code><br>示例 4:</p>
<p><code>输入: [1,3,5,6], 0</code><br><code>输出: 0</code></p>
<h2 id="🌸分析"><a href="#🌸分析" class="headerlink" title="🌸分析"></a>🌸分析</h2><h2 id="🌸方法一：暴力解法"><a href="#🌸方法一：暴力解法" class="headerlink" title="🌸方法一：暴力解法"></a>🌸方法一：暴力解法</h2><ul>
<li><p>从数组的左边遍历到右边，如果遇到相等的元素，直接返回下标；</p>
</li>
<li><p>遇到第 1 个严格大于 target 的元素，返回这个元素的下标；</p>
</li>
<li><p>如果数组里所有的元素都严格小于 target，返回数组的长度 len。</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= nums[i]){</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nums.length;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>python</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt;= target:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> target <span class="keyword">in</span> list:</span><br><span class="line">        <span class="keyword">return</span> list.index(target)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        list.append(target)</span><br><span class="line">        list.sort()</span><br><span class="line">        <span class="keyword">return</span> list.index(target)</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸方法二：-二分查找"><a href="#🌸方法二：-二分查找" class="headerlink" title="🌸方法二： 二分查找"></a>🌸方法二： 二分查找</h2><p>🍁分析：在有序数组中查找插入元素的位置，显然可以使用二分查找。这篇题解提供的思路是「排除法」，思路是：<strong>在循环的过程中，不断排除不需要的解，最后剩下的那个元素的位置就一定是插入元素的位置。</strong></p>
<p>具体来说：</p>
<ul>
<li>首先，插入位置有可能在数组的末尾（题目中的示例 3），需要单独判断，此时返回数组的长度；</li>
<li>否则，根据示例和暴力解法的分析，插入的位置是<strong>大于等于</strong> <code>target</code> 的<strong>第 1 个元素的位置。</strong></li>
</ul>
<p>因此，<strong>严格小于</strong> <code>target</code> <strong>的元素一定不是解</strong>，在循环体中将左右边界 <code>left</code> 和 <code>right</code> 逐渐向中间靠拢，最后 left 和 right 相遇，则找到了插入元素的位置。</p>
<p>插入元素的位置可能在数组的末尾下标的下一个（见例 3），因此在初始化右边界 <code>right</code> 的时候，可以设置成为数组的长度 <code>len</code>,根据这个思路，可以写出如下代码。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">       <span class="keyword">int</span> len = nums.length;</span><br><span class="line">       <span class="keyword">if</span> (len == <span class="number">0</span>) {</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       }</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 因为有可能数组的最后一个元素的位置的下一个是我们要找的，故右边界是 len</span></span><br><span class="line">       <span class="keyword">int</span> right = len;</span><br><span class="line">       <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">           <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">           <span class="comment">// 小于 target 的元素一定不是解</span></span><br><span class="line">           <span class="keyword">if</span> (nums[mid] &lt; target) {</span><br><span class="line">               <span class="comment">// 下一轮搜索的区间是 [mid + 1, right]</span></span><br><span class="line">               left = mid + <span class="number">1</span>;</span><br><span class="line">           } <span class="keyword">else</span> {</span><br><span class="line">             	<span class="comment">// 下一轮搜索的区间是 [left, mid]</span></span><br><span class="line">               right = mid;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> left;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        size = len(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 因为有可能数组的最后一个元素的位置的下一个是我们要找的，故右边界是 len</span></span><br><span class="line">        right = size</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 严格小于 target 的元素一定不是解</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                <span class="comment"># 下一轮搜索区间是 [mid + 1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸二分查找算法简介"><a href="#🌸二分查找算法简介" class="headerlink" title="🌸二分查找算法简介"></a>🌸二分查找算法简介</h2><hr>
<p><img src="https://s1.ax1x.com/2020/07/17/UsKbVA.png" alt=""></p>
<h2 id="🌸二分查找的思想"><a href="#🌸二分查找的思想" class="headerlink" title="🌸二分查找的思想"></a>🌸二分查找的思想</h2><p>减而治之，即将大规模问题转化成小规模问题。减而治之是分而治之的特例，将大问题划分成若干个子问题以后，最终答案只在其中一个子问题里。</p>
<h2 id="🌸生活中的二分查找"><a href="#🌸生活中的二分查找" class="headerlink" title="🌸生活中的二分查找"></a>🌸生活中的二分查找</h2><p>以前央视有一档节目叫《幸运 52》，里面有个游戏「猜价格」，主持人说猜高了，观众就往低了猜，主持人说猜低了，观众就往高了猜，直至猜中为止。</p>
<p>程序员定位 bug，经常是在一些逻辑关键点做一些变量的打印输出，以逐渐缩小查找范围，最终定位出问题的代码行（或者块）。</p>
<h2 id="🌸二分查找的基本问题（二分查找模板一）"><a href="#🌸二分查找的基本问题（二分查找模板一）" class="headerlink" title="🌸二分查找的基本问题（二分查找模板一）"></a>🌸二分查找的基本问题（二分查找模板一）</h2><p>「力扣」第 704 题：二分查找</p>
<p>思路：先看中间位置的元素，如果恰好等于，则直接返回中间位置的下标，否则看中间位置元素的值 nums[mid] 和 target 的关系决定下一轮在哪一侧寻找目标元素。</p>
<p>这个思路把待查找数组分为了 3 个部分：mid 所在位置，mid 的左边，mid 的右边。根据 mid 元素与目标元素的值的大小关系，如果 nums[mid] 恰好等于 target 直接返回就好了，否则根据不等关系，确定下一轮搜索的区间在哪里。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 目标元素可能存在在区间 [left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) {</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) {</span><br><span class="line">                <span class="comment">// 目标元素可能存在在区间 [mid + 1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 目标元素可能存在在区间 [left, mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>说明：</p>
<ul>
<li><p>循环可以继续的条件是 while (left &lt;= right) ，表示当 left == right 成立的时候，还有一个元素，即下标 left（right）位置的元素还没有看到，需要继续查看这个元素的值，看看是不是目标元素；</p>
</li>
<li><p>关于取中间数 int mid = (left + right) / 2; 在 left + right 很大的时候会发生整形溢出，一般这样改写：</p>
</li>
</ul>
<p><code>int mid = left + (right - left) / 2;</code></p>
<p>这两种写法事实上没有太大的区别，在 left 和 right 都表示数组下标的时候，几乎不会越界，因为绝大多数情况下不会开那么长的数组。</p>
<p>在 Java 中还可以这样写</p>
<p><code>int mid = (left + right) &gt;&gt;&gt; 1;</code></p>
<p><code>&gt;&gt;&gt;</code>，它表示，在 <code>left + right</code> 发生整型溢出的时候，<strong>高位补 0</strong>，结果依然正确。这一点是从 JDK 的源码中 <code>Arrays.binarySearch()</code> 方法借鉴来的。</p>
<p>在 Python 中不用这样改写，Python 在 <code>left + right</code> 发生整型溢出的时候会自动转成长整形。</p>
<p>这里不建议把 <code>/ 2</code> 改写成 <code>&gt;&gt; 1</code>，理由是高级语言在编译期间会做优化，会将 <code>/ 2</code>，以及除以 2 的方幂的操作，在内部修改为 <code>&gt;&gt;</code>，工程师只需要写程序本来的逻辑就好了。如果使用位运算，在 C++ 中可能还需要注意运算优先级的问题。</p>
<p><strong>为什么取二分之一？三分之一、五分之四可不可以？</strong><br>（对于这道问题）当然可以，大家可以自行验证。结合二分查找的思路并不难理解，其实只要在数组中间任意找一个位置的元素，如果恰好是目标元素，则直接返回。如果不是根据这个元素的值和目标元素的大小关系，进而在当前位置的左侧还是右侧继续查找。</p>
<p>在我们对问题一无所知的时候，取中间数是最好的做法（如果有学习过《机器学习》熵的概念可能会有感触）。</p>
<p>还有一个细节，<code>/ 2</code> 表示的是下取整，当数组中的元素个数为偶数的时候，<code>int mid = left + (right - left) / 2;</code> 只能取到位于左边的那个元素。那么取位于右边的那个元素可以吗，当然可以，理由同上。<br>取右边中间数的表达式是（其实就是在括号里 + 1，表示上取整）：</p>
<p><code>int mid = left + (right - left) / 2;</code><br>以上的代码可以认为是二分查找的模板一。下面我们介绍二分查找模板二，应用这个模板的思想可以解决「力扣」上很多二分查找算法的变种和一些复杂的二分查找问题。</p>
<h2 id="🌸二分查找模板二（在循环体里排除不存在目标元素的区间）"><a href="#🌸二分查找模板二（在循环体里排除不存在目标元素的区间）" class="headerlink" title="🌸二分查找模板二（在循环体里排除不存在目标元素的区间）"></a>🌸二分查找模板二（在循环体里排除不存在目标元素的区间）</h2><h3 id="🍁基本思想"><a href="#🍁基本思想" class="headerlink" title="🍁基本思想"></a>🍁基本思想</h3><p>从考虑哪些元素一定不是目标元素开始考虑。在本题解最开始其实已经介绍了：根据看到的 <code>mid</code> <strong>位置的元素，排除掉一定不可能存在目标元素的区间，而下一轮在可能存在目标的子区间里继续查找。</strong></p>
<h3 id="🍁具体做法"><a href="#🍁具体做法" class="headerlink" title="🍁具体做法"></a>🍁具体做法</h3><ul>
<li>先把循环可以继续的条件写成 <code>while (left &lt; right)</code>，表示退出循环的时候，<code>[left, right]</code> 这个区间里只有一个元素，这个元素有可能就是目标元素；</li>
<li>写 if 和 else 语句的时候，思考当 <code>nums[mid]</code> 满足什么性质的时候，<code>num[mid]</code> 不是解，进而接着判断 mid 的左边有没有可能是解，mid 的右边有没有可能是解；<br>说明：</li>
<li>做题的经验告诉我，思考什么时候不是解比较好想。如果一个数要满足多个条件，只需要对其中一个条件取反，就可以达到缩小搜索范围的目的；</li>
<li>此时 mid 作为待查找数组的分界，就把它分为两个区间：一个部分可能存在目标元素，一个部分一定不存在目标元素。</li>
</ul>
<h3 id="🍁理解如何避免死循环（重难点）"><a href="#🍁理解如何避免死循环（重难点）" class="headerlink" title="🍁理解如何避免死循环（重难点）"></a>🍁理解如何避免死循环（重难点）</h3><p>根据 mid 被分到左边区间还是右边区间，代码写出来只有以下 2 种：</p>
<p><strong>边界收缩行为 1：</strong> mid 被分到左边。即区间被分成 <code>[left, mid]</code> 与 <code>[mid + 1, right]，</code>这里用「闭区间」表示区间端点可以取到，下同；</p>
<p>代码写出来是这样的：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (check(mid)) {</span><br><span class="line">    <span class="comment">// 下一轮搜索区间是 [mid + 1, right]，因此把左边界设置为 mid + 1 位置</span></span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// 上面对了以后，剩下的区间一定是 [left, mid]，因此右边界设置为 mid 位置</span></span><br><span class="line">    right = mid;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>说明：这里的 <code>check(mid)</code> 函数通常是一个表达式，在一些情况下有可能逻辑比较复杂，建议专门抽取成一个私有方法，以突显主干逻辑。</p>
<p><strong>边界收缩行为 2</strong>： mid 被分到右边。即区间被分成 [left, mid - 1] 与 [mid, right]；</p>
<p>同上，代码写出来是这样的：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (check(mid)) {</span><br><span class="line">    <span class="comment">// 下一轮搜索区间是 [left, mid - 1]，因此把右边界设置为 mid - 1 位置</span></span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// 上面对了以后，剩下的区间一定是 [mid, right]，因此左边界设置为 mid 位置</span></span><br><span class="line">    left = mid;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>面对面的<strong>边界收缩行为 2</strong>（mid 被分到右边），在待搜索区间收缩到只剩下 2 个元素的时候，<strong>就有可能造成死循环。搜索区间不能缩小，是造成死循环的原因</strong>。</p>
<p>有了上面的分析，我们把上面「边界收缩行为」对应的中间数取法补上：</p>
<p><strong>边界收缩行为 1：</strong> mid 被分到左边。即区间被分成 <code>[left, mid] 与 [mid + 1, right]，</code>此时取中间数的时候下取整。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (check(mid)) {</span><br><span class="line">    <span class="comment">// 下一轮搜索区间是 [mid + 1, right]</span></span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    right = mid;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>边界收缩行为 2：</strong> mid 被分到右边。即区间被分成 <strong>[left, mid - 1] 与 [mid, right]，</strong>此时取中间数的时候上取整。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (check(mid)) {</span><br><span class="line">    <span class="comment">// 下一轮搜索区间是 [left, mid - 1]</span></span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    left = mid;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果这里有疑惑，大家在练习的过程中，当发生死循环的时候：在 while 循环里把 left、right、mid 变量的值打印出来看看，就很清楚了。</p>
<p>遇到几次死循环，调试正确以后，就能很清楚地记住下面这条规则：在 if else 语句里面只要出现 left = mid 的时候，把去中间数行为改成上取整即可。</p>
<h2 id="🌸二分查找模板二（在循环体里排除不存在目标元素的区间）的一般步骤"><a href="#🌸二分查找模板二（在循环体里排除不存在目标元素的区间）的一般步骤" class="headerlink" title="🌸二分查找模板二（在循环体里排除不存在目标元素的区间）的一般步骤"></a>🌸二分查找模板二（在循环体里排除不存在目标元素的区间）的一般步骤</h2><p>1、确定搜索区间初始化时候的左右边界，有时需要关注一下边界值。在初始化时，有时把搜索区间设置大一点没有关系，但是如果恰好把边界值排除在外，再怎么搜索都得不到结果；</p>
<p>例如本题（「力扣」第 35 题），如果一开始把 len 这个位置排除在外进行二分搜索（在之前也没有特判），代码是怎么都通不过评测系统的。</p>
<p>2、先写上 while (left &lt; right) ，表示退出循环的条件是 left == right，对于返回左右边界就不用思考了，因此此时它们下标的值相等；</p>
<p>3、先写下取整的中间数取法，然后<strong>从如何把 mid 排除掉的角度思考 if 和 else 语句应该怎样写。</strong>这里建议写两个注释，非必需。</p>
<ul>
<li><p>一般而言，我都会把<strong>「什么时候不是目标元素」作为注释写在代码中，提醒自己要判断正确，</strong>这一步判断非常关键，直接影响到后面的代码逻辑；</p>
</li>
<li><p>然后接着思考 mid 不是解的情况下，mid 的左右两边可能存在解，<strong>把下一轮搜索的区间范围作为注释写进代码里，</strong>进而在确定下一轮搜索区间边界的收缩行为时，不容易出错。</p>
</li>
<li><p>if 有把握写对的情况下，else 就是 if 的反面，可以不用思考，直接写出来。</p>
</li>
</ul>
<p>说明：这种思考方式，就正正好把待搜索区间从逻辑上分成两个区间，一个区间不可能存在目标元素，进而在另一个区间里继续搜索，更符合二分的语义。</p>
<p>4、根据 if else 里面写的情况，看看是否需要修改中间数下取整的行为；</p>
<p>只有看到 left = mid 的时候，才需要调整成为上取整，记住这一点即可，我因为刚开始不理解这种写法，遇到很多次死循环，现在已经牢记在心了。</p>
<p>5、退出循环的时候，一定有 <code>left == right</code> 成立<strong>。有些时候可以直接返回 left （或者 right，由于它们相等，后面都省略括弧）或者与 left 相关的数值，有些时候还须要再做一次判断，判断 left 与 right 是否是我们需要查找的元素，这一步叫「后处理」。</strong></p>
<p>本题就是这样，因为插入元素的位置，一定在搜索范围里，因此退出循环的时候，不用再做一次判断。</p>
<h3 id="🍁与其它二分查找模板的比较"><a href="#🍁与其它二分查找模板的比较" class="headerlink" title="🍁与其它二分查找模板的比较"></a>🍁与其它二分查找模板的比较</h3><p>while 里面的表达式决定了退出循环以后区间 [left, right] 有几个元素。几个模板的主要区别就在这里。</p>
<p>1、 <code>while (left &lt;= right)</code> 事实上是把待搜索区间「三分」，if else 有三个分支，它直接面对目标元素，在目标元素在待搜索数组中有只有 1 个的时候，可能提前结束查找。但是如果目标元素没有在待搜索数组中存在，则不能节约搜索次数；</p>
<p>2、<code>while (left &lt; right)</code> 是本题解推荐使用的思考方法，不建议背模板，建议的方法是多做题，掌握解题的思路和技巧；</p>
<p>优点是：更符合二分语义，不用去思考返回 left 还是 right，在退出循环的时候，有的时候，根据语境，不正确的数都排除掉，最后剩下的那个数就一定是目标值，不需要再做一次判断。</p>
<p><strong>🍁这种方法思考的细节最少，写程序不易出错。</strong></p>
<p>缺点是：需要理解当分支逻辑出现 left = mid 的时候，要修改取中间数的行为，使其上取整。</p>
<p>3、<code>while (left + 1 &lt; right)</code> 这种写法其实很多人都在用，如果你理解了本题解介绍的方法，理解它就很容易了。使用它在退出循环的时候，有 <code>left + 1 = right</code> 成立，即 left 和 right夹成的区间里一定有 2 个元素，此时需要分别判断 left 和 right 位置的元素是不是目标元素，有时需要注意判断的先后顺序。</p>
<p>优点：不用去理解和处理第 2 点说的那种上取整的行为，因为不会出现死循环。<br>缺点：</p>
<ul>
<li><code>while (left + 1 &lt; right)</code> 这种写法我个人认为不那么自然；</li>
<li>一定需要后处理，在后处理这个问题上增加了思考的负担；</li>
<li><code>left = mid</code> 和 <code>right = mid</code> 这种写法比较随意，而事实上，程序员完全有能力决定 mid 是保留还是被排除在外。</li>
</ul>
<h2 id="🌸补充：二分查找变体（来自极客APP专栏）"><a href="#🌸补充：二分查找变体（来自极客APP专栏）" class="headerlink" title="🌸补充：二分查找变体（来自极客APP专栏）"></a>🌸补充：二分查找变体（来自极客APP专栏）</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 查找第一个值等于给定值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">firstEquals</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) {</span><br><span class="line">        <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid; <span class="comment">// 收缩右边界不影响 first equals</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (arr[l] == target &amp;&amp; (l == <span class="number">0</span> || arr[l - <span class="number">1</span>] &lt; target)) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 查找最后一个值等于给定值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lastEquals</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) {</span><br><span class="line">        <span class="keyword">int</span> mid = l + ((r - l + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; target) r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid; <span class="comment">// 收缩左边界不影响 last equals</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (arr[l] == target &amp;&amp; (l == arr.length - <span class="number">1</span> || arr[l + <span class="number">1</span>] &gt; target)) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 查找第一个大于等于给定值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">firstLargeOrEquals</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) {</span><br><span class="line">        <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid; <span class="comment">// 收缩右边界不影响 first equals</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &gt;= target &amp;&amp; (l == <span class="number">0</span> || arr[l - <span class="number">1</span>] &lt; target)) <span class="keyword">return</span> l; <span class="comment">// &gt;=</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 查找最后一个小于等于给定值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lastLessOrEquals</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) {</span><br><span class="line">        <span class="keyword">int</span> mid = l + ((r - l + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; target) r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid; <span class="comment">// 收缩左边界不影响 last equals</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &lt;= target &amp;&amp; (l == arr.length - <span class="number">1</span> || arr[l + <span class="number">1</span>] &gt; target)) <span class="keyword">return</span> l; <span class="comment">// &lt;=</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="注：本博为自身二分查找学习的记录收藏，以上二分查找的内容均截取自liweiwei1419，威威哥写的真的挺棒，为大家推荐一波"><a href="#注：本博为自身二分查找学习的记录收藏，以上二分查找的内容均截取自liweiwei1419，威威哥写的真的挺棒，为大家推荐一波" class="headerlink" title="注：本博为自身二分查找学习的记录收藏，以上二分查找的内容均截取自liweiwei1419，威威哥写的真的挺棒，为大家推荐一波"></a>注：本博为自身二分查找学习的记录收藏，以上二分查找的内容均截取自<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">liweiwei1419</a>，威威哥写的真的挺棒，为大家推荐一波</h3><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>二分搜索</tag>
        <tag>java</tag>
        <tag>python</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找_leetcode.410_分割数组的最大值</title>
    <url>/The_maximum_value_of_the_split_array/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。</p>
<p>注意:<br>数组长度 n 满足以下条件:</p>
<p><code>1 ≤ n ≤ 1000</code><br><code>1 ≤ m ≤ min(50, n)</code><br>示例:</p>
<a id="more"></a>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums = [7,2,5,10,8]</span><br><span class="line">m = 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">18</span><br></pre></td></tr></tbody></table></figure>

<p>解释:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">一共有四种方法将nums分割为2个子数组。</span><br><span class="line">其中最好的方式是将其分为[7,2,5] 和 [10,8]，</span><br><span class="line">因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸分析思路"><a href="#🌸分析思路" class="headerlink" title="🌸分析思路"></a>🌸分析思路</h2><p>🍁这道题要找一个整数，这个整数有确定的范围，因此可以考虑使用二分查找，类似的典型问题有「力扣」第 69 题：平方根，「力扣」第 287 题：寻找重复数。</p>
<p>题目要求的变量（各自分组的和的最大值 M）与另一个变量（组数）有相关关系（负线性相关），而题目对组数有限制，根据这个相关关系去逼近 M 的最小值，这也是一类常见的使用「二分查找」的题型：「力扣」第 875 题： 爱吃香蕉的珂珂。</p>
<p>重点理解：</p>
<ul>
<li><strong>大于的时候舍弃，小于等于的时候保留，这样左右向中间逼近能找到 M 的最小值，</strong>具体可以看题解中唯一的那张图；</li>
<li>理解贪心算法的应用，在从左向右划分组的时候，我们的方案是尽量让一个组有更多的元素，直至超过了设定的临界值</li>
</ul>
<h2 id="🌸方法：二分查找"><a href="#🌸方法：二分查找" class="headerlink" title="🌸方法：二分查找"></a>🌸方法：二分查找</h2><p>🍁注意题目中给出的这 3 个条件：</p>
<ul>
<li>数组中的元素均是「非负整数」；</li>
<li>子数组的特点是：「非空」且「连续」；</li>
<li>恰好分成 <code>m</code> 个非空「非空连续子数组」。</li>
</ul>
<p>题目中还给出了一个概念：「连续子数组各自和的最大值」，我们用一个变量 <code>maxIntervalSum</code> 表示。不难知道：</p>
<ul>
<li>每一个「非空连续子数组」如果包含的元素个数越多，那么 <code>maxIntervalSum</code> 就可能越大（非负整数保证）；</li>
<li><strong>一个 <code>maxIntervalSum</code>的数值就唯一对应了一个分出的「非空连续子数组」的组数 M ，它们是函数关系（一一对应）， <code>maxIntervalSum</code> 是自变量，M 是因变量，可以写成：</strong><br><code>M = function(maxIntervalSum)</code></li>
</ul>
<p><strong>如何找到一个 <code>maxIntervalSum</code>，使得它对应的 M 恰好等于题目给出的 <code>m</code>。但是我们容易分析出，这个函数是一个单调递减的函数：</strong></p>
<ul>
<li>如果 <code>maxIntervalSum</code> 越小，分出的「非空连续子数组」的组数 M 就越大；</li>
<li>如果 <code>maxIntervalSum</code> 越大，分出的「非空连续子数组」的组数 M 就越小。</li>
</ul>
<p>因此这个函数是单调不增的函数。</p>
<p><img src="https://pic.leetcode-cn.com/078e19e89976f6487da9936288855a27feb50b935b69a475dd3c9c3bb730b5dc-image.png" alt=""></p>
<p>原因就在于上面强调的题目中给出的 2 个条件：非负整数和非空连续子数组，<strong>由于这种单调性，可以使用二分查找，找到与 m 对应的 <code>maxIntervalSum 。</code></strong></p>
<p>参考代码：</p>
<p>下面是一些细节：</p>
<ul>
<li><p>只要连续加起来的数值超过了 <code>maxIntervalSum</code>，就新产生一个新的连续子数组；</p>
</li>
<li><p><code>maxIntervalSum</code> 的最小值是这个数组中的最大值，这是因为 <code>max(nums)</code> 一定会被分到其中一组；</p>
</li>
<li><p><code>maxIntervalSum</code> 的最大值是这个数组中所有元素的和，极端情况就是题</p>
<p>目中给出 <code>m = 1</code> 的时候。</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 计算「子数组各自的和的最大值」的上下界</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> num : nums) {</span><br><span class="line">		max = Math.max(max, num);</span><br><span class="line">		sum += num;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">       <span class="comment">// 使用「二分查找」确定一个恰当的「子数组各自的和的最大值」，</span></span><br><span class="line">       <span class="comment">// 使得它对应的「子数组的分割数」恰好等于 m</span></span><br><span class="line">	<span class="keyword">int</span> left = max;</span><br><span class="line">	<span class="keyword">int</span> right = sum;</span><br><span class="line">	<span class="keyword">while</span>(left &lt; right) {</span><br><span class="line">		<span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> splits = split(nums, mid);</span><br><span class="line">		<span class="keyword">if</span>(splits &gt; m) {</span><br><span class="line">               <span class="comment">// 如果分割数太多，说明「子数组各自的和的最大值」太小，此时需要将「子数组各自的和的最大值」调大</span></span><br><span class="line">               <span class="comment">// 下一轮搜索的区间是 [mid + 1, right]处。</span></span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		}<span class="keyword">else</span> {</span><br><span class="line">			 <span class="comment">// 下一轮搜索的区间是上一轮的反面区间 [left, mid]</span></span><br><span class="line">			right = mid;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">}</span><br><span class="line">   <span class="comment">/***</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> nums 原始数组</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> maxIntervalSum 子数组各自的和的最大值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 满足不超过「子数组各自的和的最大值」的分割数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> maxIntervalSum)</span> </span>{</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="comment">//至少一个分割数</span></span><br><span class="line">	<span class="keyword">int</span> splits = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//当前区间的和</span></span><br><span class="line">	<span class="keyword">int</span> curIntervalSum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> num : nums) {</span><br><span class="line">		<span class="keyword">if</span>(curIntervalSum + num &gt; maxIntervalSum) {</span><br><span class="line">			curIntervalSum = <span class="number">0</span>;</span><br><span class="line">			splits++;</span><br><span class="line">		}</span><br><span class="line">		curIntervalSum += num;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> splits;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>python</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitArray</span><span class="params">(self, nums: list[int], m: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(nums: list[int], maxIntervalSum: int)</span> -&gt; int:</span></span><br><span class="line">            splits = <span class="number">1</span></span><br><span class="line">            curIntervalSum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> curIntervalSum + num &gt; maxIntervalSum:</span><br><span class="line">                    curIntervalSum = <span class="number">0</span></span><br><span class="line">                    splits += <span class="number">1</span></span><br><span class="line">                curIntervalSum += num</span><br><span class="line">            <span class="keyword">return</span> splits</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">#   计算「子数组各自的和的最大值」的上下界</span></span><br><span class="line">        _max = max(nums)</span><br><span class="line">        _sum = sum(nums)</span><br><span class="line">        <span class="comment">#  使用「二分查找」确定一个恰当的「子数组各自的和的最大值」，</span></span><br><span class="line">        <span class="comment"># 使得它对应的「子数组的分割数」恰好等于 m</span></span><br><span class="line">        left, right = _max, _sum</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right):</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            splits = split(nums, mid)</span><br><span class="line">            <span class="keyword">if</span> splits &gt; m:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸总结"><a href="#🌸总结" class="headerlink" title="🌸总结"></a>🌸总结</h2><h4 id="🍁理解单调性"><a href="#🍁理解单调性" class="headerlink" title="🍁理解单调性"></a>🍁理解单调性</h4><ul>
<li>一个重要的性质：分割数越大，「子数组各自的和的最大值」就越小（非递增，满足单调性），因此可以使用二分查找，定位分割数；</li>
<li>一种「分割方案（分成几个子数组）」对应了一个「子数组各自的和的最大值」；</li>
<li>反过来，一个「子数组各自的和的最大值」对应了一种「分割方案（分成几个子数组）」；</li>
<li>它们是一一对应的关系（关键）。</li>
</ul>
<h4 id="🍁思路整理（绕了个弯子去逼近）"><a href="#🍁思路整理（绕了个弯子去逼近）" class="headerlink" title="🍁思路整理（绕了个弯子去逼近）"></a>🍁思路整理（绕了个弯子去逼近）</h4><ul>
<li>先找「子数组各自的和的最大值」的中间数（尝试得到的一个值），看看它对应的「分割方案（分成几个子数组）」是多少；</li>
<li>如果「分割方案（分成几个子数组）」比题目要求的 <code>m</code> 还多，说明「子数组各自的和的最大值」还太小，所以下一次搜索应该至少是中位数 <code>+ 1</code>（<code>left = mid + 1</code>），它的反面即至多是中位数（<code>right = mid</code>）。</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>二分搜索</tag>
        <tag>java</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>二分_剑指offer.11_旋转数组的最小数字</title>
    <url>/Rotate%20the_smallest_number_in_the_array/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p>
<p>示例 1：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸分析思路"><a href="#🌸分析思路" class="headerlink" title="🌸分析思路"></a>🌸分析思路</h2><ul>
<li><p>🍁如下图所示，寻找旋转数组的最小元素即为寻找 右排序数组 的首个元素 numbers[x] ，称 x 为 旋转点 。</p>
</li>
<li><p>排序数组的查找问题首先考虑使用 二分法 解决，其可将遍历法的 线性级别 时间复杂度降低至 对数级别 。</p>
</li>
</ul>
<p><a href="https://imgchr.com/i/U7EXOs" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/22/U7EXOs.png" alt="U7EXOs.png"></a></p>
<h2 id="🌸方法：二分查找"><a href="#🌸方法：二分查找" class="headerlink" title="🌸方法：二分查找"></a>🌸方法：二分查找</h2><h3 id="🍁算法流程"><a href="#🍁算法流程" class="headerlink" title="🍁算法流程"></a>🍁算法流程</h3><ol>
<li><p>循环二分： 设置 i, j 指针分别指向 numbers 数组左右两端，m = (i + j) // 2为每次二分的中点（ “//“ 代表向下取整除法，因此恒有 i ≤ m &lt; j），可分为以下三种情况：</p>
<ul>
<li>当numbers[m] &gt; numbers[j] 时: m一在左排序数组中，即旋转点x一定在[m+ 1,j]闭区间内,因此执行i= m+ 1;</li>
<li>当numbers[m] &lt; numbers[j] 时: m一定在右排序数组中，即旋转点x一定在[i, m]闭区间内，因此执行j = m;</li>
<li>当numbers[m] = numbers[j] 时:无法判断m在哪个排序数组中，即无法判断旋转点x在[i, m]还是[m+ 1,j]间中。解决方案:执行j= j- 1缩小判断范围(分析见以下内容) 。</li>
</ul>
</li>
<li><p>返回值:当i = j时跳出二分循环，并返迥numbers[i]即可。</p>
<blockquote>
<p><strong>思考:</strong>是否可以用numbers[m] 和numbers[i]|比较做代替?<br><strong>解析:</strong>不可以。因为做比较的目的是判断m在哪个排序数组中。在numbers [m]&gt;numbers[i] 情况下,无法判断m在哪个排序数组中。本质是因为j初始值肯定在右排序数组中; i 初始值无法确定在哪个排序数组中。<br><strong>示例</strong>:当i=0,j= 4,m=2时,有numbers[m] &gt; numbers[i] ， 以下两示例<br>得出不同结果。<br>numbers= [1, 2,3,4,5]旋转点x= 0: m在右排序数组(际例只有右排序<br>数组) ;<br>numbers= [3, 4,5,1,2]旋转点x= 3: m在左排序数组。</p>
</blockquote>
<p><strong>展开分析numbers[m] = numbers[j] 情况:</strong></p>
<ol>
<li><strong>无法判定m在左(右)排序数组:</strong>设以下两个旋转点值为 0的示例数组，则当i=0,j= 4时m=2，两际例结果不同。<ol>
<li>例[1,0,1,1,1]:旋转点x= 1,因此m= 2在<strong>右排序数组</strong>中。</li>
<li>例[1,1,1,0,1]:旋转点x=3,因此m = 2在<strong>左排序数组</strong>中。</li>
</ol>
</li>
<li>j= j - 1<strong>操作的正确性证明</strong>:只需证明晦次执行此操作后，旋转点x仍在[i, j]区间内即可。<ol>
<li><strong>若m在右排序数组中</strong>: numbers[m] == numbers[j]，因此数组[m,j] (恒有m &lt; j)间内所有元素值相等，执行j= j- 1只会抛弃-个重复值,因此旋转点x仍在[i, j]区间内。</li>
<li><strong>若m在左排序数组中:</strong>于|左排序数组任一元素&gt;=右排序数组任一元素|，因此可推出旋转元素值numbers[x] &lt;= numbers[j] == numbers[m]，则有:<ol>
<li>若numbers[x] &lt; numbers[j] :即j方仍有值更小的元素，执行j= j- 1后旋转点x 仍在[i, j]区间内。</li>
<li>若numbers[x] = numbers[j] :分为以下两种情况。<ol>
<li>当j&gt; x:易得执行j= j- 1后旋转点x仍在[i,j]区间内。</li>
<li>当j= x:特殊情况，即执行j=j- 1后旋转点x可能不在[i, j]区间内。例如<br>[1,1,1,2,3,1]，当i=0,m=2,j= 5时执行j= j- 1后虽然秩了旋转索引x= 5，但最终返回值仍正确(最终返回numbers[0] 等于旋转点值numbers[5])，这是因为:之后的二分循环一直在执行j = m,区间[i, m]内的元素值一定都等于旋转点值numbers[x] ( :区间内元素值既要满足≥也要满足&lt; numbers[x] )，因此仍可保证正确的返回值。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>总结:仿河以保证返回值numbers[i]| 等于旋转点值numbers[x] ;但在少数特例下i不是旋转<br>点x。本题目职要求返回“旋转点的值”，因此本方法可行。</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>{</span><br><span class="line">	  <span class="keyword">int</span> left = <span class="number">0</span>, right = numbers.length - <span class="number">1</span>;</span><br><span class="line">	  <span class="keyword">while</span>(left &lt; right) {</span><br><span class="line">		  <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">		  <span class="keyword">if</span>(numbers[mid] &lt; numbers[right]) {</span><br><span class="line">			  right = mid;</span><br><span class="line">		  }<span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &gt; numbers[right]) {</span><br><span class="line">			  left = mid + <span class="number">1</span>;</span><br><span class="line">		  }<span class="keyword">else</span> {</span><br><span class="line">			  right--;</span><br><span class="line">		  }</span><br><span class="line">	  }</span><br><span class="line">	  <span class="keyword">return</span> numbers[left];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>python</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minArray</span><span class="params">(self, numbers: [int])</span> -&gt; int:</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(numbers) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            m = (i + j) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> numbers[m] &gt; numbers[j]: i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> numbers[m] &lt; numbers[j]: j = m</span><br><span class="line">            <span class="keyword">else</span>: j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> numbers[i]</span><br></pre></td></tr></tbody></table></figure>



<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>二分搜索</tag>
        <tag>java</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划_leetcode.1504.统计全1子矩形</title>
    <url>/Statistical_all-1_subrectangle/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给你一个只包含 0 和 1 的 rows * columns 矩阵 mat ，请你返回有多少个 子矩形 的元素全部都是 1 。</p>
<p>示例 1：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：mat = [[1,0,1],</span><br><span class="line">            [1,1,0],</span><br><span class="line">            [1,1,0]]</span><br><span class="line">输出：13</span><br><span class="line">解释：</span><br><span class="line">有 6 个 1x1 的矩形。</span><br><span class="line">有 2 个 1x2 的矩形。</span><br><span class="line">有 3 个 2x1 的矩形。</span><br><span class="line">有 1 个 2x2 的矩形。</span><br><span class="line">有 1 个 3x1 的矩形。</span><br><span class="line">矩形数目总共 = 6 + 2 + 3 + 1 + 1 = 13 。</span><br></pre></td></tr></tbody></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：mat = [[0,1,1,0],</span><br><span class="line">            [0,1,1,1],</span><br><span class="line">            [1,1,1,0]]</span><br><span class="line">输出：24</span><br><span class="line">解释：</span><br><span class="line">有 8 个 1x1 的子矩形。</span><br><span class="line">有 5 个 1x2 的子矩形。</span><br><span class="line">有 2 个 1x3 的子矩形。</span><br><span class="line">有 4 个 2x1 的子矩形。</span><br><span class="line">有 2 个 2x2 的子矩形。</span><br><span class="line">有 2 个 3x1 的子矩形。</span><br><span class="line">有 1 个 3x2 的子矩形。</span><br><span class="line">矩形数目总共 = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24 。</span><br></pre></td></tr></tbody></table></figure>

<p>示例 3：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：mat = [[1,1,1,1,1,1]]</span><br><span class="line">输出：21</span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：mat = [[1,0,1],[0,1,0],[1,0,1]]</span><br><span class="line">输出：5</span><br></pre></td></tr></tbody></table></figure>


<p>提示：</p>
<ul>
<li><code>1 &lt;= rows &lt;= 150</code></li>
<li><code>1 &lt;= columns &lt;= 150</code></li>
<li><code>0 &lt;= mat[i][j] &lt;= 1</code></li>
</ul>
<h2 id="🌸解法一、暴力"><a href="#🌸解法一、暴力" class="headerlink" title="🌸解法一、暴力"></a>🌸解法一、暴力</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubmat</span><span class="params">(<span class="keyword">int</span>[][] mat)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n=mat.length;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m= mat[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++){</span><br><span class="line">            <span class="comment">// i,j为左上角顶点,固定左上角,逐行遍历右下角</span></span><br><span class="line">            <span class="keyword">int</span> p=Integer.MAX_VALUE;<span class="comment">// 矩形右边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> a=i;a&lt;n;a++){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> b=j;b&lt;m&amp;&amp;b&lt;p;b++){</span><br><span class="line">                    <span class="comment">// a,b为右下角顶点</span></span><br><span class="line">                    <span class="keyword">if</span>(mat[a][b]==<span class="number">1</span>){</span><br><span class="line">                        ans++;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        p=b;<span class="comment">// 更新边界</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸解法二、动态规划（枚举）"><a href="#🌸解法二、动态规划（枚举）" class="headerlink" title="🌸解法二、动态规划（枚举）"></a>🌸解法二、动态规划（枚举）</h2><p>🍁首先很直观的想法,我们可以枚举矩阵中的每个位置(i, j),统计以其作为右下角时,有多少个元索全部都是1的子矩形，那么我们就能不重不漏地统计出满足条件的子矩形个数。那么枚举以后，我们怎么统计满足条件的子矩形个数呢?</p>
<p>既然是枚举以(i, j)作为右下角的子矩形个数,那么我们可以直接暴力地枚举左上角(k,y),看其组成的矩形是否满足条件,时间复杂度为O(nm)。但这样无疑会使得时间复杂度变得很高,我们需要另寻他路。</p>
<p>我们预处理row数组,中row[i] [j]代表矩阵中(i,j)向左延伸连续1的个数,容易得出递推式:<br>$$<br>row[i][j]=\begin{cases}0,&amp;\text{mat[i][j] = 0}\row[i][j - 1] + 1,&amp;\text{mat[i][j] = 1}\end{cases}<br>$$<br>有了row数组以后，如果要统计以(i, j)为右下角满足条件的子矩形,我们就可以枚举子矩形的高，即第k行，看当前高度有多少满足条件的子矩形。于我们知道第k行到第i行「每一行第j列向左延伸连续1的个数」row[k] [j],….row[i] [j],],因此我们可以知道第k行满足条件的子矩形个数就是这些值的最小值，它代表了「第 k行到第i行子形的宽的最大值」， 公式化来说，即:<code>min{row[l] [j]}(l = k...i)</code></p>
<p>因此我们倒序枚举k,用col变量来记录到当前行row的最小值，即能在0(n)的<br>时间内统计出以(i, j)为右下角满足条件的子矩形个数。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubmat1</span><span class="params">(<span class="keyword">int</span>[][] mat)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> n = mat.length;</span><br><span class="line">	<span class="keyword">int</span> m = mat[<span class="number">0</span>].length;</span><br><span class="line">	<span class="keyword">int</span>[][] row = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">			<span class="keyword">if</span>(j == <span class="number">0</span>) {</span><br><span class="line">				row[i][j] = mat[i][j];</span><br><span class="line">			}<span class="keyword">else</span> <span class="keyword">if</span>(mat[i][j] != <span class="number">0</span>) {</span><br><span class="line">				row[i][j] = row[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">			}<span class="keyword">else</span> {</span><br><span class="line">				row[i][j] = <span class="number">0</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">			<span class="keyword">int</span> col = row[i][j];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &gt;=<span class="number">0</span> &amp;&amp; col != <span class="number">0</span>; --k) {</span><br><span class="line">				col = Math.min(col, row[k][j]);</span><br><span class="line">				ans += col;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubmat</span><span class="params">(self, mat: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n, m = len(mat), len(mat[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        row = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                    row[i][j] = mat[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    row[i][j] = <span class="number">0</span> <span class="keyword">if</span> mat[i][j] == <span class="number">0</span> <span class="keyword">else</span> row[i][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                col = row[i][j]</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(i, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                    col = min(col, row[k][j])</span><br><span class="line">                    <span class="keyword">if</span> col == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    ans += col</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸解法三、单调栈"><a href="#🌸解法三、单调栈" class="headerlink" title="🌸解法三、单调栈"></a>🌸解法三、单调栈</h2><p>🍁单调栈是一种特殊的栈，它始终保证栈里的元素具有单调性,要么是单调递增， 要么是单调递减，在此题中我们需要维护一个存储row值的单调栈，满足从栈底到栈顶的元素单调递增。为什么会想到这么做?这因为我们会发现，最容易统计的情况是row[0..i] [j] 的值随行号单调递增，此时答案就是它们的和,但是如果遇到非递增的时候，即当前row[i] [j]小于当前row[i- 1] [j],此时无疑i- 1行row[i- 1] [j]- row[i] [j] 的部分我们是不再需要的，它对后面i+1,i+ 2,… ,n一1统计答案的时候都不会再用到，这个时候我们就可以抛弃掉这部分的值，然后再去看row[i] [j]和row[i - 2] [j] 的值,以此类推，直到row[j[j]的值大于当前单调栈栈顶的元素时结束,然后再推row[i] [j]. </p>
<p>这就是维护-一个单调栈的过程，但是还没完，我们不能简单地将不满足条件的值从栈里弹出，以上面第i- 1行举例，它有row[i] [j] 大小的部分是需要统计入答案的,<br>这个时候我们需要怎么做呢?</p>
<p>我们对单调栈存储的元素进行修改，改成存储-个二 元组(row[i] [j], height),示当<br>前矩形的宽和高，一开始我们放入的单调栈的都是高为 1宽为row[i] [j]的矩形，但碰到上面情况的时候，为了保留弹出元素中可用部分」的答案,我们需要将当前要推入栈中的元素的高加上弹出元素的高，于这个情况只会发生在推入元素小于栈顶元素的时候发生，因此矩形的宽一是当前推入元素的row值，同时我们再维护一个到当前行的答案和sum值即可。</p>
<p>通过单调栈的使用，我们就不再需要每次枚举的时候再重复倒序枚举k了,进一步优化了时间复杂度。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubmat2</span><span class="params">(<span class="keyword">int</span>[][] mat)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = mat.length;</span><br><span class="line">        <span class="keyword">int</span> m = mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] row = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) {</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) {</span><br><span class="line">                    row[i][j] = mat[i][j];</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (mat[i][j] != <span class="number">0</span>) {</span><br><span class="line">                    row[i][j] = row[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    row[i][j] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) { </span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            Deque&lt;<span class="keyword">int</span>[]&gt; Q = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">while</span> (i &lt;= n - <span class="number">1</span>) { </span><br><span class="line">                <span class="keyword">int</span> height = <span class="number">1</span>; </span><br><span class="line">                <span class="keyword">while</span> (!Q.isEmpty() &amp;&amp; Q.peekFirst()[<span class="number">0</span>] &gt; row[i][j]) {</span><br><span class="line">                  	<span class="comment">// 弹出的时候要减去多于的答案</span></span><br><span class="line">                    sum -= Q.peekFirst()[<span class="number">1</span>] * (Q.peekFirst()[<span class="number">0</span>] - row[i][j]); </span><br><span class="line">                    height += Q.peekFirst()[<span class="number">1</span>]; </span><br><span class="line">                    Q.pollFirst(); </span><br><span class="line">                } </span><br><span class="line">                sum += row[i][j]; </span><br><span class="line">                ans += sum; </span><br><span class="line">                Q.offerFirst(<span class="keyword">new</span> <span class="keyword">int</span>[]{row[i][j], height}); </span><br><span class="line">                i++; </span><br><span class="line">            } </span><br><span class="line">        } </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubmat</span><span class="params">(self, mat: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n, m = len(mat), len(mat[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        row = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                    row[i][j] = mat[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    row[i][j] = <span class="number">0</span> <span class="keyword">if</span> mat[i][j] == <span class="number">0</span> <span class="keyword">else</span> row[i][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            Q = list()</span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                height = <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> Q <span class="keyword">and</span> Q[<span class="number">-1</span>][<span class="number">0</span>] &gt; row[i][j]:</span><br><span class="line">                    <span class="comment"># 弹出的时候要减去多于的答案</span></span><br><span class="line">                    total -= Q[<span class="number">-1</span>][<span class="number">1</span>] * (Q[<span class="number">-1</span>][<span class="number">0</span>] - row[i][j])</span><br><span class="line">                    height += Q[<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">                    Q.pop()</span><br><span class="line">                total += row[i][j]</span><br><span class="line">                ans += total</span><br><span class="line">                Q.append((row[i][j], height))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法四、与运算"><a href="#🌸解法四、与运算" class="headerlink" title="🌸解法四、与运算"></a>🌸解法四、与运算</h2><p>🍁对于只有一行数组而言，比如[1,1,1,0,1,1,1,1,0,1]<br>前3个1,能组成3个1x1，2个1x2， 1个 1x3, - 共3+2+1=6种情况<br>中间4个1,能组成4个1x1, 3个1x2，2个1x3，1个1x4, -共4+3+2+1=10种情况<br>所以能找到-种规律，连续出现的n个1,可以组成1 +2+3+…+n种情况，使<br>公式，就是<code>n*(n+1)/2</code>种情况<br>上面是只有一行的情况。<br>对于2行而言，比如</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0,1,1,0,0,1,1,1,1</span><br><span class="line">0,0,1,0,1,0,0,1,1</span><br></pre></td></tr></tbody></table></figure>

<p>只有第3列能组成2x1，后两列能组成1个2x2,2个2x1,</p>
<p>我们可以发现，只有在同一列，全部都是1时才能起到作用，对于其他的地方,<br>1的存在是没有意义的,<br>这个结果和只有1行的[0, 0, 1 ,0,0, 0,0,1, 1]的结果是一样的。<br>2行变成1行，通过观察可以发现，可以使用与运算&amp;实现。<br>对于3行，4行，..n行同理，都可以转化成1行来计算。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubmat3</span><span class="params">(<span class="keyword">int</span>[][] mat)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat.length; i++) {</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[mat[i].length];</span><br><span class="line">        System.arraycopy(mat[i], <span class="number">0</span>, nums, <span class="number">0</span>, mat[i].length);</span><br><span class="line"></span><br><span class="line">        result += getRes(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; mat.length; j++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mat[j].length; ++k) {</span><br><span class="line">                nums[k] = nums[k] &amp; mat[j][k];</span><br><span class="line">            }</span><br><span class="line">            result += getRes(nums);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算1行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;     <span class="comment">//结果</span></span><br><span class="line">    <span class="keyword">int</span> continuous = <span class="number">0</span>;  <span class="comment">//连续出现的1的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) {</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) {</span><br><span class="line">            result += continuous * (continuous + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            continuous = <span class="number">0</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            continuous++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    result += continuous * (continuous + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>java</tag>
        <tag>python</tag>
        <tag>动态规划</tag>
        <tag>单调栈</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划_leetcode.337.打家劫舍3</title>
    <url>/Beating_up_the_house_and_robbing_the_house_3/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<a id="more"></a>

<p>示例 1:</p>
<p>输入: [3,2,3,null,3,null,1]</p>
<pre><code>  3
 / \
2   3
 \   \ 
  3   1</code></pre><p>输出: 7<br>解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题目本身就是动态规划的树形版本，通过此题解，可以了解一下树形问题在动态规划问题解法<br>我们通过三个方法不断递进解决问题</p>
<ul>
<li>解法一通过递归实现，虽然解决了问题，但是复杂度太高</li>
<li>解法二通过解决方法一中的重复子问题，实现了性能的百倍提升</li>
<li>解法三直接省去了重复子问题，性能又提升了一步</li>
</ul>
<h2 id="🌸解法一、暴力递归-最优子结构"><a href="#🌸解法一、暴力递归-最优子结构" class="headerlink" title="🌸解法一、暴力递归 - 最优子结构"></a>🌸解法一、暴力递归 - 最优子结构</h2><p>在解法一和解法二中，我们使用爷爷、两个孩子、4 个孙子来说明问题<br>首先来定义这个问题的状态<br>爷爷节点获取到最大的偷取的钱数呢</p>
<ul>
<li>首先要明确相邻的节点不能偷，也就是爷爷选择偷，儿子就不能偷了，但是孙子可以偷</li>
<li>二叉树只有左右两个孩子，一个爷爷最多 2 个儿子，4 个孙子<br>根据以上条件，我们可以得出单个节点的钱该怎么算</li>
</ul>
<p><strong>4 个孙子偷的钱 + 爷爷的钱 VS 两个儿子偷的钱 哪个组合钱多，就当做当前节点能偷的最大钱数。这就是动态规划里面的最优子结构</strong></p>
<p>由于是二叉树，这里可以选择计算所有子节点</p>
<p>4 个孙子投的钱加上爷爷的钱如下<br><code>int method1 = root.val + rob(root.left.left) + rob(root.left.right) + rob(root.right.left) + rob(root.right.right)</code><br>两个儿子偷的钱如下<br><code>int method2 = rob(root.left) + rob(root.right);</code><br>挑选一个钱数多的方案则<br><code>int result = Math.max(method1, method2);</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> money = root.val;</span><br><span class="line">	<span class="keyword">if</span>(root.left != <span class="keyword">null</span>) {</span><br><span class="line">		money += rob(root.left.left) + rob(root.left.right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(root.right != <span class="keyword">null</span>) {</span><br><span class="line">		money += rob(root.right.left) + rob(root.right.right);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> Math.max(money, rob(root.left) + rob(root.right));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸解法二、记忆化-解决重复子问题"><a href="#🌸解法二、记忆化-解决重复子问题" class="headerlink" title="🌸解法二、记忆化 - 解决重复子问题"></a>🌸解法二、记忆化 - 解决重复子问题</h2><p>针对解法一种速度太慢的问题，经过分析其实现，我们发现爷爷在计算自己能偷多少钱的时候，同时计算了 4 个孙子能偷多少钱，也计算了 2 个儿子能偷多少钱。这样在儿子当爷爷时，就会产生重复计算一遍孙子节点。</p>
<p>于是乎我们发现了一个动态规划的关键优化点</p>
<p><strong>重复子问题</strong></p>
<p>我们这一步针对重复子问题进行优化，我们在做斐波那契数列时，使用的优化方案是记忆化，但是之前的问题都是使用数组解决的，把每次计算的结果都存起来，下次如果再来计算，就从缓存中取，不再计算了，这样就保证每个数字只计算一次。<br>由于二叉树不适合拿数组当缓存，我们这次使用哈希表来存储结果，TreeNode 当做 key，能偷的钱当做 value</p>
<p>解法一加上记忆化优化后代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob1</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">	HashMap&lt;TreeNode, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="keyword">return</span> rob_dfs(root, map);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rob_dfs</span><span class="params">(TreeNode root, HashMap&lt;TreeNode, Integer&gt; map)</span> </span>{</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (map.containsKey(root)) {</span><br><span class="line">		<span class="keyword">return</span> map.get(root);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> money = root.val;</span><br><span class="line">	<span class="keyword">if</span> (root.left != <span class="keyword">null</span>) {</span><br><span class="line">		money += (rob_dfs(root.left.left, map) + rob_dfs(root.left.right, map));</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (root.right != <span class="keyword">null</span>) {</span><br><span class="line">		money += (rob_dfs(root.right.left, map) + rob_dfs(root.right.right, map));</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> result = Math.max(money, rob_dfs(root.left, map) + rob_dfs(root.right, map));</span><br><span class="line">	map.put(root, result);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法三、动态规划"><a href="#🌸解法三、动态规划" class="headerlink" title="🌸解法三、动态规划"></a>🌸解法三、动态规划</h2><p>上面两种解法用到了孙子节点，计算爷爷节点能偷的钱还要同时去计算孙子节点投的钱，虽然有了记忆化，但是还是有性能损耗。</p>
<p>我们换一种办法来定义此问题</p>
<p>每个节点可选择偷或者不偷两种状态，根据题目意思，相连节点不能一起偷</p>
<p>当前节点选择偷时，那么两个孩子节点就不能选择偷了<br>当前节点选择不偷时，两个孩子节点只需要拿最多的钱出来就行(两个孩子节点偷不偷没关系)<br>我们使用一个大小为 2 的数组来表示 int[] res = new int[2] 0 代表不偷，1 代表偷<br><strong>任何一个节点能偷到的最大钱的状态可以定义为</strong></p>
<ul>
<li>当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱</li>
<li>当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数</li>
</ul>
<p>公式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">root[0] = Math.max(rob(root.left)[0], rob(root.left)[1]) + Math.max(rob(root.right)[0], rob(root.right)[1])</span><br><span class="line">root[1] = rob(root.left)[0] + rob(root.right)[0] + root.val;</span><br></pre></td></tr></tbody></table></figure>

<p>将公式做个变换就是代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob2</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span>[] result = rob_dfs2(root);</span><br><span class="line">	<span class="keyword">return</span> Math.max(result[<span class="number">0</span>], result[<span class="number">1</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] rob_dfs2(TreeNode root) {</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span>[] left = rob_dfs2(root.left);</span><br><span class="line">	<span class="keyword">int</span>[] right = rob_dfs2(root.right);</span><br><span class="line">	result[<span class="number">0</span>] = Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">	result[<span class="number">1</span>] = left[<span class="number">0</span>] + right[<span class="number">0</span>] + root.val;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h3><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>DFS</tag>
        <tag>动态规划</tag>
        <tag>递归</tag>
        <tag>记忆化</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划_leetcode.309.最佳买卖股票时期含冷冻期</title>
    <url>/Best_time_to_buy_and_sell_stocks_including_freezing_period/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>示例:</p>
<a id="more"></a>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>对于力扣平台上的股票类型的题目：</p>
<ol start="121">
<li><p>买卖股票的最佳时机</p>
</li>
<li><p>买卖股票的最佳时机 II</p>
</li>
<li><p>买卖股票的最佳时机 III</p>
</li>
<li><p>买卖股票的最佳时机 IV</p>
</li>
</ol>
<p>（本题）309. 最佳买卖股票时机含冷冻期</p>
<ol start="714">
<li>买卖股票的最佳时机含手续费</li>
</ol>
<p>剑指 Offer 63. 股票的最大利润</p>
<p>这道题增加了冷冻期这样一个条件，也没有限制多少笔交易。因此只需要增加一个状态（表示当前这一天处在「冷冻期」）即可。注意：这里是增加一个状态，不是增加一维状态。</p>
<h3 id="第-1-步：状态定义"><a href="#第-1-步：状态定义" class="headerlink" title="第 1 步：状态定义"></a>第 1 步：状态定义</h3><p>dp [i] [j] 表示 [0, i] 区间内，在下标为 i 这一天状态为 j 时的最大收益。</p>
<p>这里 j 取三个值：</p>
<ul>
<li>0 表示不持股且当天没卖出,定义其最大收益dp[i] [0]；</li>
<li>1 表示持股，定义其最大收益dp[i] [1]；</li>
<li>2 表示不持股且当天卖出了，定义其最大收益dp[i][2]。</li>
</ul>
<h3 id="第-2-步：状态转移方程"><a href="#第-2-步：状态转移方程" class="headerlink" title="第 2 步：状态转移方程"></a>第 2 步：<strong>状态转移方程</strong></h3><ul>
<li><p>第i天不持股且没卖出的状态dp[i] [0]，也就是我没有股票，而且还不是因为我卖了它才没有的，那换句话说是从i-1天到第i天转移时，它压根就没给我股票！所以i-1天一定也是不持有，那就是不持有的两种可能：</p>
<ul>
<li>i-1天不持股且当天没有卖出dp[i-1] [0]；</li>
<li>i-1天不持股但是当天卖出去了dp[i-1] [2]；</li>
</ul>
</li>
<li><p>所以： dp[i] [0]=max(dp[i-1] [0],dp[i-1] [2])</p>
</li>
<li><p>第i天持股dp[i] [1]，今天我持股，来自两种可能：</p>
<p>1、要么是昨天我就持股，今天继承昨天的，也就是dp[i-1] [1]，这种可能很好理解；</p>
<p>2、要么是昨天我不持股，今天我买入的，但前提是昨天我一定没卖！因为如果昨天我卖了，那么今天我不能交易！也就是题目中所谓“冷冻期”的含义，只有昨天是“不持股且当天没卖出”这个状态，我今天才能买入！所以是dp[i-1] [0]-p[i]。所以： dp[i] [1]=max(dp[i-1] [1],dp[i-1] [0]-p[i])</p>
</li>
<li><p>i天不持股且当天卖出了，这种就简单了，那就是说昨天我一定是持股的，要不然我今天拿什么卖啊，而持股只有一种状态，昨天持股的收益加上今天卖出得到的新收益，就是dp[i-1] [1]+p[i]啦</p>
</li>
</ul>
<p>与之前股票问题的不同之处只在于：从不持股状态不能直接到持股状态，得经过一个冷冻期，才能到持股状态。</p>
<h3 id="第-3-步：思考初始化"><a href="#第-3-步：思考初始化" class="headerlink" title="第 3 步：思考初始化"></a>第 3 步：<strong>思考初始化</strong></h3><ul>
<li>在第 0 天，不持股的初始化值为 0，</li>
<li>持股的初始化值为 -prices[0]（表示购买了一股），</li>
<li>dp[0] [2]=0;//可以理解成第0天买入又卖出，那么第0天就是“不持股且当天卖出了”这个状态了,其收益为0，所以初始化为0是合理</li>
</ul>
<h3 id="第-4-步：思考输出"><a href="#第-4-步：思考输出" class="headerlink" title="第 4 步：思考输出"></a>第 4 步：思考输出</h3><p>最后一天的最大收益有两种可能，而且一定是“不持有”状态下的两种可能，把这两种“不持有”比较一下大小，返回即可</p>
<p>参考代码： </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> len = prices.length;</span><br><span class="line">	<span class="keyword">if</span>(len &lt; <span class="number">2</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">3</span>];</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) {</span><br><span class="line">		dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">		dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">		dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i];</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> Math.max(dp[len - <span class="number">1</span>][<span class="number">0</span>], dp[len - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="第-5-步：思考空间优化"><a href="#第-5-步：思考空间优化" class="headerlink" title="第 5 步：思考空间优化"></a>第 5 步：<strong>思考空间优化</strong></h3><p>​    由于当前天只参考了昨天的状态值，因此可以考虑使用「滚动数组」。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit1</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> len = prices.length;</span><br><span class="line">	<span class="keyword">if</span>(len &lt; <span class="number">2</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) {</span><br><span class="line">		dp[i &amp; <span class="number">1</span>][<span class="number">0</span>] = Math.max(dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][<span class="number">0</span>], dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">		dp[i &amp; <span class="number">1</span>][<span class="number">1</span>] = Math.max(dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][<span class="number">1</span>], dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">		dp[i &amp; <span class="number">1</span>][<span class="number">2</span>] = dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][<span class="number">1</span>] + prices[i];</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> Math.max(dp[(len - <span class="number">1</span>) &amp; <span class="number">1</span>][<span class="number">0</span>], dp[(len - <span class="number">1</span>) &amp; <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>由于状态值就 3 个，并且只关心最后 1 天的状态值，还可以使用滚动变量的方式把状态表格优化到一行。</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit2</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> len = prices.length;</span><br><span class="line">	<span class="keyword">if</span>(len &lt; <span class="number">2</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">	dp[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">int</span> preCash = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> preStock = dp[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) {</span><br><span class="line">		dp[<span class="number">0</span>] = Math.max(preCash, dp[<span class="number">2</span>]);</span><br><span class="line">		dp[<span class="number">1</span>] = Math.max(preStock, preCash - prices[i]);</span><br><span class="line">		dp[<span class="number">2</span>] = preStock + prices[i];</span><br><span class="line">		</span><br><span class="line">        preCash = dp[<span class="number">0</span>];</span><br><span class="line">        preStock = dp[<span class="number">1</span>];</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> Math.max(dp[<span class="number">0</span>], dp[<span class="number">2</span>]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h3><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划_leetcode.120.三角形最小路径和</title>
    <url>/Minimum_path_sum_of_triangles/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">例如，给定三角形：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">   [2],</span><br><span class="line">  [3,4],</span><br><span class="line"> [6,5,7],</span><br><span class="line">[4,1,8,3]</span><br><span class="line">]</span><br><span class="line">自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</span><br></pre></td></tr></tbody></table></figure>

<p>说明：</p>
<a id="more"></a>

<p><code>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</code></p>
<h2 id="🌸分析"><a href="#🌸分析" class="headerlink" title="🌸分析"></a>🌸分析</h2><p>本题是一道非常经典且历史悠久的动态规划题，其作为算法题出现，最早可以追溯到 1994 年的 IOI（国际信息学奥林匹克竞赛）的 The Triangle。时光飞逝，经过 20 多年的沉淀，往日的国际竞赛题如今已经变成了动态规划的入门必做题，不断督促着我们学习和巩固算法。</p>
<p>这道题当我看到自顶向下四个字就知道是动态规划类题目，然而首先读完题在脑海里的却是深度优先DFS（暴力搜索解法），若定义 <code>f(i, j)</code> 为 <code>(i, j)</code>点到底边的最小路径和，则易知递归求解式为:</p>
<p><code>f(i, j) = min(f(i + 1, j), f(i + 1, j + 1)) + triangle [  i ] [ j ]</code></p>
<p>由此，我们将任一点到底边的最小路径和，转化成了与该点相邻两点到底边的最小路径和中的较小值，再加上该点本身的值。这样本题的 递归解法（解法一） 就完成了。最终超时，果然还是得动态规划呀</p>
<h2 id="解法一：DFS递归-暴力解法"><a href="#解法一：DFS递归-暴力解法" class="headerlink" title="解法一：DFS递归/暴力解法"></a>解法一：DFS递归/暴力解法</h2><blockquote>
<p>暴力求解，不解释。</p>
<p>暴力搜索会有大量的重复计算，导致 <strong>超时</strong>，因此在 <strong>解法二</strong> 中结合记忆化数组进行优化。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> dfs(triangle, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>{</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="keyword">if</span>(rows == triangle.size()) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> Math.min(dfs(triangle, rows + <span class="number">1</span>, cols), dfs(triangle, rows + <span class="number">1</span>, cols + <span class="number">1</span>)) + triangle.get(rows).get(cols);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="解法二：递归-记忆化"><a href="#解法二：递归-记忆化" class="headerlink" title="解法二：递归+记忆化"></a>解法二：递归+记忆化</h2><blockquote>
<p>在解法一的基础上，定义了二维数组进行记忆化。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Integer[][] memory;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal2</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>{</span><br><span class="line">	memory = <span class="keyword">new</span> Integer[triangle.size()][triangle.size()];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> dfs2(triangle, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>{</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="keyword">if</span>(rows == triangle.size()) {</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(memory[rows][cols] != <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">return</span> memory[rows][cols];</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> memory[rows][cols] = Math.min(dfs2(triangle, rows + <span class="number">1</span>, cols), dfs2(triangle, rows + <span class="number">1</span>, cols + <span class="number">1</span>)) + triangle.get(rows).get(cols);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="解法三：-自顶向下的动态规划"><a href="#解法三：-自顶向下的动态规划" class="headerlink" title="解法三： 自顶向下的动态规划"></a>解法三： 自顶向下的动态规划</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们用<code>f[i] [j]</code>示从三形顶部走到位置<code>(i, j)</code>的最小路径和。这里的位置<code>(i,j)</code>指的是三角形中第 i行第 j列(均从0开始编号)的位置。于每-织能移动到下一行「相邻的节点，上, 因此要想走到位置<code>(i,j)</code>,上一步就只能在位置<code>(i- 1,j- 1)</code>或者位置<code>(i-1,j)</code>。我们在这两个位置中选择一个路径和较小的来进行转移, 状态转移方程为:<br><code>f[i] [j]= min(f[i- 1] [j- 1],f[i- 1] [j]) + c[i] [j]</code><br><code>c[i] [j]</code>示位置(i, j)对应的元素值。注意第i行有i+ 1个元素,它们对应的j的范围为<code>[0,i]</code>。当 j=0或j= i时, .上述状态转移方程中有一 些项是没有意义的。例如当j = 0时，<code>f[i- 1] [j- 1]</code>没有意义，因此状态转移方程为:<code>f[i] [0]= f[i- 1] [0]+c[i] [0]</code>即当我们在第i行的最左侧时，我们只能从第<code>i - 1</code> 行的最左侧移动过来。当<code>j=i</code>时<code>, f[i- 1][j]</code>没有意义，因此状态转移方程为:</p>
<p><code>f[i] [i]= f[i-1] [i- 1] + c[i] [i]</code><br>即当我们在第i行的最右侧时,我们只能从第i - 1行的最右侧移动过来。<br>最终的答案即为<code>f[n- 1] [0]</code> 到<code>f[n- 1 ] [n- 1]</code>中的最大值,n .是三角形的行数。</p>
<h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><blockquote>
<p>状态转移方程的边界条件是什么?于我们已经却除了所有没有意义」<br>的状态，因此边界条件可以定为:<br><code>f[0][0] = c[0][0]</code><br>即在三角形的顶部时，最小路径和就等于对应位置的元素值。这样一来,<br>我们从1开始递增地枚举i,并在<code>[0, i]</code>的范围内递增地枚举j,就可以<br>完成所有状态的计算。</p>
</blockquote>
<p><strong>java</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">    <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) {</span><br><span class="line">        f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) {</span><br><span class="line">            f[i][j] = Math.min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + triangle.get(i).get(j);</span><br><span class="line">        }</span><br><span class="line">        f[i][i] = f[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle.get(i).get(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> minTotal = f[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) {</span><br><span class="line">        minTotal = Math.min(minTotal, f[n - <span class="number">1</span>][i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> minTotal;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>python</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">     n = len(triangle)</span><br><span class="line">     f = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">     f[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">         f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][<span class="number">0</span>]</span><br><span class="line">         <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i):</span><br><span class="line">             f[i][j] = min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + triangle[i][j]</span><br><span class="line">         f[i][i] = f[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle[i][i]</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> min(f[n - <span class="number">1</span>])</span><br></pre></td></tr></tbody></table></figure>

<h2 id="解法四：-自顶向下的空间优化"><a href="#解法四：-自顶向下的空间优化" class="headerlink" title="解法四： 自顶向下的空间优化"></a>解法四： 自顶向下的空间优化</h2><p>我们从i到0递减地枚举j,这样我们只要一个长度为n的一维数组f,就可以完成状态转移。</p>
<p>为什么只有在递减地枚举j时，才能省去一个一维数组?当我们在计算位置<code>(i,j)</code>时, <code>f[j+ 1]</code>到<code>f[i]</code>是第i行的值，而<code>f[0]</code>到<code>f[i]</code>仍然是第i一1行的值。此时我们直接通过</p>
<ul>
<li><code>f[j] = min(f[j - 1],f[j])+ c[i[j]</code></li>
</ul>
<p>进行转移,恰好就是在<code>(i - 1,j - 1)</code>和<code>(i- 1,j)</code>中进行选择。但如果我们递增地枚举j,那么在计算位置<code>(i,j)</code>时，<code>f(0)</code>到<code>f[j - 1]</code>经是第i行的值。如果我]仍然使用上述状态转移方程，那么是在<code>(i,j-1)</code>和<code>(i- 1,i)</code>中进行选择,就产生了错误。</p>
<p>这样虽然空间复杂度仍然为0(n),但我们只使用了n的空间存储状态,<br>减少了一半的空间消耗。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        f[<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) {</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + triangle.get(i).get(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span>; --j) {</span><br><span class="line">                f[j] = Math.min(f[j - <span class="number">1</span>], f[j]) + triangle.get(i).get(j);</span><br><span class="line">            }</span><br><span class="line">            f[<span class="number">0</span>] += triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> minTotal = f[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) {</span><br><span class="line">            minTotal = Math.min(minTotal, f[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> minTotal;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p><strong>python</strong> </p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    n = len(triangle)</span><br><span class="line">    f = [<span class="number">0</span>] * n</span><br><span class="line">    f[<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + triangle[i][i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            f[j] = min(f[j - <span class="number">1</span>], f[j]) + triangle[i][j]</span><br><span class="line">        f[<span class="number">0</span>] += triangle[i][<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> min(f)</span><br></pre></td></tr></tbody></table></figure>



<h2 id="解法五：自底向上的动态规划"><a href="#解法五：自底向上的动态规划" class="headerlink" title="解法五：自底向上的动态规划"></a>解法五：自底向上的动态规划</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p>定义二维 dp 数组，将解法二中「自顶向下的递归」改为「自底向上的递推」。</p>
<p><code>dp[i][j]</code>表示从点 <code>(i, j)</code>到底边的最小路径和。</p>
<p>状态转移:<br><code>dp[i][j] = min(dp[i+ 1][i],dp[i + 1][j + 1]) + triangle[i][j]</code>[][j]</p>
</blockquote>
<p><strong>java</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal3</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> len = triangle.size();</span><br><span class="line">	<span class="comment">//dp[i][j]表示从点（i，j)到底边的最小路径和</span></span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>][len + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">//从三角形的最后一行开始递推</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) {</span><br><span class="line">			dp[i][j] = Math.min(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="解法五：自底向上的动态规划-空间优化"><a href="#解法五：自底向上的动态规划-空间优化" class="headerlink" title="解法五：自底向上的动态规划+空间优化"></a>解法五：自底向上的动态规划+空间优化</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p>在上述代码中，我们定义了-一个N行N列的dp数组(N三角形的行数)<br>但是在实际递推中我们发现，计算<code>dp[i][j]</code>时，只用到了下一行的dp[i+ 1][j]和<code>dp[i+ 1][j+ 1]</code>。<br>因此dp数组不需要定义N行,只要定义1行就阔以。<br>所以我们稍微修改一下上述代码,将i所在的维度去掉(如下)，就可以<br>将O(N^2^)的空间复杂度优化成O(N)</p>
</blockquote>
<p><strong>java</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal4</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> len = triangle.size();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">//从三角形的最后一行开始递推</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) {</span><br><span class="line">			dp[j] = Math.min(dp[j], dp[j + <span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>python</tag>
        <tag>DFS</tag>
        <tag>深度优先搜索</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划_leetcode.64.最小路径和</title>
    <url>/Minimum_path_sum/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>示例:</p>
<a id="more"></a>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br></pre></td></tr></tbody></table></figure>


<p>解释: 因为路径 1→3→1→1→1 的总和最小。</p>
<h2 id="🌸分析"><a href="#🌸分析" class="headerlink" title="🌸分析"></a>🌸分析</h2><p>由于路径的方向只能是向下或向右，<strong>因此网格的第一行的每个元素只能从左上角元素开始向右移动到达，网格的第一列的每个元素只能从左上角元素开始向下移动到达，此时的路径是唯一的</strong>，因此每个元素对应的最小路径和即为对应的路径上的数字总和。</p>
<p>对于不在第一行和第一列的元素，可以从其上方相邻元素向下移动一步到达，或者从其左方相邻元素向右移动一步到达，元素对应的最小路径和等于其上方相邻元素与其左方相邻元素两者对应的最小路径和中的最小值加上当前元素的值。由于每个元素对应的最小路径和与其相邻元素对应的最小路径和有关，因此可以使用动态规划求解。</p>
<p>状态定义：</p>
<ul>
<li>设 dp为大小 m<em>×</em>n矩阵，其中 dp[i] [j]的值代表直到走到 (i,j)的最小路径和。</li>
</ul>
<p>初始状态：</p>
<ul>
<li><code>dp[0][0] =grid[0][0]</code></li>
</ul>
<h2 id="🌸算法流程"><a href="#🌸算法流程" class="headerlink" title="🌸算法流程"></a>🌸算法流程</h2><ul>
<li>当i&gt;0且j=0时，<code>dp[i] [0]= dp[i - 1] [0]+ grid[i] [0].</code></li>
<li>当i=0且j&gt; 0时，<code>dp[0][j]= dp[0][j - 1]+ grid[0][ij]。</code></li>
<li>当i&gt;0且j&gt; 0时，<code>dp[i[i] = min(dp[i - 1][j], dp[i[ji -1]) + gridi[j]。</code></li>
<li>后得到<code>dp[m- 1][n - 1]</code>的值即为从网格左上角到网格右下的最小<br>路径和。</li>
</ul>
<p>其实我们完全不需要建立 dp矩阵浪费额外空间，直接遍历 <code>grid[i][j]</code>修改即可。这是因为：<code>grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j]</code> ；原 grid矩阵元素中被覆盖为 dp 元素后（都处于当前遍历点的左上方），不会再被使用到。</p>
<h2 id="🌸复杂度分析"><a href="#🌸复杂度分析" class="headerlink" title="🌸复杂度分析"></a>🌸复杂度分析</h2><ul>
<li><p>时间复杂度O(M×N) ： 遍历整个 grid 矩阵元素。</p>
</li>
<li><p>空间复杂度 O(1) ： 直接修改原矩阵，不使用额外空间。</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>{</span><br><span class="line">	 <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) {</span><br><span class="line">		 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	 }</span><br><span class="line">	 </span><br><span class="line">	 <span class="keyword">int</span> rows = grid.length, cols = grid[<span class="number">0</span>].length;</span><br><span class="line">	 <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">	 dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">	 </span><br><span class="line">	 <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) {</span><br><span class="line">		 <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) {</span><br><span class="line">			 <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) {</span><br><span class="line">				 <span class="keyword">continue</span>;</span><br><span class="line">			 }<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>) {</span><br><span class="line">				 dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">			 }<span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) {</span><br><span class="line">				 dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">			 }<span class="keyword">else</span> {</span><br><span class="line">				 dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">			 }</span><br><span class="line">		 }</span><br><span class="line">	 }</span><br><span class="line">	 </span><br><span class="line">	 <span class="keyword">return</span> dp[rows - <span class="number">1</span>][cols - <span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>python</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        rows, columns = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>] * columns <span class="keyword">for</span> _ <span class="keyword">in</span> range(rows)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, rows):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, columns):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, columns):</span><br><span class="line">                dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[rows - <span class="number">1</span>][columns - <span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸不使用dp数组。直接原地修改"><a href="#🌸不使用dp数组。直接原地修改" class="headerlink" title="🌸不使用dp数组。直接原地修改"></a>🌸不使用dp数组。直接原地修改</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum2</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>{</span><br><span class="line">	 <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) {</span><br><span class="line">		 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	 }</span><br><span class="line">	 </span><br><span class="line">	 <span class="keyword">int</span> rows = grid.length, cols = grid[<span class="number">0</span>].length;</span><br><span class="line">	 </span><br><span class="line">	 <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) {</span><br><span class="line">		 <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) {</span><br><span class="line">			 <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) {</span><br><span class="line">				 <span class="keyword">continue</span>;</span><br><span class="line">			 }<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>) {</span><br><span class="line">				 grid[<span class="number">0</span>][j] = grid[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">			 }<span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) {</span><br><span class="line">				 grid[i][<span class="number">0</span>] = grid[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">			 }<span class="keyword">else</span> {</span><br><span class="line">				 grid[i][j] = Math.min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">			 }</span><br><span class="line">		 }</span><br><span class="line">	 }</span><br><span class="line">	 </span><br><span class="line">	 <span class="keyword">return</span> grid[rows - <span class="number">1</span>][cols - <span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>python</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: [[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> i == j == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">0</span>:  grid[i][j] = grid[i][j - <span class="number">1</span>] + grid[i][j]</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:  grid[i][j] = grid[i - <span class="number">1</span>][j] + grid[i][j]</span><br><span class="line">                <span class="keyword">else</span>: grid[i][j] = min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]) + grid[i][j]</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>python</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>递归_leetcode.151-剑指offer.07_重建二叉树(从先序和中序)</title>
    <url>/Reconstruction_of_binary_tree/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>例如，给出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">前序遍历 preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br></pre></td></tr></tbody></table></figure>

<p>返回如下的二叉树：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></tbody></table></figure>

<p><strong>限制：</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0 &lt;= 节点个数 &lt;= 5000</span><br></pre></td></tr></tbody></table></figure>

<h2 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h2><p><strong>🍁思路</strong></p>
<p>对于任意一颗树而言，前序遍历的形式总是</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</span><br></pre></td></tr></tbody></table></figure>

<p>即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</span><br></pre></td></tr></tbody></table></figure>

<p>只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。</p>
<p>这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p>
<p><strong>🍁细节</strong></p>
<p>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希映射（HashMap）来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要O(1) 的时间对根节点进行定位了。</p>
<p><a href="https://imgchr.com/i/aVzPQe" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/29/aVzPQe.png" alt="aVzPQe.png"></a></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	TreeNode left;</span><br><span class="line">	TreeNode right;</span><br><span class="line"></span><br><span class="line">	TreeNode(<span class="keyword">int</span> x) {</span><br><span class="line">		val = x;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> preLen = preorder.length;</span><br><span class="line">		<span class="keyword">int</span> inLen = inorder.length;</span><br><span class="line">		<span class="keyword">if</span> (preLen != inLen) {</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Incorrect input data."</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">// 构建哈希映射，快速定位根节点</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; preLen; i++) {</span><br><span class="line">			map.put(inorder[i], i);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> buildTree(preorder, <span class="number">0</span>, preLen - <span class="number">1</span>, inorder, <span class="number">0</span>, inLen - <span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preLeft, <span class="keyword">int</span> preRight, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inLeft, <span class="keyword">int</span> inRight)</span> </span>{</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">// 递归结束条件</span></span><br><span class="line">		<span class="keyword">if</span> (preLeft &gt; preRight || inLeft &gt; inRight) {</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">// 先序遍历的起点元素为根节点</span></span><br><span class="line">		<span class="keyword">int</span> pre_root = preorder[preLeft];</span><br><span class="line">		<span class="comment">// 定位中序遍历中的根节点的下标</span></span><br><span class="line">		<span class="keyword">int</span> in_root = map.get(pre_root);</span><br><span class="line">		<span class="comment">// 将根节点建立起来</span></span><br><span class="line">		TreeNode root = <span class="keyword">new</span> TreeNode(pre_root);</span><br><span class="line">		<span class="comment">// 先序遍历中「从 左边界+1 开始的 in_root-inLeft(即左子树元素的个数)」个元素就对应了中序遍历中「从 左边界 开始到</span></span><br><span class="line">		<span class="comment">// 根节点定位-1」的元素</span></span><br><span class="line">		root.left = buildTree(preorder, preLeft + <span class="number">1</span>, in_root - inLeft + preLeft, inorder, inLeft, in_root - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span></span><br><span class="line">		root.right = buildTree(preorder, in_root - inLeft + preLeft + <span class="number">1</span>, preRight, inorder, in_root + <span class="number">1</span>, inRight);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">myBuildTree</span><span class="params">(preorder_left: int, preorder_right: int, inorder_left: int, inorder_right: int)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> preorder_left &gt; preorder_right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 前序遍历中的第一个节点就是根节点</span></span><br><span class="line">            preorder_root = preorder_left</span><br><span class="line">            <span class="comment"># 在中序遍历中定位根节点</span></span><br><span class="line">            inorder_root = index[preorder[preorder_root]]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 先把根节点建立出来</span></span><br><span class="line">            root = TreeNode(preorder[preorder_root])</span><br><span class="line">            <span class="comment"># 得到左子树中的节点数目</span></span><br><span class="line">            size_left_subtree = inorder_root - inorder_left</span><br><span class="line">            <span class="comment"># 递归地构造左子树，并连接到根节点</span></span><br><span class="line">            <span class="comment"># 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span></span><br><span class="line">            root.left = myBuildTree(preorder_left + <span class="number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 递归地构造右子树，并连接到根节点</span></span><br><span class="line">            <span class="comment"># 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span></span><br><span class="line">            root.right = myBuildTree(preorder_left + size_left_subtree + <span class="number">1</span>, preorder_right, inorder_root + <span class="number">1</span>, inorder_right)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        n = len(preorder)</span><br><span class="line">        <span class="comment"># 构造哈希映射，帮助我们快速定位根节点</span></span><br><span class="line">        index = {element: i <span class="keyword">for</span> i, element <span class="keyword">in</span> enumerate(inorder)}</span><br><span class="line">        <span class="keyword">return</span> myBuildTree(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>



<h2 id="解法二：-迭代"><a href="#解法二：-迭代" class="headerlink" title="解法二： 迭代"></a>解法二： 迭代</h2><p><strong>🍁思路</strong></p>
<p>迭代法是一种非常巧妙的实现方法。</p>
<p>对于前序遍历中的任意两个连续节点 u 和 v，根据前序遍历的流程，我们可以知道 u 和 v 只有两种可能的关系：</p>
<ul>
<li><p>v 是 u 的左儿子。这是因为在遍历到 u 之后，下一个遍历的节点就是 u 的左儿子，即 v；</p>
</li>
<li><p>u 没有左儿子，并且 v 是 u 的某个祖先节点（或者 u 本身）的右儿子。如果 u 没有左儿子，那么下一个遍历的节点就是 u 的右儿子。如果 u 没有右儿子，我们就会向上回溯，直到遇到第一个有右儿子（且 u 不在它的右儿子的子树中）的节点$$u_a$$，那么 v 就是 $$u_a$$ 的右儿子。</p>
</li>
</ul>
<p>第二种关系看上去有些复杂。我们举一个例子来说明其正确性，并在例子中给出我们的迭代算法。</p>
<p>我们以树</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">        3</span><br><span class="line">       / \</span><br><span class="line">      9  20</span><br><span class="line">     /  /  \</span><br><span class="line">    8  15   7</span><br><span class="line">   / \</span><br><span class="line">  5  10</span><br><span class="line"> /</span><br><span class="line">4</span><br></pre></td></tr></tbody></table></figure>

<p>为例，它的前序遍历和中序遍历分别为</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">preorder = [3, 9, 8, 5, 4, 10, 20, 15, 7]</span><br><span class="line">inorder = [4, 5, 8, 10, 9, 3, 15, 20, 7]</span><br></pre></td></tr></tbody></table></figure>

<p>我们用一个栈stack来维护「当前节点的所有还没有考虑过右儿子的祖先节<br>点,栈顶就是当前节点。也就是说，只有在栈中的节点可能连接一个新的右<br>子。同时,我们用一个指针index 指向中序遍历的某个位置， 初始值为<br>0。index对应的节点是「 当前节点不断往左走达到的最终节点，这也是符<br>合序遍历的，它的作用在下面的过程中会有所体现。</p>
<p>首先我们将根节点3入栈，再初始化 index 所指向的节点为4，随后对于前序遍历中的每个节点，我们依此判断它是栈顶节点的左儿子，还是栈中某个节点的右儿子。</p>
<ul>
<li><p>我们遍历9。9一定是栈顶节点3的左儿子。我们使用反证法，假设9是3的右子,那么3没有左儿子，index 应该恰好指向3,但实际上为4，因此产生了矛盾。所以我们将9作伪3的左儿子,并将9入栈。</p>
<ul>
<li><code>stack= [3， 9]</code></li>
<li><code>index -&gt; inorder[0] = 4</code></li>
</ul>
</li>
<li><p>我们遍历8，5和4。同理可得它们都是上一个节点(栈顶节点)的左<br>儿子,所以它们会依次入栈。</p>
<ul>
<li><code>stack=[3, 9，8，5，4]</code></li>
<li><code>index -&gt; inorder[0] = 4</code></li>
</ul>
</li>
<li><p>我们遍历10 ，这时情况就不-样了。我们发现index 恰好指向当前的栈顶节点4,也就是说4没有左儿子，那么10必须为栈中某个节点的右子。那么如何找到这个节点呢?栈中的节点的顺序和它们在前序遍历中出现的顺序是一致的， 且每一个节点的右儿子都还没有被遍历过，<strong>那么这些节点的顺序和它们在中序遍历中出现的顺序一定是相反的</strong>。</p>
<blockquote>
<p>这是因为栈中的任意两个相邻的节点，前者都是后者的某个祖先。并且我们知道，栈中的任意一个节点的右儿子还没有被遍历过，说明后者一定是前者左儿子的子树中的节点，那么后者就先于前者出现在中序遍历中。</p>
</blockquote>
<p>因此我们可以把index 不断向右移动， 并与栈顶节点进行比较。如果<br>index对应的元素恰好等于栈顶节点，那么说明我们在中序遍历中找到了<br>栈顶节点，所以将index增加1并弹出栈顶节点，直到index 对应的元素不等于栈顶节点。按照这样的过程，我们弹出的最后-一个节点x就是10的双亲节点，这是因为10 出现在了x与x在栈中的下一个节点的中序遍历之间，因呲10就是x的右子。</p>
</li>
</ul>
<p>  回到我们的例子，我们会依次从栈顶弹出4，5和8，并且将index向右移动了三次。我们将10作为最后弹出的节点8的右儿子，并將10入栈。</p>
<ul>
<li>stack = [3, 9，10]</li>
<li>index -&gt; inorder[3] = 10</li>
</ul>
<ul>
<li><p>我们遍历20。同理，index 恰好指向当前栈顶节点10，那么我们会依次从栈顶弹出| 10，9和3,并且将index 向右移动了三次。我们将20作为最后弹出的节点3的右儿子,并将20入栈。</p>
<ul>
<li><code>stack = [20]</code></li>
<li><code>index -&gt; inorder[6] = 15</code></li>
</ul>
</li>
<li><p>我们遍历15，将| 15作为栈顶节点20的左儿子，并將15入栈。</p>
<ul>
<li><code>stack = [20， 15]</code></li>
<li><code>index -&gt; inorder[6] = 15</code></li>
</ul>
</li>
<li><p>我们遍历7。1 index 恰好指向当前栈顶节点15 ，那么我们会依次从栈顶弹出15和20，并且将index 向右移动了两次。我们将7作为最后弹出的节点20 的右儿子，將7入栈。</p>
<ul>
<li><code>stack = [7]</code></li>
<li><code>index -&gt; inorder[8] = 7</code></li>
</ul>
</li>
</ul>
<p>此时遍历结束，我们就构造出了正确的二叉树。</p>
<p><strong>🍁算法</strong></p>
<p>我们归纳出上述例子中的算法流程:</p>
<ul>
<li>我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点(前序遍历的第一个节点) ，指针指向中序遍历的第一个节点;</li>
<li>我们依次枚举前遍历中除了第一个节点以外的每个节点。 如果index 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动index ，并将当前节点作为最后一个弹出的节点的右儿子;如果index 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子;</li>
<li>无论是哪一种情况，我们最后都将当前的节点入栈。</li>
</ul>
<p>后得到的二叉树即为答案。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (preorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">int</span> inorderIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; preorder.length; i++) {</span><br><span class="line">            <span class="keyword">int</span> preorderVal = preorder[i];</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (node.val != inorder[inorderIndex]) {</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(preorderVal);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) {</span><br><span class="line">                    node = stack.pop();</span><br><span class="line">                    inorderIndex++;</span><br><span class="line">                }</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(preorderVal);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>深度优先搜索</tag>
        <tag>递归</tag>
        <tag>中序遍历</tag>
        <tag>先序遍历</tag>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>递归_leetcode.114.二叉树展开为链表</title>
    <url>/Binary_tree_expanded_into_linked_list/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给定一个二叉树，原地将它展开为一个单链表。</p>
<p>例如，给定二叉树</p>
<pre><code>    1
   / \
  2   5
 / \   \
3   4   6</code></pre><p>将其展开为</p>
<a id="more"></a>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></tbody></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题需要将二叉树转化为列表，对于二叉树的题目，无非就以下几种解题思路：</p>
<ul>
<li>先序遍历（深度优先搜索）</li>
<li>中序遍历（深度优先搜索）（尤其二叉搜索树）</li>
<li>后序遍历（深度优先搜索）</li>
<li>层序遍历（广度优先搜索）（尤其按照层来解决问题的时候）</li>
<li>序列化与反序列化（结构唯一性问题）</li>
</ul>
<h2 id="解法一：暴力（常规思路）"><a href="#解法一：暴力（常规思路）" class="headerlink" title="解法一：暴力（常规思路）"></a>解法一：暴力（常规思路）</h2><p>可以发现展开的顺序其实就是二叉树的先序遍历，我们需要两步完成这道题。</p>
<ul>
<li>将左子树插入到右子树的地方</li>
<li>将原来的右子树接到左子树的最右边节点</li>
<li>考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null</li>
<li>可以看图理解下这个过程。</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br><span class="line"></span><br><span class="line">//将 1 的左子树插入到右子树的地方</span><br><span class="line">    1</span><br><span class="line">     \</span><br><span class="line">      2         5</span><br><span class="line">     / \         \</span><br><span class="line">    3   4         6        </span><br><span class="line">//将原来的右子树接到左子树的最右边节点</span><br><span class="line">    1</span><br><span class="line">     \</span><br><span class="line">      2          </span><br><span class="line">     / \          </span><br><span class="line">    3   4  </span><br><span class="line">         \</span><br><span class="line">          5</span><br><span class="line">           \</span><br><span class="line">            6</span><br><span class="line">            </span><br><span class="line"> //将 2 的左子树插入到右子树的地方</span><br><span class="line">    1</span><br><span class="line">     \</span><br><span class="line">      2          </span><br><span class="line">       \          </span><br><span class="line">        3       4  </span><br><span class="line">                 \</span><br><span class="line">                  5</span><br><span class="line">                   \</span><br><span class="line">                    6   </span><br><span class="line">        </span><br><span class="line"> //将原来的右子树接到左子树的最右边节点</span><br><span class="line">    1</span><br><span class="line">     \</span><br><span class="line">      2          </span><br><span class="line">       \          </span><br><span class="line">        3      </span><br><span class="line">         \</span><br><span class="line">          4  </span><br><span class="line">           \</span><br><span class="line">            5</span><br><span class="line">             \</span><br><span class="line">              6         </span><br><span class="line">  </span><br><span class="line">  ......</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">	<span class="keyword">while</span>(root != <span class="keyword">null</span>) {</span><br><span class="line">		<span class="comment">//左子树为空直接考虑下一个节点</span></span><br><span class="line">		<span class="keyword">if</span>(root.left == <span class="keyword">null</span>) {</span><br><span class="line">			root = root.right;</span><br><span class="line">		}<span class="keyword">else</span> {</span><br><span class="line">			<span class="comment">//找左子树最右边的节点</span></span><br><span class="line">			TreeNode pre = root.left;</span><br><span class="line">			<span class="keyword">while</span>(pre.right != <span class="keyword">null</span>) {</span><br><span class="line">				pre = pre.right;</span><br><span class="line">			}</span><br><span class="line">			<span class="comment">//将原来的右子树接到左子树的最右边的节点</span></span><br><span class="line">			pre.right = root.right;</span><br><span class="line">			<span class="comment">//将左子树插入到右子树的地方</span></span><br><span class="line">			root.right = root.left;</span><br><span class="line">			root.left = <span class="keyword">null</span>;</span><br><span class="line">			<span class="comment">//考虑下一个节点</span></span><br><span class="line">			root = root.right;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="解法二：-深度递归搜索"><a href="#解法二：-深度递归搜索" class="headerlink" title="解法二： 深度递归搜索"></a>解法二： 深度递归搜索</h2><p>其实是分为三步：</p>
<ul>
<li>首先将根节点的左子树变成链表</li>
<li>其次将根节点的右子树变成链表</li>
<li>最后将变成链表的右子树放在变成链表的左子树的最右边</li>
</ul>
<p>这就是一个递归的过程，递归的一个非常重要的点就是：不去管函数的内部细节是如何处理的，我们只看其函数作用以及输入与输出。对于函数flatten来说：</p>
<ul>
<li>函数作用：将一个二叉树，原地将它展开为链表</li>
<li>输入：树的根节点</li>
<li>输出：无</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//将根节点的左子树编程连表</span></span><br><span class="line">	flatten(root.left);</span><br><span class="line">	<span class="comment">//将根节点的右子树变成链表</span></span><br><span class="line">	flatten(root.right);</span><br><span class="line">	TreeNode temp = root.right;</span><br><span class="line">	<span class="comment">//讲述的右边换成左边的链表</span></span><br><span class="line">	root.right = root.left;</span><br><span class="line">	<span class="comment">//记得将左边置空</span></span><br><span class="line">	root.left = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">//找到树的最右边的点</span></span><br><span class="line">	<span class="keyword">while</span>(root.right != <span class="keyword">null</span>) {</span><br><span class="line">		root = root.right;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//把右边的链表连接到刚才树得最右边的节点</span></span><br><span class="line">	root.right = temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="解法三：先序遍历递归"><a href="#解法三：先序遍历递归" class="headerlink" title="解法三：先序遍历递归"></a>解法三：先序遍历递归</h2><p>其实就是将二叉树通过右指针，组成一个链表。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6</span><br></pre></td></tr></tbody></table></figure>

<p>我们知道题目给定的遍历顺序其实就是先序遍历的顺序，所以我们能不能利用先序遍历的代码，每遍历一个节点，就将上一个节点的右指针更新为当前节点。</p>
<p>先序遍历的顺序是 1 2 3 4 5 6。</p>
<p>遍历到 2，把 1 的右指针指向 2。1 -&gt; 2 3 4 5 6。</p>
<p>遍历到 3，把 2 的右指针指向 3。1 -&gt; 2 -&gt; 3 4 5 6。</p>
<p>… …</p>
<p>一直进行下去似乎就解决了这个问题。但现实是残酷的，原因就是我们把 1 的右指针指向 2，那么 1 的原本的右孩子就丢失了，也就是 5 就找不到了。</p>
<p>解决方法的话，我们可以逆过来进行。</p>
<p>我们依次遍历 6 5 4 3 2 1，然后每遍历一个节点就将当前节点的右指针更新为上一个节点。</p>
<p>遍历到 5，把 5 的右指针指向 6。6 &lt;- 5 4 3 2 1。</p>
<p>遍历到 4，把 4 的右指针指向 5。6 &lt;- 5 &lt;- 4 3 2 1。</p>
<p>… …</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></tbody></table></figure>

<p>这样就不会有丢失孩子的问题了，因为更新当前的右指针的时候，当前节点的右孩子已经访问过了。</p>
<p>而 6 5 4 3 2 1 的遍历顺序其实变形的后序遍历，遍历顺序是右子树-&gt;左子树-&gt;根节点。</p>
<p>先回想一下后序遍历的代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintBinaryTreeBacRecur</span><span class="params">(TreeNode&lt;T&gt; root)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    PrintBinaryTreeBacRecur(root.right);</span><br><span class="line">    PrintBinaryTreeBacRecur(root.left); </span><br><span class="line">    System.out.print(root.data);</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里的话，我们不再是打印根节点，而是利用一个全局变量 <code>pre</code>，更新当前根节点的右指针为 <code>pre</code>，左指针为 <code>null</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    flatten(root.right);</span><br><span class="line">    flatten(root.left);</span><br><span class="line">    root.right = pre;</span><br><span class="line">    root.left = <span class="keyword">null</span>;</span><br><span class="line">    pre = root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>相应的左孩子也要置为 null，同样的也不用担心左孩子丢失，因为是后序遍历，左孩子已经遍历过了。和 112 题一样，都巧妙的利用了后序遍历。</p>
<p>既然后序遍历这么有用，利用 112 题介绍的后序遍历的迭代方法，把这道题也改一下吧。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>{ </span><br><span class="line">    Stack&lt;TreeNode&gt; toVisit = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !toVisit.isEmpty()) {</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">            toVisit.push(cur); <span class="comment">// 添加根节点</span></span><br><span class="line">            cur = cur.right; <span class="comment">// 递归添加右节点</span></span><br><span class="line">        }</span><br><span class="line">        cur = toVisit.peek(); <span class="comment">// 已经访问到最右的节点了</span></span><br><span class="line">        <span class="comment">// 在不存在左节点或者右节点已经访问过的情况下，访问根节点</span></span><br><span class="line">        <span class="keyword">if</span> (cur.left == <span class="keyword">null</span> || cur.left == pre) {</span><br><span class="line">            toVisit.pop(); </span><br><span class="line">            <span class="comment">/**************修改的地方***************/</span></span><br><span class="line">            cur.right = pre;</span><br><span class="line">            cur.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">/*************************************/</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = <span class="keyword">null</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            cur = cur.left; <span class="comment">// 左节点还没有访问过就先访问左节点</span></span><br><span class="line">        }</span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="解法四：-先序遍历迭代"><a href="#解法四：-先序遍历迭代" class="headerlink" title="解法四： 先序遍历迭代"></a>解法四： 先序遍历迭代</h2><p>解法二中提到如果用先序遍历的话，会丢失掉右孩子，除了用后序遍历，还有没有其他的方法避免这个问题。在 Discuss 又发现了一种解法。</p>
<p>为了更好的控制算法，所以我们用先序遍历迭代的形式，正常的先序遍历代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderStack</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) { </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span> || !s.isEmpty()) {</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) {</span><br><span class="line">            System.out.println(root.val);</span><br><span class="line">            s.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        }</span><br><span class="line">        root = s.pop();</span><br><span class="line">        root = root.right;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>还有一种特殊的先序遍历，提前将右孩子保存到栈中，我们利用这种遍历方式就可以防止右孩子的丢失了。由于栈是先进后出，所以我们先将右节点入栈。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderStack</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!s.isEmpty()) {</span><br><span class="line">        TreeNode temp = s.pop();</span><br><span class="line">        System.out.println(temp.val);</span><br><span class="line">        <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>){</span><br><span class="line">            s.push(temp.right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>){</span><br><span class="line">            s.push(temp.left);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>之前我们的思路如下：</p>
<p>题目其实就是将二叉树通过右指针，组成一个链表。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6</span><br></pre></td></tr></tbody></table></figure>

<p>我们知道题目给定的遍历顺序其实就是先序遍历的顺序，所以我们可以利用先序遍历的代码，每遍历一个节点，就将上一个节点的右指针更新为当前节点。</p>
<p>先序遍历的顺序是 1 2 3 4 5 6。</p>
<p>遍历到 2，把 1 的右指针指向 2。1 -&gt; 2 3 4 5 6。</p>
<p>遍历到 3，把 2 的右指针指向 3。1 -&gt; 2 -&gt; 3 4 5 6。</p>
<p>… …</p>
<p>因为我们用栈保存了右孩子，所以不需要担心右孩子丢失了。用一个 pre 变量保存上次遍历的节点。修改的代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>{ </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    s.push(root);</span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!s.isEmpty()) {</span><br><span class="line">        TreeNode temp = s.pop(); </span><br><span class="line">        <span class="comment">/***********修改的地方*************/</span></span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="keyword">null</span>){</span><br><span class="line">            pre.right = temp;</span><br><span class="line">            pre.left = <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">/********************************/</span></span><br><span class="line">        <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>){</span><br><span class="line">            s.push(temp.right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>){</span><br><span class="line">            s.push(temp.left);</span><br><span class="line">        } </span><br><span class="line">        <span class="comment">/***********修改的地方*************/</span></span><br><span class="line">        pre = temp;</span><br><span class="line">        <span class="comment">/********************************/</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>题解来自<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/" target="_blank" rel="noopener">@windiang</a></p>
<h3 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</h3><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>深度优先搜索</tag>
        <tag>递归</tag>
        <tag>先序遍历</tag>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>递归_leetcode.109.有序链表转换二叉搜索树</title>
    <url>/Transformation_of_binary_search_tree_from_ordered_linked_list/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<a id="more"></a>

<p>示例:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸分析"><a href="#🌸分析" class="headerlink" title="🌸分析"></a>🌸分析</h2><p>将给定的有序链表转换为二叉搜索树的第一步是确定根节点。由于我们需要构造<br>出平衡的二叉树，因此比较直观的想法是让根节点左子树中的节点个数与右子树<br>中的节点个数尽可能接近。这样一来，左右子树的高度也会非常接近,可以达到<br>度差绝对值不超过1的题目要求。</p>
<p>如何找出这样的一个根节点呢?我们可以找出链表元素的中位数作为根节点的<br>值。</p>
<blockquote>
<p>这对于中位数的定义为:如果链表中的元素个数为奇数,那么唯一的中间<br>值为中位数;如果元素个数为偶数,那么唯二的中间值都可以作为中位数,<br>而不是常规定义中二者的平均值。</p>
</blockquote>
<p>根据中位数的性质，链表中小于中位数的元素个数与大于中位数的元素个数要么<br>相等,要么相差1.此时，小于中位数的元素组成了左子树,大于中位数的元素组成了右子树，它们分别对应着有序链表中连续的一-段。在这之后，我们使用分治的思想，继续递归地对左右子树进行构造，找出对应的中位数作为根节点，以此类推。</p>
<p>可以证明，这样的构造方法得到的二叉搜索树是平衡的,详见文末的「正确性证<br>明」部分。</p>
<h2 id="🌸解法一：分治"><a href="#🌸解法一：分治" class="headerlink" title="🌸解法一：分治"></a>🌸解法一：分治</h2><p>具体地，设当前链表的左端点为left,右端点right,包含关系为「左闭右开」，<br>即left包含在链表中而right不包含在链表中。我们希望快速地找出链表的中位<br>数节点mid.</p>
<blockquote>
<p>为什么要设定[闭右刑的关系?于题目中给定的链表为向链表，访问后继元素十分容易,但无法直接访问前驱元素。因此在找出链表的中位数节点mid之后，如果设定「左闭右开」的关系，我们就可以直接用(left, mid)以吸(mid. next, right) 来表在子树对应的列表了。初初始的列表也可以用(head, null)方便地进行表示，中null表示空节点。</p>
</blockquote>
<p>找出链表中位数节点的方法多种多样，中较为简单的一种是「快慢指针法」。<br>初始时，快指针fast和慢指针slow均指向链表的左端点left。我们将快指针<br>fast向右移动两次的同时，将慢指针slow向右移动一次，直到快指针到达边界.<br>(即快指针到达右端点或快指针的下一个节点是右端点)。此时，慢指针对应的<br>元愫就是中位数。</p>
<p>在找出了中位数节点之后,我们将其作为当前根节点的元素，并递归地构造其左<br>侧部分的链表对应的左子树，以及右侧部分的链表对应的右子树。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> buildTree(head, <span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(ListNode left, ListNode right)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (left == right) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    ListNode mid = getMedian(left, right);</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(mid.val);</span><br><span class="line">    root.left = buildTree(left, mid);</span><br><span class="line">    root.right = buildTree(mid.next, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getMedian</span><span class="params">(ListNode left, ListNode right)</span> </span>{</span><br><span class="line">    ListNode fast = left;</span><br><span class="line">    ListNode slow = left;</span><br><span class="line">    <span class="keyword">while</span> (fast != right &amp;&amp; fast.next != right) {</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># python    </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getMedian</span><span class="params">(left: ListNode, right: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">            fast = slow = left</span><br><span class="line">            <span class="keyword">while</span> fast != right <span class="keyword">and</span> fast.next != right:</span><br><span class="line">                fast = fast.next.next</span><br><span class="line">                slow = slow.next</span><br><span class="line">            <span class="keyword">return</span> slow</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(left: ListNode, right: ListNode)</span> -&gt; TreeNode:</span></span><br><span class="line">            <span class="keyword">if</span> left == right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            mid = getMedian(left, right)</span><br><span class="line">            root = TreeNode(mid.val)</span><br><span class="line">            root.left = buildTree(left, mid)</span><br><span class="line">            root.right = buildTree(mid.next, right)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> buildTree(head, <span class="literal">None</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>写法二</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="comment">//边界条件的判断</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(head.val);</span><br><span class="line">    <span class="comment">//这里通过快慢指针找到链表的中间结点slow，pre就是中间</span></span><br><span class="line">    <span class="comment">//结点slow的前一个结点</span></span><br><span class="line">    ListNode slow = head, fast = head, pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) {</span><br><span class="line">        pre = slow;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//链表断开为两部分，一部分是node的左子节点，一部分是node</span></span><br><span class="line">    <span class="comment">//的右子节点</span></span><br><span class="line">    pre.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//node就是当前节点</span></span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">    <span class="comment">//从head节点到pre节点是node左子树的节点</span></span><br><span class="line">    node.left = sortedListToBST(head);</span><br><span class="line">    <span class="comment">//从slow.next到链表的末尾是node的右子树的结点</span></span><br><span class="line">    node.right = sortedListToBST(slow.next);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//把链表节点值全部提取到list中</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) {</span><br><span class="line">        list.add(head.val);</span><br><span class="line">        head = head.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sortedListToBSTHelper(list, <span class="number">0</span>, list.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode <span class="title">sortedListToBSTHelper</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//把list中数据分为两部分</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(list.get(mid));</span><br><span class="line">    root.left = sortedListToBSTHelper(list, left, mid - <span class="number">1</span>);</span><br><span class="line">    root.right = sortedListToBSTHelper(list, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸解法二：-分治-中序遍历优化"><a href="#🌸解法二：-分治-中序遍历优化" class="headerlink" title="🌸解法二： 分治+中序遍历优化"></a>🌸解法二： 分治+中序遍历优化</h2><p>方法一的时间复杂度的瓶颈在于寻找中位数节点。由于<strong>构造出的二叉搜索树的中序遍历结果就是链表本身</strong>,因此我们可以将分治和中序遍历结合起来，减少时间复杂度。</p>
<p>具体地，设当前链表的左端点编号为left, 右端点编号为right, 包含关系为「双闭]，即left和right均包含在链表中。链表节点的编号为[0,n)。中序遍历的顺序是[左子树-根节点-右子树」，那么在分治的过程中, 我们不用急着找出链表的中位数节点，而是使用一个占位节点,等到中序遍历到该节点时,再填充它的值。</p>
<p>我们可以通过计算编号范围来进行中序遍历:</p>
<ul>
<li><p>中位数节点对应的编号为<code>mid= (left+ right + 1)/2;</code></p>
<blockquote>
<p>根据方法一 中对于中位数的定义,编号为(left + right)/2 的节点同样也可以是中位数节点。</p>
</blockquote>
</li>
<li><p>左右子树对应的编号范围分别为<code>[left, mid - 1]和[mid+ 1, right]。</code></p>
</li>
</ul>
<p>如果left &gt; right, 那么遍历到的位置对应着一个空节点， 否则对应着二叉 搜索树中的一个节点。<br>这样一来我们其实已经知道了这棵二叉搜索树的结构,组题目给定了它的中序遍历结果,那么我们只要对其进行中序遍历，就可以还原出整棵二叉 搜索树了。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   ListNode globalNode;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST2</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">   	globalNode = head;</span><br><span class="line">   	<span class="keyword">int</span> length = getLength(head);</span><br><span class="line">   	<span class="keyword">return</span> buildTree(<span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">   }</span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="keyword">if</span>(left &gt; right) {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> mid = (right + left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">	root.left = buildTree(left, mid - <span class="number">1</span>);</span><br><span class="line">	root.val = globalNode.val;</span><br><span class="line">	globalNode = globalNode.next;</span><br><span class="line">	root.right = buildTree(mid + <span class="number">1</span>, right);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(head != <span class="keyword">null</span>) {</span><br><span class="line">		++ret;</span><br><span class="line">		head = head.next;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLength</span><span class="params">(head: ListNode)</span> -&gt; int:</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            ret += <span class="number">1</span></span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(left: int, right: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = (left + right + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        root = TreeNode()</span><br><span class="line">        root.left = buildTree(left, mid - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">nonlocal</span> head</span><br><span class="line">        root.val = head.val</span><br><span class="line">        head = head.next</span><br><span class="line">        root.right = buildTree(mid + <span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    length = getLength(head)</span><br><span class="line">    <span class="keyword">return</span> buildTree(<span class="number">0</span>, length - <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸正确性证明"><a href="#🌸正确性证明" class="headerlink" title="🌸正确性证明"></a>🌸正确性证明</h2><p>我们需要证明的是:对于任意的有序链表，用「前言」部分的构造方法得到的二叉搜索树一定是平衡的。显然,如果二叉搜索树的左右子树都是平衡的，并且它们的高度差不超过1,那么该二叉搜索树就是平衡的。</p>
<p>我们使用数学归纳法,设链表的长度为n,对应的二叉搜索树的高度为H(n):</p>
<blockquote>
<p>这里规定只包含根节点的二叉搜索树的高度为 1.</p>
</blockquote>
<ul>
<li>当n= 1,2时，对应的二叉搜索树都是平衡的，并且<code>H(1)= 1, H(2)= 2;</code></li>
<li>当n=3时,对应的二叉搜索树包含一 个根节点和左右子树各一 个节点，它是平衡的,并且H(3)= 2;</li>
<li>假设当n&lt; $$n_0$$时，对应的二叉搜索树是平衡的，并且对于任意的1≤n&lt;$$n_0$$-1,都有H(n+ 1) - H(n)≤1,那么当n= $$n_0$$时:<ul>
<li>如果n为奇数,设n= 2k+3,那么二叉搜索树的左右子树的大小均为k+ 1,高度相等，因此二叉搜索树平衡的，組有<code>H(n)= H(k+ 1)+1.</code>而n-1=2k+ 2,对应的二叉搜索树的左右子树的大小为k和k+1,即<code>H(n-1)= H(k+ 1)+1</code>,因此<code>H(n)= H(n- 1);</code></li>
<li>如果n为偶数，设<code>n=2k+ 2</code>,那么二叉搜 索树的左右子树的大小为k和k+ 1,根据假设,度差<code>H(k+ 1)- H(k)≤1</code>,因此二叉搜索树是平衡的，并且有<code>H(n)= H(k+1)+ 1。而n-1= 2k+ 1</code></li>
<li>对应的二叉搜索树的左右子树的大小均为k,即H(n- 1)= H(k),因此<code>H(n)- H(n- 1)=H(k + 1)- H(k)≤1。</code></li>
</ul>
</li>
</ul>
<p>这样我们就证明了任意长度的链表对应的二叉搜索树是平衡的。</p>
<p>题解出自<a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-1-3/" target="_blank" rel="noopener">@LeetCode-Solution</a></p>
<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>二分搜索</tag>
        <tag>中序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>递归_leetcode.95.不同的二叉搜索树2</title>
    <url>/Different_binary_search_trees_2/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<a id="more"></a>

<p>示例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">[1,null,3,2],</span><br><span class="line">[3,2,null,1],</span><br><span class="line">[3,1,null,null,2],</span><br><span class="line">[2,1,3],</span><br><span class="line">[1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">以上的输出对应以下 5 种不同结构的二叉搜索树：</span><br><span class="line"></span><br><span class="line"> 1         3     3      2      1</span><br><span class="line">  \       /     /      / \      \</span><br><span class="line">   3     2     1      1   3      2</span><br><span class="line">  /     /       \                 \</span><br><span class="line"> 2     1         2                 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">0 &lt;= n &lt;= 8</span><br></pre></td></tr></tbody></table></figure>



<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote>
<p>给定一个有序序列1..n,为了构建出一棵二叉搜索树，我们可以利用一下查找二叉树的性质。左子树的所有值小于根节点，右子树的所有值大于根节点。我们可以遍历每个数字i,将该数字作为树根，所以如果求1..n的所有可能。</p>
<ul>
<li><p>我们只需要把1作为根节点, [] 空作为左子树, [2 .. n]的所有可能作为右<br>子树。</p>
</li>
<li><p>2作为根节点，[1] 作伪左子树, [3..n]的所有可能作为右子树。</p>
</li>
<li><p>3作为根节点，[1， 2 ]的所有可能作为左子树，[4 … n]的所有可能作为右子树，然后左子树和右子树两两组合。</p>
</li>
<li><p>4作为根节点[1 ，2，3]的所有可能作为佐子树，[5 .. n]的所有可能作为右子树,然后佐子树和右子树两两组合。</p>
</li>
<li><p>…….</p>
</li>
<li><p>n作为根节点，[ 1…. n]的所有可能作为左子树，[]作为右子树。</p>
</li>
</ul>
<p>由此可见，原问题可以分解成规模较小的两个子问题，子问题的解可以复用。<br>因此，我们可以想到使用递归、动态规划来求解本题。</p>
</blockquote>
<h2 id="解法一：递归搜索"><a href="#解法一：递归搜索" class="headerlink" title="解法一：递归搜索"></a>解法一：递归搜索</h2><blockquote>
<p>按照以上分析的思路，利用上边的方法，把每个数字作为根节点，然后把所有可能的左子树和右子树组合起来即可。</p>
<p>如果只有一个数字，那么所有可能就是一种情况，把该数字作为一棵树。而如果是 [ ]，那就返回 null。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> dfs(<span class="number">1</span>, n);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="comment">//如果此时没有值，将null加入到结果中</span></span><br><span class="line">	<span class="keyword">if</span>(start &gt; end) {</span><br><span class="line">		res.add(<span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//如果只有一个数字，将当前数字作为一棵树加入到结果中</span></span><br><span class="line">	<span class="keyword">if</span>(start == end) {</span><br><span class="line">		TreeNode tree = <span class="keyword">new</span> TreeNode(start);</span><br><span class="line">		res.add(tree);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//尝试每个数字作为根节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++) {</span><br><span class="line">		<span class="comment">//得到所有可能的左子树</span></span><br><span class="line">		List&lt;TreeNode&gt; leftTrees = dfs(start, i - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//得到所有可能的右子树</span></span><br><span class="line">		List&lt;TreeNode&gt; rightTrees = dfs(i + <span class="number">1</span>, end);</span><br><span class="line">		<span class="comment">//将所得的左子树右子树两两组合</span></span><br><span class="line">		<span class="keyword">for</span>(TreeNode leftTree : leftTrees) {</span><br><span class="line">			<span class="keyword">for</span>(TreeNode rightTree : rightTrees) {</span><br><span class="line">				TreeNode tree = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">				tree.left = leftTree;</span><br><span class="line">				tree.right = rightTree;</span><br><span class="line">				<span class="comment">//加入到结果集中去</span></span><br><span class="line">				res.add(tree);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="解法二：-动态规划"><a href="#解法二：-动态规划" class="headerlink" title="解法二： 动态规划"></a>解法二： 动态规划</h2><blockquote>
<p>仔细分析，可以发现一个规律。首先我们每次新增加的数字大于之前的所有数字，所以新增加的数字出现的位置只可能是根节点或者是根节点的右孩子，右孩子的右孩子，右孩子的右孩子的右孩子等等，总之一定是右边。其次，新数字所在位置原来的子树，改为当前插入数字的左孩子即可，因为插入数字是最大的。</p>
<p>由于求当前的所有解只需要上一次的解，所有我们只需要两个 list，pre 保存上一次的所有解， cur 计算当前的所有解。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    List&lt;TreeNode&gt; pre = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line">    pre.add(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//每次增加一个数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        List&lt;TreeNode&gt; cur = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">//遍历之前的所有解</span></span><br><span class="line">        <span class="keyword">for</span> (TreeNode root : pre) {</span><br><span class="line">            <span class="comment">//插入到根节点</span></span><br><span class="line">            TreeNode insert = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">            insert.left = root;</span><br><span class="line">            cur.add(insert);</span><br><span class="line">            <span class="comment">//插入到右孩子，右孩子的右孩子...最多找 n 次孩子</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) {</span><br><span class="line">                TreeNode root_copy = treeCopy(root); <span class="comment">//复制当前的树</span></span><br><span class="line">                TreeNode right = root_copy; <span class="comment">//找到要插入右孩子的位置</span></span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//遍历 j 次找右孩子</span></span><br><span class="line">                <span class="keyword">for</span> (; k &lt; j; k++) {</span><br><span class="line">                    <span class="keyword">if</span> (right == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    right = right.right;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//到达 null 提前结束</span></span><br><span class="line">                <span class="keyword">if</span> (right == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//保存当前右孩子的位置的子树作为插入节点的左孩子</span></span><br><span class="line">                TreeNode rightTree = right.right;</span><br><span class="line">                insert = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                right.right = insert; <span class="comment">//右孩子是插入的节点</span></span><br><span class="line">                insert.left = rightTree; <span class="comment">//插入节点的左孩子更新为插入位置之前的子树</span></span><br><span class="line">                <span class="comment">//加入结果中</span></span><br><span class="line">                cur.add(root_copy);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        pre = cur;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">treeCopy</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    TreeNode newRoot = <span class="keyword">new</span> TreeNode(root.val);</span><br><span class="line">    newRoot.left = treeCopy(root.left);</span><br><span class="line">    newRoot.right = treeCopy(root.right);</span><br><span class="line">    <span class="keyword">return</span> newRoot;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>动态规划</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP_leetcode.459.重复的子字符串</title>
    <url>/Repeated_substring_of_a_string/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p>
<a id="more"></a>

<p>示例 1:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: "abab"</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 "ab" 重复两次构成。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: "aba"</span><br><span class="line">输出: False</span><br></pre></td></tr></tbody></table></figure>


<p>示例 3:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入: "abcabcabcabc"</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 "abc" 重复四次构成。 (或者子字符串 "abcabc" 重复两次构成。)</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸分析"><a href="#🌸分析" class="headerlink" title="🌸分析"></a>🌸分析</h2><p>暴力出奇迹，优化见真章！</p>
<h2 id="🌸解法一：暴力解法（直接匹配）"><a href="#🌸解法一：暴力解法（直接匹配）" class="headerlink" title="🌸解法一：暴力解法（直接匹配）"></a>🌸解法一：暴力解法（直接匹配）</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern1</span><span class="params">(String s)</span> </span>{</span><br><span class="line">       <span class="keyword">if</span>(s.length() == <span class="number">0</span>||s.length()==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       List&lt;Integer&gt; indexes =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       indexes.add(<span class="number">0</span>);</span><br><span class="line">       <span class="comment">//计算出所有有可能的子串长度</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;s.length() ; i++) {</span><br><span class="line">           <span class="comment">//和第0个位置的字符相等，且总字符串的长度能够整除当前子串长度</span></span><br><span class="line">           <span class="keyword">if</span>(s.charAt(i)==s.charAt(<span class="number">0</span>)</span><br><span class="line">                   &amp;&amp;s.length()%i==<span class="number">0</span>){</span><br><span class="line">               indexes.add(i);</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; indexes.size() ; i++) {</span><br><span class="line">           <span class="keyword">int</span> length =indexes.get(i);  <span class="comment">//当前考虑的子串长度单位</span></span><br><span class="line">           String str = s.substring(<span class="number">0</span>,length);   <span class="comment">//子串</span></span><br><span class="line">           <span class="keyword">int</span> j = length;</span><br><span class="line">           <span class="comment">//以当前考虑的长度单位进行遍历，如果每隔length的子串都等于str，</span></span><br><span class="line">           <span class="comment">//并且遍历到了字符串末尾，说明结果为true，反之跳出考虑下一种子串长度</span></span><br><span class="line">           <span class="keyword">for</span> (; j &lt;s.length() ; j=j+length) {</span><br><span class="line">               <span class="keyword">if</span>(!s.substring(j,j+length).equals(str))</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">if</span>(j==s.length())</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法二：-暴力解法（枚举）"><a href="#🌸解法二：-暴力解法（枚举）" class="headerlink" title="🌸解法二： 暴力解法（枚举）"></a>🌸解法二： 暴力解法（枚举）</h2><p>如果一个长度为n的字符串s可以由它的一个长度为<code>n'</code>的子串<code>s'</code>重复多次构<br>成，那么:</p>
<ul>
<li>n—定是<code>n'</code>的倍数;</li>
<li><code>s'</code>一定是s的前缀;</li>
<li>对于任意的<code>i ∈[n’, 7)</code>，有<code>s[2]= s[i - n']</code>。</li>
</ul>
<p>也就是说，s中长度为<code>n'</code>的前缀就是<code>s'</code>，并且在这之后的每一个位置上的字符<code>s[i]</code>，都需要与它之前的第<code>n'</code>个字符<code>s[i-n'</code>]相同。</p>
<p>因此，我们可以从小到大枚举<code>n'</code>，并对字符串s进行遍历，进行上述的判断。注<br>意到一个小优化是，因为子串至少需要重复一次，所以<code>n'</code>不会大于n的一半，我<br>们只需要在<code>[1, n/2]</code>的范围内枚举<code>n'</code>即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>{</span><br><span class="line">       <span class="keyword">int</span> n = s.length();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * <span class="number">2</span> &lt;= n; ++i) {</span><br><span class="line">           <span class="keyword">if</span> (n % i == <span class="number">0</span>) {</span><br><span class="line">               <span class="keyword">boolean</span> match = <span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) {</span><br><span class="line">                   <span class="keyword">if</span> (s.charAt(j) != s.charAt(j - i)) {</span><br><span class="line">                       match = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line">               <span class="keyword">if</span> (match) {</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法三：移动匹配"><a href="#🌸解法三：移动匹配" class="headerlink" title="🌸解法三：移动匹配"></a>🌸解法三：移动匹配</h2><p>如果您的字符串S包含一个重复的子字符串，那么这意味着您可以多次“移位和换行”您的字符串，并使其与原始字符串匹配。<br>例如:<code>abcabc</code></p>
<ul>
<li>移位一次:<code>cabcab</code></li>
<li>移位两次:<code>bcabca</code></li>
<li>移位三次:<code>abcabc</code></li>
</ul>
<p>现在字符串和原字符串匹配了，所以可以得出结论存在重复的子串</p>
<p>基于这个思想，可以每次移动k个字符，直到匹配移动length -1次。但是这样对于重复字符串很长的字符串，效率会非常低。在LeetCode中执行时间超时了。</p>
<p>为了避免这种无用的环绕，可以创建一个新的字符串str;它等于原来的字符串S再加上S自身，这样其实就包含了所有移动的字符串。</p>
<p>比如字符串: S= acd，那么<code>str = S+S = acdacd</code></p>
<p>acd移动的可能: dac、cda。其实都包含在了str中了。就像一个滑动窗口一开始acd (acd)，移动一次<code>ac(dac)d</code>,移动两次<code>a(cda)cd</code>。循环结束</p>
<p>所以可以直接判断str中去除首尾元素之后，是否包含自身元素。如果包含。则表明存在重复子串。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern2</span><span class="params">(String s)</span> </span>{</span><br><span class="line">	String str = s + s;</span><br><span class="line">	<span class="keyword">return</span> str.substring(<span class="number">1</span>, str.length() - <span class="number">1</span>).contains(s);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="🌸解法四：KMP（留下了无知的泪水，太难了。）"><a href="#🌸解法四：KMP（留下了无知的泪水，太难了。）" class="headerlink" title="🌸解法四：KMP（留下了无知的泪水，太难了。）"></a>🌸解法四：KMP（留下了无知的泪水，太难了。）</h2><p>读者需要注意以下几点:</p>
<ul>
<li>KMP 算法虽然有着良好的理论时间复杂度上限，但大部分语言自带的字符串查找函数并不是用 KMP 算法实现的。这是因为在实现 API 时，我们需要在平均时间复杂度和最坏时间复杂度二者之间权衡。普通的暴力匹配算法以及优化的 BM 算法拥有比 KMP 算法更为优秀的平均时间复杂度；</li>
<li>学习 KMP 算法时，一定要理解其本质。如果放弃阅读晦涩难懂的材料（即使大部分讲解 KMP 算法的材料都包含大量的图，但图毕竟只能描述特殊而非一般情况）而是直接去阅读代码，是永远无法学会 KMP 算法的。读者甚至无法理解 KMP 算法关键代码中的任意一行。</li>
</ul>
<p>由于本题就是在一个字符串中查询另一个字符串是否出现，可以直接套用 KMP 算法。因此这里对 KMP 算法本身不再赘述。读者可以自行查阅资料进行学习。这里留了三个思考题，读者可以在学习完毕后尝试回答这三个问题，检验自己的学习成果：</p>
<ul>
<li>设查询串的的长度为 n，模式串的长度为 m，我们需要判断模式串是否为查询串的子串。那么使用 KMP 算法处理该问题时的时间复杂度是多少？在分析时间复杂度时使用了哪一种分析方法？</li>
<li>如果有多个查询串，平均长度为 n，数量为 k，那么总时间复杂度是多少？</li>
<li>在 KMP 算法中，对于模式串，我们需要预处理出一个fail 数组（有时也称为 next 数组、π 数组等）。这个数组到底表示了什么？</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern3</span><span class="params">(String s)</span> </span>{</span><br><span class="line">       <span class="keyword">return</span> kmp(s + s, s);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">kmp</span><span class="params">(String query, String pattern)</span> </span>{</span><br><span class="line">       <span class="keyword">int</span> n = query.length();</span><br><span class="line">       <span class="keyword">int</span> m = pattern.length();</span><br><span class="line">       <span class="keyword">int</span>[] fail = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">       Arrays.fill(fail, -<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) {</span><br><span class="line">           <span class="keyword">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">           <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; pattern.charAt(j + <span class="number">1</span>) != pattern.charAt(i)) {</span><br><span class="line">               j = fail[j];</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">if</span> (pattern.charAt(j + <span class="number">1</span>) == pattern.charAt(i)) {</span><br><span class="line">               fail[i] = j + <span class="number">1</span>;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">int</span> match = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) {</span><br><span class="line">           <span class="keyword">while</span> (match != -<span class="number">1</span> &amp;&amp; pattern.charAt(match + <span class="number">1</span>) != query.charAt(i)) {</span><br><span class="line">               match = fail[match];</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">if</span> (pattern.charAt(match + <span class="number">1</span>) == query.charAt(i)) {</span><br><span class="line">               ++match;</span><br><span class="line">               <span class="keyword">if</span> (match == m - <span class="number">1</span>) {</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>



<h2 id="🌸正确性证明"><a href="#🌸正确性证明" class="headerlink" title="🌸正确性证明"></a>🌸正确性证明</h2><p><a href="https://imgchr.com/i/dDZdW8" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/24/dDZdW8.png" alt="dDZdW8.png"></a></p>
<p><a href="https://imgchr.com/i/dDZ0SS" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/24/dDZ0SS.png" alt="dDZ0SS.png"></a></p>
<p>题解出自<a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-1-3/" target="_blank" rel="noopener">@LeetCode-Solution</a></p>
<h2 id="🌸思考题答案"><a href="#🌸思考题答案" class="headerlink" title="🌸思考题答案"></a>🌸思考题答案</h2><ul>
<li><p>设查询串的的长度为 n，模式串的长度为 m，我们需要判断模式串是否为查询串的子串。那么使用 KMP 算法处理该问题时的时间复杂度是多少？在分析时间复杂度时使用了哪一种分析方法？</p>
<ul>
<li>时间复杂度为 O(n+m)，用到了均摊分析（摊还分析）的方法。</li>
<li>具体地，无论在预处理过程还是查询过程中，虽然匹配失败时，指针会不断地根据 fail 数组向左回退，看似时间复杂度会很高。但考虑匹配成功时，指针会向右移动一个位置，这一部分对应的时间复杂度为 O(n+m)。又因为向左移动的次数不会超过向右移动的次数，因此总时间复杂度仍然为 O(n+m)。</li>
</ul>
</li>
<li><p>如果有多个查询串，平均长度为 n，数量为 k，那么总时间复杂度是多少？</p>
<ul>
<li>时间复杂度为 O(nk+m)。模式串只需要预处理一次。</li>
</ul>
</li>
<li><p>在 KMP 算法中，对于模式串，我们需要预处理出一个fail 数组（有时也称为next 数组、π 数组等）。这个数组到底表示了什么？</p>
<ul>
<li>fail[i] 等于满足下述要求的 x 的最大值：s[0:i]具有长度为 x+1 的完全相同的前缀和后缀。这也是 KMP 算法最重要的一部分</li>
</ul>
</li>
</ul>
<h2 id="🌸解法五-优化的KMP"><a href="#🌸解法五-优化的KMP" class="headerlink" title="🌸解法五: 优化的KMP"></a>🌸解法五: 优化的KMP</h2><p>如果读者能够看懂「正确性证明」和「思考题答案」这两部分，那么一定已经发现了方法三中的 KMP 算法有可以优化的地方。即：</p>
<ul>
<li><p>在「正确性证明」部分，如果我们设 i 为<code>最小的</code>起始位置，那么一定有 gcd(n,i)=i，即 n 是 i 的倍数。这说明字符串 s 是由长度为 i的前缀重复 n / i次构成；</p>
</li>
<li><p>由于fail[n−1] 表示 s 具有长度为 fail[n−1]+1 的完全相同的（且最长的）前缀和后缀。那么对于满足题目要求的字符串，一定有 fail[n−1]=n−i−1，即 i=n−fail[n−1]−1；</p>
</li>
<li><p>对于不满足题目要求的字符串，n 一定不是 n −<em>fail</em>[<em>n</em>−1]−1 的倍数</p>
</li>
</ul>
<blockquote>
<p>上述所有的结论都可以很容易地使用反证法证出。</p>
</blockquote>
<p>因此，我们在预处理出fail 数组后，只需要判断 n 是否为 n - fail[n−1]−1 的倍数即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern4</span><span class="params">(String s)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> kmp(s);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">kmp</span><span class="params">(String pattern)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = pattern.length();</span><br><span class="line">    <span class="keyword">int</span>[] fail = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Arrays.fill(fail, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) {</span><br><span class="line">        <span class="keyword">int</span> j = fail[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; pattern.charAt(j + <span class="number">1</span>) != pattern.charAt(i)) {</span><br><span class="line">            j = fail[j];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (pattern.charAt(j + <span class="number">1</span>) == pattern.charAt(i)) {</span><br><span class="line">            fail[i] = j + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fail[n - <span class="number">1</span>] != -<span class="number">1</span> &amp;&amp; n % (n - fail[n - <span class="number">1</span>] - <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>题解出自<a href="https://leetcode-cn.com/problems/repeated-substring-pattern/solution/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/" target="_blank" rel="noopener">LeetCode-Solution</a></p>
<h3 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</h3><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>枚举</tag>
        <tag>匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS-BFS_leetcode.785.判断二分图</title>
    <url>/Judge_bipartite_graph/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>🍁给定一个无向图graph，当这个图为二分图时返回true。</p>
<p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p>
<p>graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到<code>graph.length-1</code>之间的整数。这图中没有自环和平行边： <code>graph[i]</code> 中不存在i，并且graph[i]中没有重复的值。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">输出: true</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">我们可以将节点分成两组: {0, 2} 和 {1, 3}。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">输出: false</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">我们不能将节点分割成两个独立的子集。</span><br></pre></td></tr></tbody></table></figure>

<p>注意:</p>
<p><code>graph</code> 的长度范围为 <code>[1, 100]</code>。<br><code>graph[i]</code> 中的元素的范围为 <code>[0, graph.length - 1]。</code><br><code>graph[i]</code> 不会包含 i 或者有重复的值。<br>图是无向的: 如果j 在 <code>graph[i]</code>里边, 那么 i 也会在 <code>graph[j]里</code>边。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>对于图中的任意两个节点 u 和 v，如果它们之间有一条边直接相连，那么 u 和 vv必须属于不同的集合。</strong></p>
<p>如果给定的无向图连通，那么我们就可以任选一个节点开始，给它分成第一组。随后我们对整个图进行遍历，将该节点直接相连的所有节点分成第二组，表示这些节点不能与起始节点属于同一个集合。我们再将这些第二组的节点直接相连的所有节点分成第一组，以此类推，直到无向图中的每个节点均被分组。</p>
<p>如果我们能够成功分组，那么一组和二组的节点各属于一个集合，这个无向图就是一个二分图；如果我们未能成功分组，即在分组的过程中，某一时刻访问到了一个已经分组的节点，并且它的组与我们将要给它分的组不相同，也就说明这个无向图不是一个二分图。</p>
<p>算法的流程如下：</p>
<ul>
<li><p>我们任选一个节点开始，将其分组第一组，并从该节点开始对整个无向图进行遍历；</p>
</li>
<li><p>在遍历的过程中，如果我们通过节点 u 遍历到了节点 v（即 u 和 v 在图中有一条边直接相连），那么会有两种情况：</p>
<ul>
<li>如果 v 未被分组，那么我们将其分成与 u 不同的组，并对 v 直接相连的节点进行遍历；</li>
<li>如果 v 被分组，并且组与 u 相同，那么说明给定的无向图不是二分图。我们可以直接退出遍历并返回 False 作为答案。</li>
</ul>
</li>
<li><p>当遍历结束时，说明给定的无向图是二分图，返回 True 作为答案。</p>
</li>
</ul>
<p>我们可以使用「深度优先搜索」或「广度优先搜索」对无向图进行遍历，下文分别给出了这两种搜索对应的代码。</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>题目中给定的无向图不一定保证连通，因此我们需要进行多次遍历，直到每一个节点都被分组，或确定答案为 False 为止。每次遍历开始时，我们任选一个未被分组的节点，将所有与该节点直接或间接相连的节点进行分组。</p>
<h2 id="解法一：DFS"><a href="#解法一：DFS" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//0 代表还未分组的数字，1代表分的是第一组，2代表分的是第二组</span></span><br><span class="line"><span class="comment">//group用于记录无向图数字分组的状态：例如group[2] = 2;表示图中顶点2 被分为第二组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] group;</span><br><span class="line"><span class="comment">//记录分组成功与否的标志</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> len = graph.length;</span><br><span class="line">	<span class="comment">//开始初始化标志为true,用于判断数字能否分组成功</span></span><br><span class="line">	flag = <span class="keyword">true</span>;</span><br><span class="line">	<span class="comment">//初始化数字分组的状态：0</span></span><br><span class="line">	group = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">	Arrays.fill(group, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//从初始遍历无向图的每个数字</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len &amp;&amp; flag; i++) {</span><br><span class="line">		<span class="comment">//如果该数字是未分组状态，深度搜索该数字对应的边的那个数字</span></span><br><span class="line">		<span class="keyword">if</span>(group[i] == <span class="number">0</span>) {</span><br><span class="line">			dfs(i, <span class="number">1</span>, graph);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> sub, <span class="keyword">int</span>[][] graph)</span> </span>{</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="comment">//将节点node分组</span></span><br><span class="line">	group[node] = sub;</span><br><span class="line">	<span class="comment">//保存当前节点node分组所对应的另一个分组</span></span><br><span class="line">	<span class="keyword">int</span> sub2 = sub == <span class="number">1</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//搜索当前节点的所有邻节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> neighbor : graph[node]) {</span><br><span class="line">		<span class="comment">//该邻节点未分组，深度搜索 进行分组</span></span><br><span class="line">		<span class="keyword">if</span>(group[neighbor] == <span class="number">0</span>) {</span><br><span class="line">			dfs(neighbor, sub2, graph);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//如果flag为false，说明未能完成分组，直接返回</span></span><br><span class="line">			<span class="keyword">if</span>(!flag) {</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="comment">//如果以分组且与邻接点处于同一组</span></span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(group[neighbor] != sub2) {</span><br><span class="line">			flag = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span><span class="params">(self, graph: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        n = len(graph)</span><br><span class="line">        UNCOLORED, RED, GREEN = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        color = [UNCOLORED] * n</span><br><span class="line">        valid = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node: int, c: int)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> valid</span><br><span class="line">            color[node] = c</span><br><span class="line">            cNei = (GREEN <span class="keyword">if</span> c == RED <span class="keyword">else</span> RED)</span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">                <span class="keyword">if</span> color[neighbor] == UNCOLORED:</span><br><span class="line">                    dfs(neighbor, cNei)</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> valid:</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">elif</span> color[neighbor] != cNei:</span><br><span class="line">                    valid = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> color[i] == UNCOLORED:</span><br><span class="line">                dfs(i, RED)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> valid:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> valid</span><br></pre></td></tr></tbody></table></figure>



<h2 id="解法二：-BFS"><a href="#解法二：-BFS" class="headerlink" title="解法二： BFS"></a>解法二： BFS</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite2</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>{</span><br><span class="line">       <span class="keyword">int</span> n = graph.length;</span><br><span class="line">       group = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">       Arrays.fill(group, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">           <span class="keyword">if</span> (group[i] == <span class="number">0</span>) {</span><br><span class="line">               Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">               queue.offer(i);</span><br><span class="line">               group[i] = <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">                   <span class="keyword">int</span> node = queue.poll();</span><br><span class="line">                   <span class="keyword">int</span> cNei = group[node] == <span class="number">1</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph[node]) {</span><br><span class="line">                       <span class="keyword">if</span> (group[neighbor] == <span class="number">0</span>) {</span><br><span class="line">                           queue.offer(neighbor);</span><br><span class="line">                           group[neighbor] = cNei;</span><br><span class="line">                       } <span class="keyword">else</span> <span class="keyword">if</span> (group[neighbor] != cNei) {</span><br><span class="line">                           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                       }</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span><span class="params">(self, graph: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        n = len(graph)</span><br><span class="line">        UNCOLORED, RED, GREEN = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        color = [UNCOLORED] * n</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> color[i] == UNCOLORED:</span><br><span class="line">                q = collections.deque([i])</span><br><span class="line">                color[i] = RED</span><br><span class="line">                <span class="keyword">while</span> q:</span><br><span class="line">                    node = q.popleft()</span><br><span class="line">                    cNei = (GREEN <span class="keyword">if</span> color[node] == RED <span class="keyword">else</span> RED)</span><br><span class="line">                    <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">                        <span class="keyword">if</span> color[neighbor] == UNCOLORED:</span><br><span class="line">                            q.append(neighbor)</span><br><span class="line">                            color[neighbor] = cNei</span><br><span class="line">                        <span class="keyword">elif</span> color[neighbor] != cNei:</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>深度优先搜索</tag>
        <tag>BFS</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS_leetcode.130.被围绕的区域</title>
    <url>/Surrounding_area/</url>
    <content><![CDATA[<h2 id="🌸题目"><a href="#🌸题目" class="headerlink" title="🌸题目"></a>🌸题目</h2><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p>
<p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
<a id="more"></a>

<p>示例:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></tbody></table></figure>


<p>运行你的函数后，矩阵变为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></tbody></table></figure>


<p>解释:</p>
<p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题我们拿到基本就可以确定是图的 dfs、bfs 遍历的题目了。题目中解释说被包围的区间不会存在于边界上，所以我们会想到边界上的 O 要特殊处理，只要把边界上的 O 特殊处理了，那么剩下的 O 替换成 XX 就可以了。问题转化为，如何寻找和边界联通的 O，我们需要考虑如下情况。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O O X</span><br></pre></td></tr></tbody></table></figure>

<p>这时候的0不做替换的。因为和边界是连通的。为了记录这种状态,我们把这<br>种情况下的O换成#作为占位符,待搜索结束之后，遇到O替换为X (和边界<br>不连通的O) ;遇倒#,替换回$O(和边界连通的0)。<br>如何寻找和边界联通的O?从边界出发,对图进行dfs 和bfs 即呵。这里简单<br>总结下dfs和bfs</p>
<ul>
<li>bfs递归。可以想想二叉树中如何递归的进行序遍历。</li>
<li>bfs递归。一般用队列存储。</li>
<li>dfs递归。最常用，如二叉树的先序遍历。</li>
<li>dfs非递归。一般用stack。</li>
</ul>
<p>那么基于上面这种想法，我们有四种方式实现。</p>
<h2 id="解法一：DFS"><a href="#解法一：DFS" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="comment">// 从边缘o开始搜索</span></span><br><span class="line">                <span class="keyword">boolean</span> isEdge = i == <span class="number">0</span> || j == <span class="number">0</span> || i == m - <span class="number">1</span> || j == n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (isEdge &amp;&amp; board[i][j] == <span class="string">'O'</span>) {</span><br><span class="line">                    dfs(board, i, j);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) {</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'#'</span>) {</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= board.length  || j &gt;= board[<span class="number">0</span>].length || board[i][j] == <span class="string">'X'</span> || board[i][j] == <span class="string">'#'</span>) {</span><br><span class="line">            <span class="comment">// board[i][j] == '#' 说明已经搜索过了. </span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">        dfs(board, i - <span class="number">1</span>, j); <span class="comment">// 上</span></span><br><span class="line">        dfs(board, i + <span class="number">1</span>, j); <span class="comment">// 下</span></span><br><span class="line">        dfs(board, i, j - <span class="number">1</span>); <span class="comment">// 左</span></span><br><span class="line">        dfs(board, i, j + <span class="number">1</span>); <span class="comment">// 右</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h2 id="解法二：-DFS非递归"><a href="#解法二：-DFS非递归" class="headerlink" title="解法二： DFS非递归"></a>解法二： DFS非递归</h2><p>非递归的方式，我们需要记录每- -次遍历过的位置 ，我们用stack 来记录，因<br>为它先进后出的特点。而位置我们定义一一个内部类Pos 来标记横坐标和纵坐<br>标。注意的是，在写非递归的时候，我们每次查看stack顶，但是并不出stack<br>，直到这个位置上下左右都搜索不到的时候出Stack</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pos</span></span>{</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        Pos(<span class="keyword">int</span> i, <span class="keyword">int</span> j) {</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">            <span class="keyword">this</span>.j = j;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="comment">// 从边缘第一个是o的开始搜索</span></span><br><span class="line">                <span class="keyword">boolean</span> isEdge = i == <span class="number">0</span> || j == <span class="number">0</span> || i == m - <span class="number">1</span> || j == n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (isEdge &amp;&amp; board[i][j] == <span class="string">'O'</span>) {</span><br><span class="line">                    dfs(board, i, j);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) {</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'#'</span>) {</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">        Stack&lt;Pos&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(<span class="keyword">new</span> Pos(i, j));</span><br><span class="line">        board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">            <span class="comment">// 取出当前stack 顶, 不弹出.</span></span><br><span class="line">            Pos current = stack.peek();</span><br><span class="line">            <span class="comment">// 上</span></span><br><span class="line">            <span class="keyword">if</span> (current.i - <span class="number">1</span> &gt;= <span class="number">0</span> </span><br><span class="line">                &amp;&amp; board[current.i - <span class="number">1</span>][current.j] == <span class="string">'O'</span>) {</span><br><span class="line">                stack.push(<span class="keyword">new</span> Pos(current.i - <span class="number">1</span>, current.j));</span><br><span class="line">                board[current.i - <span class="number">1</span>][current.j] = <span class="string">'#'</span>;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 下</span></span><br><span class="line">            <span class="keyword">if</span> (current.i + <span class="number">1</span> &lt;= board.length - <span class="number">1</span> </span><br><span class="line">                &amp;&amp; board[current.i + <span class="number">1</span>][current.j] == <span class="string">'O'</span>) {</span><br><span class="line">                stack.push(<span class="keyword">new</span> Pos(current.i + <span class="number">1</span>, current.j));</span><br><span class="line">                board[current.i + <span class="number">1</span>][current.j] = <span class="string">'#'</span>;      </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 左</span></span><br><span class="line">            <span class="keyword">if</span> (current.j - <span class="number">1</span> &gt;= <span class="number">0</span> </span><br><span class="line">                &amp;&amp; board[current.i][current.j - <span class="number">1</span>] == <span class="string">'O'</span>) {</span><br><span class="line">                stack.push(<span class="keyword">new</span> Pos(current.i, current.j - <span class="number">1</span>));</span><br><span class="line">                board[current.i][current.j - <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span> (current.j + <span class="number">1</span> &lt;= board[<span class="number">0</span>].length - <span class="number">1</span> </span><br><span class="line">                &amp;&amp; board[current.i][current.j + <span class="number">1</span>] == <span class="string">'O'</span>) {</span><br><span class="line">                stack.push(<span class="keyword">new</span> Pos(current.i, current.j + <span class="number">1</span>));</span><br><span class="line">                board[current.i][current.j + <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果上下左右都搜索不到,本次搜索结束，弹出stack</span></span><br><span class="line">            stack.pop();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="解法三：BFS非递归"><a href="#解法三：BFS非递归" class="headerlink" title="解法三：BFS非递归"></a>解法三：BFS非递归</h2><p>dfs非递归的时候我们用stack来记录状态，而bfs 非递归,我们则用队列来记录状态。和dfs 不同的是，dfs 中搜索上下左右,只要搜索到一一个满足条件,我们就顺着该方向继续搜索,所以你可以看到dfs代码中，只要满足条件，就入Stack ,<br>然后cont inue本次搜索,进行下一次搜索,直到搜索到没有满足条件的时候出stack 。而dfs 中，我们要把上下左右满足条件的都入队，所以搜索的时候就不能continue 。大家可以对比下两者的代码，体会bfs和dfs 的差异。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pos</span></span>{</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        Pos(<span class="keyword">int</span> i, <span class="keyword">int</span> j) {</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">            <span class="keyword">this</span>.j = j;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="comment">// 从边缘第一个是o的开始搜索</span></span><br><span class="line">                <span class="keyword">boolean</span> isEdge = i == <span class="number">0</span> || j == <span class="number">0</span> || i == m - <span class="number">1</span> || j == n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (isEdge &amp;&amp; board[i][j] == <span class="string">'O'</span>) {</span><br><span class="line">                    bfs(board, i, j);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) {</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'#'</span>) {</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">        Queue&lt;Pos&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> Pos(i, j));</span><br><span class="line">        board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            Pos current = queue.poll();</span><br><span class="line">            <span class="comment">// 上</span></span><br><span class="line">            <span class="keyword">if</span> (current.i - <span class="number">1</span> &gt;= <span class="number">0</span> </span><br><span class="line">                &amp;&amp; board[current.i - <span class="number">1</span>][current.j] == <span class="string">'O'</span>) {</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pos(current.i - <span class="number">1</span>, current.j));</span><br><span class="line">                board[current.i - <span class="number">1</span>][current.j] = <span class="string">'#'</span>;</span><br><span class="line">              	<span class="comment">// 没有continue.</span></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 下</span></span><br><span class="line">            <span class="keyword">if</span> (current.i + <span class="number">1</span> &lt;= board.length - <span class="number">1</span> </span><br><span class="line">                &amp;&amp; board[current.i + <span class="number">1</span>][current.j] == <span class="string">'O'</span>) {</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pos(current.i + <span class="number">1</span>, current.j));</span><br><span class="line">                board[current.i + <span class="number">1</span>][current.j] = <span class="string">'#'</span>;      </span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 左</span></span><br><span class="line">            <span class="keyword">if</span> (current.j - <span class="number">1</span> &gt;= <span class="number">0</span> </span><br><span class="line">                &amp;&amp; board[current.i][current.j - <span class="number">1</span>] == <span class="string">'O'</span>) {</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pos(current.i, current.j - <span class="number">1</span>));</span><br><span class="line">                board[current.i][current.j - <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span> (current.j + <span class="number">1</span> &lt;= board[<span class="number">0</span>].length - <span class="number">1</span> </span><br><span class="line">                &amp;&amp; board[current.i][current.j + <span class="number">1</span>] == <span class="string">'O'</span>) {</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pos(current.i, current.j + <span class="number">1</span>));</span><br><span class="line">                board[current.i][current.j + <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="BFS-递归"><a href="#BFS-递归" class="headerlink" title="BFS 递归"></a>BFS 递归</h2><p><code>bfs</code> 一般我们不会去涉及，而且比较绕，之前我们唯一 <code>A</code> 过的用 <code>bfs</code> 递归的方式是层序遍历二叉树的时候可以用递归的方式。</p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集这种数据结构好像大家不太常用，实际上很有用，我在实际的 production code 中用过并查集。并查集常用来解决连通性的问题，即将一个图中连通的部分划分出来。当我们判断图中两个点之间是否存在路径时，就可以根据判断他们是否在一个连通区域。 而这道题我们其实求解的就是和边界的 O 在一个连通区域的的问题。</p>
<p>并查集的思想就是，同一个连通区域内的所有点的根节点是同一个。将每个点映射成一个数字。先假设每个点的根节点就是他们自己，然后我们以此输入连通的点对，然后将其中一个点的根节点赋成另一个节点的根节点，这样这两个点所在连通区域又相互连通了。<br>并查集的主要操作有：</p>
<ul>
<li><code>find(int m)</code>：这是并查集的基本操作，查找 m 的根节点。</li>
<li><code>isConnected(int m,int n)</code>：判断 m，n 两个点是否在一个连通区域。</li>
<li><code>union(int m,int n)</code>:合并 m，，n 两个点所在的连通区域。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] parents;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> totalNodes)</span> </span>{</span><br><span class="line">        parents = <span class="keyword">new</span> <span class="keyword">int</span>[totalNodes];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalNodes; i++) {</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">		<span class="comment">// 合并连通区域是通过find来操作的, 即看这两个节点是不是在一个连通区域内.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> node1, <span class="keyword">int</span> node2)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> root1 = find(node1);</span><br><span class="line">        <span class="keyword">int</span> root2 = find(node2);</span><br><span class="line">        <span class="keyword">if</span> (root1 != root2) {</span><br><span class="line">            parents[root2] = root1;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> node)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (parents[node] != node) {</span><br><span class="line">            <span class="comment">// 当前节点的父节点 指向父节点的父节点.</span></span><br><span class="line">            <span class="comment">// 保证一个连通区域最终的parents只有一个.</span></span><br><span class="line">            parents[node] = parents[parents[node]];</span><br><span class="line">            node = parents[node];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> node1, <span class="keyword">int</span> node2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> find(node1) == find(node2);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们的思路是把所有边界上的 O 看做一个连通区域。遇到 O 就执行并查集合并操作，这样所有的 O 就会被分成两类</p>
<ul>
<li>和边界上的 O 在一个连通区域内的。这些 O我们保留。</li>
<li>不和边界上的 O 在一个连通区域内的。这些 O 就是被包围的，替换。</li>
</ul>
<p>由于并查集我们一般用一维数组来记录，方便查找 parants，所以我们将二维坐标用 node 函数转化为一维坐标。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = board.length;</span><br><span class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用一个虚拟节点, 边界上的O 的父节点都是这个虚拟节点</span></span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(rows * cols + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> dummyNode = rows * cols;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) {</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) {</span><br><span class="line">                    <span class="comment">// 遇到O进行并查集操作合并</span></span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || i == rows - <span class="number">1</span> || j == <span class="number">0</span> || j == cols - <span class="number">1</span>) {</span><br><span class="line">                        <span class="comment">// 边界上的O,把它和dummyNode 合并成一个连通区域.</span></span><br><span class="line">                        uf.union(node(i, j), dummyNode);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="comment">// 和上下左右合并成一个连通区域.</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; board[i - <span class="number">1</span>][j] == <span class="string">'O'</span>)</span><br><span class="line">                            uf.union(node(i, j), node(i - <span class="number">1</span>, j));</span><br><span class="line">                        <span class="keyword">if</span> (i &lt; rows - <span class="number">1</span> &amp;&amp; board[i + <span class="number">1</span>][j] == <span class="string">'O'</span>)</span><br><span class="line">                            uf.union(node(i, j), node(i + <span class="number">1</span>, j));</span><br><span class="line">                        <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; board[i][j - <span class="number">1</span>] == <span class="string">'O'</span>)</span><br><span class="line">                            uf.union(node(i, j), node(i, j - <span class="number">1</span>));</span><br><span class="line">                        <span class="keyword">if</span> (j &lt; cols - <span class="number">1</span> &amp;&amp; board[i][j + <span class="number">1</span>] == <span class="string">'O'</span>)</span><br><span class="line">                            uf.union(node(i, j), node(i, j + <span class="number">1</span>));</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) {</span><br><span class="line">                <span class="keyword">if</span> (uf.isConnected(node(i, j), dummyNode)) {</span><br><span class="line">                    <span class="comment">// 和dummyNode 在一个连通区域的,那么就是O；</span></span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">node</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> i * cols + j;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>题解出自@<a href="https://leetcode-cn.com/problems/surrounded-regions/solution/bfsdi-gui-dfsfei-di-gui-dfsbing-cha-ji-by-ac_pipe/" target="_blank" rel="noopener">Ac_pipe</a></strong></p>
<h3 id="最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！"><a href="#最后，不经历风雨-怎能在计算机的大山之顶看见彩虹呢！-无论怎样，相信明天一定会更好！！！！！" class="headerlink" title="最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！"></a><strong>最后，不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</strong></h3><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>深度优先搜索</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记之pip的基础使用</title>
    <url>/pip/</url>
    <content><![CDATA[<h2 id="粗略学习了pip的基础知识，便将此作为学习笔记记录下来同样希望分享的能帮到大家！"><a href="#粗略学习了pip的基础知识，便将此作为学习笔记记录下来同样希望分享的能帮到大家！" class="headerlink" title="粗略学习了pip的基础知识，便将此作为学习笔记记录下来同样希望分享的能帮到大家！"></a>粗略学习了pip的基础知识，便将此作为学习笔记记录下来同样希望分享的能帮到大家！</h2><p>如果自己电脑没有pip,小澈在此分享如何安装，解决办法很多呢</p>
<p>1、使用easy_install安装： <a id="more"></a>各种进入到easy_install脚本的目录下，然后运行easy_inatall pip</p>
<p>2、使用get-pip.py安装： 在下面的url下载get-pip.py脚本 curl <a href="https://bootstrap.pypa.io/get-pip.py" target="_blank" rel="noopener">https://bootstrap.pypa.io/get-pip.py</a> -o get-pip.py 然后运行：python get-pip.py 这个脚本会同时安装setuptools和wheel工具。</p>
<p>3、在linux下使用包管理工具安装pip： 例如，ubuntu下：<code>sudo apt-get install python-pip</code>。Fedora系下：sudo yum install python-pip</p>
<p>4、在windows下安装pip： 在C:\python27\scirpts下运行<code>easy_install pip</code>进行安装。<br>刚安装完毕的pip可能需要先升级一下自身： 在Linux或masOS中：pip install -U pip 在windows中：<code>python -m pip install -U pip</code></p>
<h2 id="一、基础使用"><a href="#一、基础使用" class="headerlink" title="一、基础使用"></a>一、基础使用</h2><p>1、在命令行下，输入pip，回车可以看到帮助说明：<br><img src="https://img-blog.csdnimg.cn/2020032115483851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMzMzkzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2、以安装pillow模块为例。输入pip install pillow（我经过了换源），安装过程如下图<br><img src="https://img-blog.csdnimg.cn/20200321155107882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMzMzkzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="命令集锦"><a href="#命令集锦" class="headerlink" title="命令集锦"></a>命令集锦</h2><p>3、 指定版本安装<br>安装特定版本的package，通过使用==, &gt;=, &lt;=, &gt;, &lt;来指定一个版本号。 <code>pip install 'Markdown&lt;2.0' pip install 'Markdown&gt;2.0,&lt;2.0.3</code></p>
<p>4、卸载已安装的库<br><code>pip uninstall pillow</code></p>
<p>5、 列出已经安装的库<br><code>pip list</code></p>
<p>6、 将已经安装的库列表保存到文本文件中<br><code>pip freeze &gt; requirements.txt</code></p>
<p>这个功能非常常用、好用！经常被用作项目环境依赖文件。</p>
<p>7、 根据依赖文件批量安装库<br><code>pip install -r requirements.txt</code></p>
<p>使用上面的txt文件，批量安装第三方库。</p>
<p>8、使用wheel文件安装<br>除了使用上面的方式联网进行安装外，还可以将安装包也就是wheel格式的文件，下载到本地，然后使用pip进行安装。比如我在PYPI上提前下载的pillow库的wheel文件，后缀名为whl。</p>
<p>可以使用<code>pip install pillow-x.xxxxxxxx.whl</code>的方式离线进行安装</p>
<p>9、pip源的选择<br>很多时候，比如网络不给力，连接超时、防火墙阻挡等等各种原因，我们可能无法从Python官方的PyPi仓库进行pip安装，这时候可以选择国内的第三方源，推荐使用豆瓣源，速度不错。</p>
<p>总结：<br>pip 是目前 python 包管理的事实标准，2008年发布。它被用作 easy_install 的替代品，但是它仍有大量的功能建立在 setuptools 组件之上。具有十分大的优势，值得朋友们去学习。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>后端</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title>python 安装模块之pip install +模块名的换源写法</title>
    <url>/py_pip/</url>
    <content><![CDATA[<p>1、采用国内源，加速下载模块的速度<br>2、常用pip源（上一篇博客介绍过）：<br>    – 豆瓣：<a href="https://pypi.douban.com/simple" target="_blank" rel="noopener">https://pypi.douban.com/simple</a></p>
<a id="more"></a>

<p>​    – 阿里：<a href="https://mirrors.aliyun.com/pypi/simple" target="_blank" rel="noopener">https://mirrors.aliyun.com/pypi/simple</a><br>3、加速安装的命令：<br>​    – &gt;: pip install -i <a href="https://pypi.douban.com/simple" target="_blank" rel="noopener">https://pypi.douban.com/simple</a> 模块名</p>
<h2 id="永久配置下载源"><a href="#永久配置下载源" class="headerlink" title="永久配置下载源"></a>永久配置下载源</h2><h2 id="Windows系统下"><a href="#Windows系统下" class="headerlink" title="Windows系统下"></a>Windows系统下</h2><p>1、文件管理器文件路径地址栏敲：%APPDATA% 回车，快速进入 C:\Users\电脑用户\AppData\Roaming 文件夹中<br>2、新建 pip 文件夹并在文件夹中新建 pip.ini 配置文件<br>3、新增 pip.ini 配置文件内容</p>
<h2 id="MacOS、Linux"><a href="#MacOS、Linux" class="headerlink" title="MacOS、Linux"></a>MacOS、Linux</h2><p>1、在用户根目录下 ~ 下创建 .pip 隐藏文件夹，如果已经有了可以跳过<br>    <code>-- mkdir ~/.pip</code><br>2、进入 .pip 隐藏文件夹并创建 pip.conf 配置文件<br>    <code>-- cd ~/.pip &amp;&amp; touch pip.conf</code><br>3、启动 Finder(访达) 按 cmd+shift+g 来的进入，输入 ~/.pip 回车进入<br>4、新增 pip.conf 配置文件内容</p>
<h2 id="配置文件内容"><a href="#配置文件内容" class="headerlink" title="配置文件内容"></a>配置文件内容</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = http://pypi.douban.com/simple</span><br><span class="line">[install]</span><br><span class="line">use-mirrors =true</span><br><span class="line">mirrors =http://pypi.douban.com/simple/</span><br><span class="line">trusted-host =pypi.douban.com</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>后端</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pip</tag>
        <tag>镜像</tag>
      </tags>
  </entry>
  <entry>
    <title>解决虚拟机中linux系统无法使用本机无线wifi联网的问题</title>
    <url>/linux_wifi/</url>
    <content><![CDATA[<p>最近使用Linux系统来玩一玩，找到了国产Deepping,在安装双系统的过程中发生了一系列的错误，结果都是第一次开机能使用，第二次开机都挂起在了开机页面，试过了很多种方法，总结出来还是自己的笔记本太low，显卡不行哎，只能能被迫转战VMware Workstation ，VMware Workstation安装系统十分简单，简单的next就完成了，我安装了一个deepping,一个Ubuntu，在使用Ubuntu的过程中没啥毛病，但就是deeping系统无法做到与Windows的无线网络连接（因为我我没有无线网卡，也没有网线，只能连接局域网，哎）,导致不能上网，后来在网上查阅资料，整理出来了这么一篇解决的博文，希望能对大家有所帮助。</p>
<a id="more"></a>

<p>注：<br>deepping操作系统镜像;<br><a href="%E9%93%BE%E6%8E%A5%EF%BC%9Ahttps://pan.baidu.com/s/1OUKz32XhVeM2L4r25lFzvw">网盘下载地址</a><br>提取码：3fgz</p>
<h2 id="1-打开Win10网络配置，操作如下："><a href="#1-打开Win10网络配置，操作如下：" class="headerlink" title="1. 打开Win10网络配置，操作如下："></a>1. 打开Win10网络配置，操作如下：</h2><p><img src="https://img-blog.csdnimg.cn/20200321105219605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMzMzkzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200321105227900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMzMzkzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2-在虚拟机菜单中进行配置，选择编辑-gt-虚拟网络编辑器-按照以下方法进行配置："><a href="#2-在虚拟机菜单中进行配置，选择编辑-gt-虚拟网络编辑器-按照以下方法进行配置：" class="headerlink" title="2. 在虚拟机菜单中进行配置，选择编辑->虚拟网络编辑器 ,按照以下方法进行配置："></a>2. 在虚拟机菜单中进行配置，选择编辑-&gt;虚拟网络编辑器 ,按照以下方法进行配置：</h2><p><img src="https://img-blog.csdnimg.cn/20200321105236917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMzMzkzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200321105245791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMzMzkzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="3-设置Linux系统的网络适配器，使用NAT模式，如下操作："><a href="#3-设置Linux系统的网络适配器，使用NAT模式，如下操作：" class="headerlink" title="3. 设置Linux系统的网络适配器，使用NAT模式，如下操作："></a>3. 设置Linux系统的网络适配器，使用NAT模式，如下操作：</h2><p><img src="https://img-blog.csdnimg.cn/20200321105257783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMzMzkzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="4-进入linux-系统中进行配置，点击系统-gt-网络设置，并进行如下设置："><a href="#4-进入linux-系统中进行配置，点击系统-gt-网络设置，并进行如下设置：" class="headerlink" title="4. 进入linux 系统中进行配置，点击系统->网络设置，并进行如下设置："></a>4. 进入linux 系统中进行配置，点击系统-&gt;网络设置，并进行如下设置：</h2><p><img src="https://img-blog.csdnimg.cn/20200321105306410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMzMzkzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="5-重启Linux系统，完成配置过程；"><a href="#5-重启Linux系统，完成配置过程；" class="headerlink" title="5. 重启Linux系统，完成配置过程；"></a>5. 重启Linux系统，完成配置过程；</h2><p>不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！！</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
        <category>Debug</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>Linux</tag>
        <tag>wifi</tag>
        <tag>联网</tag>
      </tags>
  </entry>
  <entry>
    <title>解决python语言的工具pycharm以及Windows电脑安装pygame模块的问题</title>
    <url>/pygame_py/</url>
    <content><![CDATA[<p>人生苦短，我用python，python作为一门当今时代潮流性的语言，已经成为大多数的年轻程序猿们向往的目标，python中有许多的库，</p>
<p>其中有一个pygame库是作为开发2D游戏必不可少的开发库，是一个很完整的2D游戏模块，相信很多小伙伴用python开发游戏一定听说过它。</p>
<a id="more"></a>

<p>但是安装pygame时总是会出现各种各样的问题，使用pip安装pygame提示出错。</p>
<p>下面小澈就手把手教大家怎么样从头到尾安装pygame这个2D游戏模块。</p>
<p>首先，第一个原始的笨方法</p>
<p>（安装pygame的前提是你的电脑里面有python编译器哦）</p>
<h2 id="1、在pycharm中点击fie——-gt-setting——-gt-Project-Interpreter"><a href="#1、在pycharm中点击fie——-gt-setting——-gt-Project-Interpreter" class="headerlink" title="1、在pycharm中点击fie——>setting——>Project Interpreter"></a>1、在pycharm中点击fie——&gt;setting——&gt;Project Interpreter</h2><p><img src="https://img-blog.csdnimg.cn/20200321103954196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMzMzkzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2、点击加号，里面搜索pygame-后点击安装"><a href="#2、点击加号，里面搜索pygame-后点击安装" class="headerlink" title="2、点击加号，里面搜索pygame 后点击安装"></a>2、点击加号，里面搜索pygame 后点击安装</h2><p><img src="https://img-blog.csdnimg.cn/20200321104036712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMzMzkzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="3、如果你直接安装成功，后面的方法你都可以直接忽略了。"><a href="#3、如果你直接安装成功，后面的方法你都可以直接忽略了。" class="headerlink" title="3、如果你直接安装成功，后面的方法你都可以直接忽略了。"></a>3、如果你直接安装成功，后面的方法你都可以直接忽略了。</h2><h2 id="二、下一种方法"><a href="#二、下一种方法" class="headerlink" title="二、下一种方法"></a><strong>二、下一种方法</strong></h2><h2 id="1、首先，我们直接进入官网，在PIPY里面搜索pygame，在download-里面找到适合自己python版本的pygame（cp38代表python版本，因为我的是python3-8，所以我选的也是3-8版本）"><a href="#1、首先，我们直接进入官网，在PIPY里面搜索pygame，在download-里面找到适合自己python版本的pygame（cp38代表python版本，因为我的是python3-8，所以我选的也是3-8版本）" class="headerlink" title="1、首先，我们直接进入官网，在PIPY里面搜索pygame，在download 里面找到适合自己python版本的pygame（cp38代表python版本，因为我的是python3.8，所以我选的也是3.8版本）"></a>1、首先，我们直接进入官网，在PIPY里面搜索pygame，在download 里面找到适合自己python版本的pygame（cp38代表python版本，因为我的是python3.8，所以我选的也是3.8版本）</h2><p><img src="https://img-blog.csdnimg.cn/20200321104058273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMzMzkzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200321104108144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMzMzkzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200321104118745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMzMzkzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2将下载后的whl文件放入自己python38的文件下的LIb下的site-packages文件夹里"><a href="#2将下载后的whl文件放入自己python38的文件下的LIb下的site-packages文件夹里" class="headerlink" title="2将下载后的whl文件放入自己python38的文件下的LIb下的site-packages文件夹里"></a>2将下载后的whl文件放入自己python38的文件下的LIb下的site-packages文件夹里</h2><p><img src="https://img-blog.csdnimg.cn/20200321104148297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMzMzkzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200321104159303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMzMzkzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p> <img src="https://img-blog.csdnimg.cn/202003211042071.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMzMzkzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="3、然后将shift-鼠标右键点住site-packages文件夹在此处打开命令窗口，输入pip-install-pygame-1-9-6-cp38-cp38-win-amd64-whl-这个是你下载的版本名。然后回车即可开始安装）-4、最后win-R-cmd-输入python后回车，再输入import-pygame，验证是否成功。"><a href="#3、然后将shift-鼠标右键点住site-packages文件夹在此处打开命令窗口，输入pip-install-pygame-1-9-6-cp38-cp38-win-amd64-whl-这个是你下载的版本名。然后回车即可开始安装）-4、最后win-R-cmd-输入python后回车，再输入import-pygame，验证是否成功。" class="headerlink" title="3、然后将shift+鼠标右键点住site-packages文件夹在此处打开命令窗口，输入pip install pygame-1.9.6-cp38-cp38-win_amd64.whl(这个是你下载的版本名。然后回车即可开始安装） 4、最后win+R cmd 输入python后回车，再输入import pygame，验证是否成功。"></a>3、然后将shift+鼠标右键点住site-packages文件夹在此处打开命令窗口，输入<code>pip install pygame-1.9.6-cp38-cp38-win_amd64.whl</code>(这个是你下载的版本名。然后回车即可开始安装） 4、最后win+R cmd 输入python后回车，再输入import pygame，验证是否成功。</h2><p><img src="https://img-blog.csdnimg.cn/20200321104223146.png" alt="在这里插入图片描述"></p>
<h2 id="三、笨方法讲完了，讲一下升一级的方法"><a href="#三、笨方法讲完了，讲一下升一级的方法" class="headerlink" title="三、笨方法讲完了，讲一下升一级的方法"></a>三、笨方法讲完了，讲一下升一级的方法</h2><h2 id="1、在pipy里面下载的若是如下图的文件"><a href="#1、在pipy里面下载的若是如下图的文件" class="headerlink" title="1、在pipy里面下载的若是如下图的文件"></a>1、在pipy里面下载的若是如下图的文件</h2><p><img src="https://img-blog.csdnimg.cn/20200321104233518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMzMzkzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2、则将下载好的压缩文件解压到python的lib目录下（前面有详细讲lib-这里就不详细了）-3、直接打开命令行窗口输入python-m-pip-install-–user-pygame，然后回车。"><a href="#2、则将下载好的压缩文件解压到python的lib目录下（前面有详细讲lib-这里就不详细了）-3、直接打开命令行窗口输入python-m-pip-install-–user-pygame，然后回车。" class="headerlink" title="2、则将下载好的压缩文件解压到python的lib目录下（前面有详细讲lib,这里就不详细了） 3、直接打开命令行窗口输入python -m pip install –user pygame，然后回车。"></a>2、则将下载好的压缩文件解压到python的lib目录下（前面有详细讲lib,这里就不详细了） 3、直接打开命令行窗口输入python -m pip install –user pygame，然后回车。</h2><p> <img src="https://img-blog.csdnimg.cn/20200321104244228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMzMzkzNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="4、这样就直接安装成功了"><a href="#4、这样就直接安装成功了" class="headerlink" title="4、这样就直接安装成功了"></a>4、这样就直接安装成功了</h2><h2 id="四、再说一个再升一级的方法，在你有pip的前提下可以使用"><a href="#四、再说一个再升一级的方法，在你有pip的前提下可以使用" class="headerlink" title="四、再说一个再升一级的方法，在你有pip的前提下可以使用"></a>四、再说一个再升一级的方法，在你有pip的前提下可以使用</h2><p>1、以管理员身份启动命令提示符，输入<code>pip --version</code> 查看自己的pip版本或者直接输入<code>py -m pip install -U pygame==1.9.6 -i https://pypi.tuna.tsinghua.edu.cn/simple</code> 测试能否直接安装pygame，</p>
<p>注：# ==后面的语句意思是国外网速较慢，更换为国内清华大学的镜像源下载速度可以加快很多很多，如果不介意下载速度，可以直接忽略</p>
<p>加快安装速度可以使用国内镜像源。清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a></p>
<p>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a></p>
<p>华中理工大学：<a href="http://pypi.hustunique.com/" target="_blank" rel="noopener">http://pypi.hustunique.com/</a></p>
<p>山东理工大学：<a href="http://pypi.sdutlinux.org/" target="_blank" rel="noopener">http://pypi.sdutlinux.org/</a></p>
<p>豆瓣：<a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a></p>
<p>2.如果出现<code>WARNING: You are using pip version 19.2.3, however version 20.0.2 is available.</code><br><code>You should consider upgrading via the 'python -m pip install --upgrade pip' command.报错</code><br>说明你的pip版本太低</p>
<p>3.这时输入：<br><code>python -m pip install -U pip # 当然，如果嫌弃下载速度慢同样可以考虑换源</code><br>安装最新版本pip</p>
<p>4.成功后重复2操作</p>
<p>5.输入：<br><code>py -m pygame.examples.aliens</code><br>这是pygame自带的一个游戏，用于检测pygame是否安装成功，如果成功，则会开始运行一个小游戏，否则失败！</p>
<p>总结：</p>
<p>以上所述是小澈给大家介绍的python中pygame安装过程（超级详细），希望对大家有所帮助，如果大家有任何疑问欢迎给我留言，小澈会及时回复大家的！</p>
<p>不经历风雨,怎能在计算机的大山之顶看见彩虹呢！ 无论怎样，相信明天一定会更好！！！！</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>后端</category>
        <category>Debug</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pygame</tag>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World Created</title>
    <url>/hellow_world/</url>
    <content><![CDATA[<h2 id="Hellow-World-的不同语言实现方法，值得了解"><a href="#Hellow-World-的不同语言实现方法，值得了解" class="headerlink" title="Hellow World 的不同语言实现方法，值得了解"></a>Hellow World 的不同语言实现方法，值得了解</h2><p>我们作为一名程序员，在学习不同语言时至少完成了一个“Hello, World!“程序。当我们学习一门新的语言时，“Hello, World!“通常是我们所写的第一个程序。然而学会（了解）不同语言的表达是一个程序猿所必要的，在这里我询问大家，大家从学习编程语言以来，目前能使用多少种语言的基础表达呢？欢迎大家评论区域留言讨论哦。</p>
<a id="more"></a>

<p>在这里，我会带大家经历`一段计算机编程领域的时空之旅。为此，我将向你展示50种不同的编程语言的  “Hello, World!“程序的写法。如果有错也请大家评论区去纠正呢。毕竟在下也不是十分了解。</p>
<h2 id="NO-1-汇编语言-1949"><a href="#NO-1-汇编语言-1949" class="headerlink" title="NO.1. 汇编语言 - 1949"></a>NO.1. 汇编语言 - 1949</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">bdos equ <span class="number">0005</span>H ; BDOS entry point</span><br><span class="line">start: mvi c,<span class="number">9</span> ; BDOS function: output <span class="keyword">string</span></span><br><span class="line">lxi d,msg$ ; address of msg</span><br><span class="line">call bdos</span><br><span class="line">ret ; <span class="keyword">return</span> to CCP</span><br><span class="line">msg$: db <span class="string">'Hello, world!$'</span></span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-2-Fortran-1957"><a href="#NO-2-Fortran-1957" class="headerlink" title="NO.2. Fortran - 1957"></a>NO.2. Fortran - 1957</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">PROGRAM Hello</span><br><span class="line">WRITE (*,*) <span class="string">'Hello, World!'</span></span><br><span class="line">STOP</span><br><span class="line">END</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-3-Lisp-1958"><a href="#NO-3-Lisp-1958" class="headerlink" title="NO.3. Lisp - 1958"></a>NO.3. Lisp - 1958</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">(write-line <span class="string">"Hello, World!"</span>)</span><br><span class="line">NO<span class="number">.4</span>. Cobol - <span class="number">1959</span></span><br><span class="line">IDENTIFICATION DIVISION.</span><br><span class="line">PROGRAM-ID. HELLO-WORLD.</span><br><span class="line">PROCEDURE DIVISION.</span><br><span class="line">DISPLAY <span class="string">"Hello, World!"</span></span><br><span class="line">STOP RUN.</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-5-BASIC-1964"><a href="#NO-5-BASIC-1964" class="headerlink" title="NO.5. BASIC - 1964"></a>NO.5. BASIC - 1964</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">PRINT <span class="string">"Hello, World!"</span></span><br><span class="line">END</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-6-Logo-1968"><a href="#NO-6-Logo-1968" class="headerlink" title="NO.6. Logo - 1968"></a>NO.6. Logo - 1968</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">print [Hello World !]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-7-B-1969"><a href="#NO-7-B-1969" class="headerlink" title="NO.7. B - 1969"></a>NO.7. B - 1969</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">main(</span><br><span class="line">{</span><br><span class="line">putstr(<span class="string">"Hello world!*n"</span>);</span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-8-Pascal-1970"><a href="#NO-8-Pascal-1970" class="headerlink" title="NO.8. Pascal - 1970"></a>NO.8. Pascal - 1970</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">begin</span><br><span class="line">writeln(<span class="string">'Hello, World!'</span>)</span><br><span class="line">end.</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-9-Forth-1970"><a href="#NO-9-Forth-1970" class="headerlink" title="NO.9. Forth - 1970"></a>NO.9. Forth - 1970</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">: HELLO ( -- ) .<span class="string">" Hello, World!"</span> CR ;</span><br><span class="line">HELLO</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-10-C-1972"><a href="#NO-10-C-1972" class="headerlink" title="NO.10. C - 1972"></a>NO.10. C - 1972</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span> {</span><br><span class="line">printf(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-11-Smalltalk-1972"><a href="#NO-11-Smalltalk-1972" class="headerlink" title="NO.11. Smalltalk - 1972"></a>NO.11. Smalltalk - 1972</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">Transcript show: <span class="string">'Hello, world!'</span>; cr.</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-12-Prolog-1972"><a href="#NO-12-Prolog-1972" class="headerlink" title="NO.12. Prolog - 1972"></a>NO.12. Prolog - 1972</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">:- write(<span class="string">'Hello, World!'</span>),nl.</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-13-ML-1973"><a href="#NO-13-ML-1973" class="headerlink" title="NO.13. ML - 1973"></a>NO.13. ML - 1973</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">print <span class="string">"Hello, World!\n"</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-14-Scheme-1975"><a href="#NO-14-Scheme-1975" class="headerlink" title="NO.14. Scheme - 1975"></a>NO.14. Scheme - 1975</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">(display <span class="string">"Hello, World!"</span>) (newline)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-15-SQL-1978"><a href="#NO-15-SQL-1978" class="headerlink" title="NO.15. SQL - 1978"></a>NO.15. SQL - 1978</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">CREATE TABLE <span class="title">message</span> (<span class="params">text <span class="keyword">char</span>(<span class="number">15</span></span>))</span>;</span><br><span class="line"><span class="function">INSERT INTO <span class="title">message</span> (<span class="params">text</span>) <span class="title">VALUES</span> (<span class="params"><span class="string">'Hello, World!'</span></span>)</span>;</span><br><span class="line">SELECT text FROM message;</span><br><span class="line">DROP TABLE message;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-16-C-1980"><a href="#NO-16-C-1980" class="headerlink" title="NO.16. C++ - 1980"></a>NO.16. C++ - 1980</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>)</span> {</span><br><span class="line">cout &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-17-Ada-1983"><a href="#NO-17-Ada-1983" class="headerlink" title="NO.17. Ada - 1983"></a>NO.17. Ada - 1983</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">with Ada.Text_IO;</span><br><span class="line">procedure Hello <span class="keyword">is</span></span><br><span class="line">begin</span><br><span class="line">Ada.Text_IO.Put_Line (<span class="string">"Hello, World!"</span>);</span><br><span class="line">end Hello;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-18-Common-Lisp-1984"><a href="#NO-18-Common-Lisp-1984" class="headerlink" title="NO.18. Common Lisp - 1984"></a>NO.18. Common Lisp - 1984</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">(princ <span class="string">"Hello, World!"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-19-MATLAB-1984"><a href="#NO-19-MATLAB-1984" class="headerlink" title="NO.19. MATLAB - 1984"></a>NO.19. MATLAB - 1984</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">disp(<span class="string">'Hello, World!'</span>)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-20-Eiffel-1985"><a href="#NO-20-Eiffel-1985" class="headerlink" title="NO.20. Eiffel - 1985"></a>NO.20. Eiffel - 1985</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span></span><br><span class="line"><span class="title">HELLO_WORLD</span></span><br><span class="line"><span class="title">create</span></span><br><span class="line"><span class="title">make</span></span><br><span class="line"><span class="title">feature</span></span><br><span class="line"><span class="title">make</span></span><br><span class="line"><span class="title">do</span></span><br><span class="line">print ("Hello, world!%N")</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-21-Objective-C-1986"><a href="#NO-21-Objective-C-1986" class="headerlink" title="NO.21. Objective-C - 1986"></a>NO.21. Objective-C - 1986</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#import &lt;Foundation/Foundation.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>)</span> {</span><br><span class="line">@autoreleasepool {</span><br><span class="line">NSLog(<span class="string">@"Hello, World!"</span>);</span><br><span class="line">　　}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-22-Erlang-1986"><a href="#NO-22-Erlang-1986" class="headerlink" title="NO.22. Erlang - 1986"></a>NO.22. Erlang - 1986</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">io:format(<span class="string">"Hello world!~n"</span>).</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-23-Perl-1987"><a href="#NO-23-Perl-1987" class="headerlink" title="NO.23. Perl - 1987"></a>NO.23. Perl - 1987</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">print <span class="string">"Hello, World!\n"</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-24-Caml-1987"><a href="#NO-24-Caml-1987" class="headerlink" title="NO.24. Caml - 1987"></a>NO.24. Caml - 1987</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">print_string <span class="string">"Hello, World!\n"</span>;;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-25-Tcl-1988"><a href="#NO-25-Tcl-1988" class="headerlink" title="NO.25. Tcl - 1988"></a>NO.25. Tcl - 1988</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">puts <span class="string">"Hello, World!"</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-26-Haskell-1990"><a href="#NO-26-Haskell-1990" class="headerlink" title="NO.26. Haskell - 1990"></a>NO.26. Haskell - 1990</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">main = putStrLn <span class="string">"Hello, World!"</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-27-Python-1991"><a href="#NO-27-Python-1991" class="headerlink" title="NO.27. Python - 1991"></a>NO.27. Python - 1991</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">print(<span class="string">"Hello, World!"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-28-Visual-Basic-1991"><a href="#NO-28-Visual-Basic-1991" class="headerlink" title="NO.28. Visual Basic - 1991"></a>NO.28. Visual Basic - 1991</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Public Sub <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">Debug.Print "Hello, World!"</span></span><br><span class="line"><span class="function">End Sub</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-29-Lua-1993"><a href="#NO-29-Lua-1993" class="headerlink" title="NO.29. Lua - 1993"></a>NO.29. Lua - 1993</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">print(<span class="string">"Hello, World!"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-30-Ruby-1995"><a href="#NO-30-Ruby-1995" class="headerlink" title="NO.30. Ruby - 1995"></a>NO.30. Ruby - 1995</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">puts <span class="string">'Hello, World!'</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-31-Java-1995"><a href="#NO-31-Java-1995" class="headerlink" title="NO.31. Java - 1995"></a>NO.31. Java - 1995</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">HelloWorld</span> {</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> {</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"Hello, World!"</span>);</span><br><span class="line">　　}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-32-JavaScript-1995"><a href="#NO-32-JavaScript-1995" class="headerlink" title="NO.32. JavaScript - 1995"></a>NO.32. JavaScript - 1995</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">document.write(<span class="string">'Hello, World!'</span>);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-33-PHP-1995"><a href="#NO-33-PHP-1995" class="headerlink" title="NO.33. PHP - 1995"></a>NO.33. PHP - 1995</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">&lt;? echo <span class="string">"Hello, World!"</span> ?&gt;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-34-Rebol-1997"><a href="#NO-34-Rebol-1997" class="headerlink" title="NO.34. Rebol - 1997"></a>NO.34. Rebol - 1997</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">print <span class="string">"Hello, World!"</span></span><br><span class="line"></span><br><span class="line">NO<span class="number">.35</span>. ActionScript — <span class="number">1998</span></span><br><span class="line">package {</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HelloWorld</span> {</span><br><span class="line"><span class="function"><span class="keyword">public</span> function <span class="title">HelloWorld</span>(<span class="params"></span>)</span> {</span><br><span class="line">trace(<span class="string">"Hello World !"</span>);</span><br><span class="line">　　　　}</span><br><span class="line">　　}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-36-D-1999"><a href="#NO-36-D-1999" class="headerlink" title="NO.36. D - 1999"></a>NO.36. D - 1999</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">import std.stdio;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span> (<span class="params"></span>)</span> {</span><br><span class="line">writefln(<span class="string">"Hello, World!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-37-C-2000"><a href="#NO-37-C-2000" class="headerlink" title="NO.37. C# - 2000"></a>NO.37. C# - 2000</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HelloWorld</span> {</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> {</span><br><span class="line">Console.WriteLine(<span class="string">"Hello, World!"</span>);</span><br><span class="line">　　}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-38-Groovy-2003"><a href="#NO-38-Groovy-2003" class="headerlink" title="NO.38. Groovy - 2003"></a>NO.38. Groovy - 2003</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">println <span class="string">"Hello, World!"</span></span><br><span class="line"></span><br><span class="line">NO<span class="number">.39</span>. Scala - <span class="number">2003</span></span><br><span class="line"><span class="keyword">object</span> HelloWorld extends App {</span><br><span class="line">println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-40-F-2005"><a href="#NO-40-F-2005" class="headerlink" title="NO.40. F# - 2005"></a>NO.40. F# - 2005</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">printfn <span class="string">"Hello, World!"</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-41-Windows-PowerShell-2006"><a href="#NO-41-Windows-PowerShell-2006" class="headerlink" title="NO.41. Windows PowerShell - 2006"></a>NO.41. Windows PowerShell - 2006</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">echo <span class="string">"Hello, World!"</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-42-Clojure-2007"><a href="#NO-42-Clojure-2007" class="headerlink" title="NO.42. Clojure - 2007"></a>NO.42. Clojure - 2007</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">(println <span class="string">"Hello, World!"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-43-Go-2009"><a href="#NO-43-Go-2009" class="headerlink" title="NO.43. Go - 2009"></a>NO.43. Go - 2009</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">main</span>(<span class="params"></span>)</span> {</span><br><span class="line">fmt.Println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-44-Rust-2010"><a href="#NO-44-Rust-2010" class="headerlink" title="NO.44. Rust - 2010"></a>NO.44. Rust - 2010</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">fn <span class="title">main</span>(<span class="params"></span>)</span> {</span><br><span class="line">println(<span class="string">"Hello, World!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-45-Dart-2011"><a href="#NO-45-Dart-2011" class="headerlink" title="NO.45. Dart - 2011"></a>NO.45. Dart - 2011</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">main() {</span><br><span class="line">print(<span class="string">'Hello, World!'</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-46-Kotlin-—-2011"><a href="#NO-46-Kotlin-—-2011" class="headerlink" title="NO.46. Kotlin — 2011"></a>NO.46. Kotlin — 2011</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">fun <span class="title">main</span>(<span class="params">args: Array&lt;String&gt;</span>)</span> {</span><br><span class="line">println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-47-Ceylon-2011"><a href="#NO-47-Ceylon-2011" class="headerlink" title="NO.47. Ceylon - 2011"></a>NO.47. Ceylon - 2011</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span>(<span class="params"></span>)</span> {</span><br><span class="line">print(<span class="string">"Hello, World!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-48-TypeScript-2012"><a href="#NO-48-TypeScript-2012" class="headerlink" title="NO.48. TypeScript - 2012"></a>NO.48. TypeScript - 2012</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">console.log(<span class="string">"Hello, World!"</span>);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-49-Julia-2012"><a href="#NO-49-Julia-2012" class="headerlink" title="NO.49. Julia - 2012"></a>NO.49. Julia - 2012</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">println(<span class="string">"Hello, World!"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="NO-50-Swift-2014"><a href="#NO-50-Swift-2014" class="headerlink" title="NO.50. Swift - 2014"></a>NO.50. Swift - 2014</h2><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">print(<span class="string">"Hello, World!"</span>)</span><br></pre></td></tr></tbody></table></figure>



<p>总结一下，50种语言的发展来看，大多数语言的设计思想都是互相借鉴的。语言的发展也是逐渐演进的，但不是越强大的语言就越流行。一门语言想要变得流行也是需要一定的机遇的（例如Python），或者是需要有个优质的大腿（例如Java和Dart）。(如果以上代码有问题或者有错的请大家评论区帮忙纠正）</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML+CSS重要知识点总结</title>
    <url>/html_css/</url>
    <content><![CDATA[<h2 id="HTML重要知识点总结"><a href="#HTML重要知识点总结" class="headerlink" title="HTML重要知识点总结"></a>HTML重要知识点总结</h2><p>超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。</p>
<p>您可以使用 HTML 来建立自己的 WEB 站点，HTML 运行在浏览器上，由浏览器来解析。</p>
<ul>
<li>CSS 指层叠样式表 (<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets)</li>
<li>样式定义<strong>如何显示</strong> HTML 元素</li>
<li>样式通常存储在<strong>样式表</strong>中</li>
<li>把样式添加到 HTML 4.0 中，是为了<strong>解决内容与表现分离的问题</strong></li>
<li><strong>外部样式表</strong>可以极大提高工作效率</li>
<li>外部样式表通常存储在 <strong>CSS 文件</strong>中</li>
<li>多个样式定义可<strong>层叠</strong>为一个</li>
</ul>
<a id="more"></a>

<h2 id="一-VSCode配置和插件"><a href="#一-VSCode配置和插件" class="headerlink" title="一. VSCode配置和插件"></a>一. VSCode配置和插件</h2><h3 id="1-1-VSCode配置"><a href="#1-1-VSCode配置" class="headerlink" title="1.1. VSCode配置"></a>1.1. VSCode配置</h3><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">            "type": "chrome",</span><br><span class="line">            "request": "launch",</span><br><span class="line">            "file":"${file}",</span><br><span class="line">            "runtimeExecutable": "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe",</span><br><span class="line">            "name": "Launch Chrome against localhost",</span><br><span class="line">            "url": "http://localhost:8080",</span><br><span class="line">            "userDataDir": "${tmpdir}",</span><br><span class="line">            "sourceMaps": true,</span><br><span class="line">            "webRoot": "${workspaceFolder}"</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="1-2-VSCode插件"><a href="#1-2-VSCode插件" class="headerlink" title="1.2. VSCode插件"></a>1.2. VSCode插件</h3><ul>
<li><p>Beautify</p>
</li>
<li><p>Chinese Language Pack for Visual Studio Code</p>
</li>
<li><p>Chinese Lorem Ipsum</p>
</li>
<li><p>Debugger for Chrome</p>
</li>
<li><p>EJS language support </p>
</li>
<li><p>ESLint</p>
</li>
<li><p>Front Mattter</p>
</li>
<li><p>Language-styles</p>
</li>
<li><p>lit-html</p>
</li>
<li><p>Lorem ipsum</p>
</li>
<li><p>Manta’s Stylus Supremacy</p>
</li>
<li><p>Markdown-formatter</p>
</li>
<li><p>Markdowm+Math</p>
</li>
<li><p>one Dark Pro</p>
</li>
<li><p>Prettier - Code formatter</p>
</li>
</ul>
<h2 id="二-HTML基本元素"><a href="#二-HTML基本元素" class="headerlink" title="二. HTML基本元素"></a>二. HTML基本元素</h2><h3 id="2-1-html元素"><a href="#2-1-html元素" class="headerlink" title="2.1. html元素"></a>2.1. html元素</h3><ul>
<li>根元素</li>
<li>lang属性: 设置语言<ul>
<li>翻译工具</li>
<li>语音合成</li>
</ul>
</li>
</ul>
<h3 id="2-2-head元素"><a href="#2-2-head元素" class="headerlink" title="2.2. head元素"></a>2.2. head元素</h3><ul>
<li>字符编码<ul>
<li>charset=”utf-8”</li>
</ul>
</li>
<li>title</li>
</ul>
<h3 id="2-3-h-p-strong元素"><a href="#2-3-h-p-strong元素" class="headerlink" title="2.3. h/p/strong元素"></a>2.3. h/p/strong元素</h3><h3 id="2-4-code-br-hr元素"><a href="#2-4-code-br-hr元素" class="headerlink" title="2.4. code-br-hr元素"></a>2.4. code-br-hr元素</h3><h3 id="2-5-字体实体"><a href="#2-5-字体实体" class="headerlink" title="2.5. 字体实体"></a>2.5. 字体实体</h3><p>&amp;gt; =&gt; &gt;</p>
<h3 id="2-6-span-div"><a href="#2-6-span-div" class="headerlink" title="2.6. span/div"></a>2.6. span/div</h3><h3 id="2-7-img元素"><a href="#2-7-img元素" class="headerlink" title="2.7. img元素"></a>2.7. img元素</h3><ul>
<li>src属性</li>
<li>alt属性</li>
</ul>
<h3 id="2-8-a元素"><a href="#2-8-a元素" class="headerlink" title="2.8. a元素"></a>2.8. a元素</h3><ul>
<li>href: 指定超链接</li>
<li>target: <ul>
<li>_self</li>
<li>_blank</li>
<li>_parent</li>
<li>_top</li>
<li>指定值</li>
<li>和iframe结合使用</li>
</ul>
</li>
<li>base元素 -&gt; <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></li>
<li>a元素的锚点链接</li>
<li>a元素和img元素结合</li>
</ul>
<h2 id="三-CSS的基本使用"><a href="#三-CSS的基本使用" class="headerlink" title="三. CSS的基本使用"></a>三. CSS的基本使用</h2><h3 id="3-1-CSS引入方式"><a href="#3-1-CSS引入方式" class="headerlink" title="3.1. CSS引入方式"></a>3.1. CSS引入方式</h3><ul>
<li>内联样式 style</li>
<li>文档样式表</li>
<li>外部样式表</li>
</ul>
<h3 id="3-2-CSS常用选择器"><a href="#3-2-CSS常用选择器" class="headerlink" title="3.2. CSS常用选择器"></a>3.2. CSS常用选择器</h3><ul>
<li>统配选择器</li>
<li>元素选择器</li>
<li>id选择器</li>
</ul>
<h3 id="3-3-最常用的CSS属性"><a href="#3-3-最常用的CSS属性" class="headerlink" title="3.3. 最常用的CSS属性"></a>3.3. 最常用的CSS属性</h3><ul>
<li>width</li>
<li>height</li>
<li>color</li>
<li>background-color</li>
<li>font-size</li>
</ul>
<h3 id="3-4-颜色设置方式"><a href="#3-4-颜色设置方式" class="headerlink" title="3.4. 颜色设置方式"></a>3.4. 颜色设置方式</h3><ul>
<li>关键字: red/orange/blue</li>
<li>十六进制: #ffaabb</li>
<li>rgb: rgb(r, g, b)</li>
<li>rgba: rgba(r, g,b,a)</li>
</ul>
<h2 id="四-文字和字体"><a href="#四-文字和字体" class="headerlink" title="四. 文字和字体"></a>四. 文字和字体</h2><h3 id="4-1-文字属性的设置"><a href="#4-1-文字属性的设置" class="headerlink" title="4.1. 文字属性的设置"></a>4.1. 文字属性的设置</h3><ul>
<li>text-decoration<ul>
<li>underline : 下划线</li>
<li>line-through: 删除线</li>
<li>none</li>
<li>overline: 上划线</li>
</ul>
</li>
<li>letter-word-spacing</li>
<li>text-transform(不常用)</li>
<li>text-indent:<ul>
<li>缩进（2em）</li>
</ul>
</li>
<li>text-align:<ul>
<li>内容对齐</li>
<li>left</li>
<li>right</li>
<li>center</li>
<li>行内级元素</li>
</ul>
</li>
</ul>
<h3 id="4-2-字体属性的设置"><a href="#4-2-字体属性的设置" class="headerlink" title="4.2. 字体属性的设置"></a>4.2. 字体属性的设置</h3><ul>
<li>font-size<ul>
<li><em>百分比是基于父元素</em></li>
</ul>
</li>
<li>font-family<ul>
<li>如果希望中英文分别使用不同的字体，应该先将英文字体写在前面，中文字体写在后面</li>
</ul>
</li>
<li>font-weight<ul>
<li>一般是700加粗</li>
</ul>
</li>
<li>font-style<ul>
<li>italic: 斜体</li>
<li>oblique: 文本倾斜显示</li>
</ul>
</li>
<li>font-varient(不常用)</li>
<li>line-height<ul>
<li>等于行高时文本垂直居中（间距等分）</li>
</ul>
</li>
<li>font缩写属性:<ul>
<li>font-size/line-height font-family</li>
<li>style varient weight(前三个可以省略，也可以交换顺序) size/line-height family</li>
</ul>
</li>
</ul>
<h2 id="五-CSS其他选择器"><a href="#五-CSS其他选择器" class="headerlink" title="五.CSS其他选择器"></a>五.CSS其他选择器</h2><h3 id="5-1-属性选择器"><a href="#5-1-属性选择器" class="headerlink" title="5.1. 属性选择器"></a>5.1. 属性选择器</h3><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-attr">[title=<span class="string">"abc"</span>]</span> {</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="5-2-后代和子代选择器"><a href="#5-2-后代和子代选择器" class="headerlink" title="5.2. 后代和子代选择器"></a>5.2. 后代和子代选择器</h3><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">a</span>{</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span>&gt;<span class="selector-tag">a</span> {</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="5-3-相邻兄弟和全兄弟"><a href="#5-3-相邻兄弟和全兄弟" class="headerlink" title="5.3. 相邻兄弟和全兄弟"></a>5.3. 相邻兄弟和全兄弟</h3><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>+<span class="selector-tag">p</span> {</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span>~<span class="selector-tag">p</span> {</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="5-4-交集和并集"><a href="#5-4-交集和并集" class="headerlink" title="5.4. 交集和并集"></a>5.4. 交集和并集</h3><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.box</span> {</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span>, <span class="selector-class">.box</span>{</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="5-5-伪类选择器"><a href="#5-5-伪类选择器" class="headerlink" title="5.5. 伪类选择器"></a>5.5. 伪类选择器</h3><ul>
<li><p>目标伪类: :target</p>
</li>
<li><p>元素状态伪类: :enable</p>
</li>
<li><p>动态伪类:</p>
<ul>
<li>:link：未访问之前的状态</li>
<li>:visited：访问之后的状态</li>
<li>:focus：指当前拥有输入焦点的元素（能接收键盘输入）<ul>
<li>去除a元素的focus效果： a:focus {outline: none;}</li>
</ul>
</li>
<li>:hover：鼠标移动到链接之上的状态</li>
<li>:active：长按未松开的状态</li>
</ul>
</li>
<li><p>结构伪类:</p>
<ul>
<li><p>nth-child：父元素中的第一个子元素</p>
<ul>
<li>数字</li>
<li>n</li>
</ul>
</li>
<li><p>nth-last-child</p>
</li>
<li><p>nth-of-type：只计算同类型的元素</p>
</li>
<li><p>nth-last-of-type</p>
</li>
<li><p>only-child：是父元素中唯一的子元素</p>
</li>
<li><p>root：根元素，就是HTML元素</p>
</li>
<li><p>empty：代表里面完全空白的元素</p>
</li>
<li><p>:not（x）：除什么以外</p>
<ul>
<li>x只能是简单的选择器，不能是组合选择器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-6-伪元素使用"><a href="#5-6-伪元素使用" class="headerlink" title="5.6. 伪元素使用"></a>5.6. 伪元素使用</h3><ul>
<li><p>::first-letter：针对首字母设置属性</p>
</li>
<li><p>::first-line</p>
</li>
<li><p>::before：用来在一个元素的内容之前插入其他内容（可以是文字、图片）</p>
</li>
<li><p>::after：用来在一个元素的内容之后插入其他内容（可以是文字、图片）</p>
<ul>
<li><p>可以用来设置清除浮动的选择器（放在浮动元素的父元素中）</p>
<ul>
<li><h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* 清除浮动 */</span></span><br><span class="line"><span class="selector-class">.clear-fix</span><span class="selector-pseudo">::after</span> {</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clear-fix</span> {</span><br><span class="line">    *zoom: 1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>







</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="六-CSS的特性"><a href="#六-CSS的特性" class="headerlink" title="六. CSS的特性"></a>六. CSS的特性</h2><h3 id="6-1-继承"><a href="#6-1-继承" class="headerlink" title="6.1.继承"></a>6.1.继承</h3><ul>
<li>一般和文字相关的都是可以继承的<ul>
<li>font-size</li>
<li>line-height</li>
<li>color</li>
</ul>
</li>
</ul>
<h3 id="6-2-层叠"><a href="#6-2-层叠" class="headerlink" title="6.2. 层叠"></a>6.2. 层叠</h3><ul>
<li>后面写的会层叠前面</li>
<li>权重:<ul>
<li>!important：10000</li>
<li>内联样式：1000</li>
<li>id: 100</li>
<li>class: 10</li>
<li>元素: 1</li>
</ul>
</li>
<li>多个选择器时权重的比较：<ul>
<li>p从权值最大的开始比较每一种权值的数量多少，数量多的则优先级高，即可结束比较</li>
<li>p如果数量相同，比较下一个较小的权值，以此类推</li>
<li>p如果所有权值比较完毕后，发现数量都相同，就采取“就近原则”</li>
</ul>
</li>
</ul>
<h2 id="七-其他HTML元素"><a href="#七-其他HTML元素" class="headerlink" title="七. 其他HTML元素"></a>七. 其他HTML元素</h2><h3 id="7-1-列表元素"><a href="#7-1-列表元素" class="headerlink" title="7.1. 列表元素"></a>7.1. 列表元素</h3><ul>
<li>ol li：有序</li>
<li>ul li：无序</li>
<li>dl dt dd：定义列表</li>
<li>list-style: 设置li元素前面标记的样式<ul>
<li>desc/circle/square/……</li>
<li>none (重要)：无样式，经常用在像导航栏这样的列表中</li>
</ul>
</li>
</ul>
<h3 id="7-2-table"><a href="#7-2-table" class="headerlink" title="7.2. table"></a>7.2. table</h3><ul>
<li><p>tbody：表格的主题</p>
</li>
<li><p>caaption：表格的标题</p>
</li>
<li><p>thead：表头（配合th：表头单元格）使用</p>
</li>
<li><p>tfoot：页脚（一般不用）</p>
</li>
<li><p>colspan/rowspan：单元格可跨行列数</p>
</li>
<li><p>border-collapse: collapse</p>
<ul>
<li>单元格的合并</li>
</ul>
</li>
</ul>
<h3 id="7-3-表单"><a href="#7-3-表单" class="headerlink" title="7.3.表单"></a>7.3.表单</h3><ul>
<li><p>form</p>
<ul>
<li><p>enctype</p>
<ul>
<li>multipart/form-data：文件上传时必须为这个值，并且method必须是post</li>
</ul>
</li>
<li><p>input: p单行文本输入框、单选框、复选框、按钮等元素</p>
<ul>
<li>type<ul>
<li>text/password/radio/checkbox/button/reset/submit/file</li>
</ul>
</li>
<li>maxlength：允许输入的最大的字数</li>
<li>placeholder: 占位文字</li>
<li>readonly: 只读</li>
<li>disable: 禁用</li>
<li>checked: 默认被选中</li>
<li>name—-value：键值对  名字—-值</li>
</ul>
</li>
<li><p>textarea：多行文本框</p>
</li>
<li><p>select、option：下拉选择框</p>
</li>
<li><p>button：按钮</p>
</li>
<li><p>textarea：多行文本</p>
<ul>
<li>resize: none(禁止缩放)/horizontal(水平)/vertical(垂直)/both（水平垂直）</li>
</ul>
</li>
<li><p>label：表单元素的标题</p>
<ul>
<li><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">laber</span> <span class="attr">for</span>=<span class="string">"username"</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">laber</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>fieldset：表单元素组（整个表单的边框）</p>
</li>
<li><p>legend：fieldset的标题（边框上的信息）</p>
</li>
</ul>
<h2 id="八-CSS元素类型"><a href="#八-CSS元素类型" class="headerlink" title="八. CSS元素类型"></a>八. CSS元素类型</h2><h3 id="8-1-元素的类型"><a href="#8-1-元素的类型" class="headerlink" title="8.1. 元素的类型"></a>8.1. 元素的类型</h3><ul>
<li><p>展示方式</p>
<ul>
<li>块级元素：不能在同一行显示</li>
<li>行内元素：不能设置宽高，只能由内容撑起</li>
</ul>
</li>
<li><p>浏览是否替换方式</p>
<ul>
<li>替换元素</li>
<li>非替换元素</li>
</ul>
</li>
<li><p>display:</p>
<ul>
<li>inline</li>
<li>block</li>
<li>inline-block：同一行显示，并可以设置宽高</li>
<li>none：隐藏</li>
</ul>
</li>
<li><p>visibility:visible/hidden</p>
</li>
<li><p>overflow</p>
<ul>
<li>scroll：滚动机制</li>
<li>auto</li>
<li>visible：内容溢出依旧可见</li>
<li>hidden：溢出直接裁剪</li>
</ul>
</li>
<li><p>元素之间的空隙是如何产生的</p>
<ul>
<li>浮动解决</li>
<li>flex</li>
</ul>
</li>
<li><p>元素的嵌套</p>
<ul>
<li>块级元素可以嵌套行内级元素</li>
<li>p元素不要嵌套div元素</li>
</ul>
</li>
</ul>
<h2 id="九-CSS的盒子模型"><a href="#九-CSS的盒子模型" class="headerlink" title="九. CSS的盒子模型"></a>九. CSS的盒子模型</h2><h3 id="9-1-重要的几个属性"><a href="#9-1-重要的几个属性" class="headerlink" title="9.1. 重要的几个属性"></a>9.1. 重要的几个属性</h3><ul>
<li>content:<ul>
<li>width</li>
<li>height</li>
<li>max-width</li>
<li>min-width</li>
<li>max-height</li>
<li>min-height</li>
</ul>
</li>
<li>padding<ul>
<li>padding缩写属性</li>
</ul>
</li>
<li>margin<ul>
<li>margin缩写属性</li>
<li>传递和折叠问题<ul>
<li>只有上下会传递和折叠</li>
</ul>
</li>
</ul>
</li>
<li>border<ul>
<li>border: 1px solid red;</li>
</ul>
</li>
<li>行内元素:<ul>
<li>width/height/margin-top/margin-bottom无效</li>
<li>padding-top/bottom ， border-top/bottom比较特殊<ul>
<li>看来有设置但是不占据空间</li>
</ul>
</li>
</ul>
</li>
<li>设置圆角效果<ul>
<li>border-radius：参考当前元素的border+padding+width<ul>
<li>4个值的顺序是top-left、top-right、bottom-right、bottom-left（顺时针方向</li>
</ul>
</li>
</ul>
</li>
<li>设置轮廓<ul>
<li>outline</li>
</ul>
</li>
<li>设置阴影<ul>
<li>box-shadow: 第一个是水平方向上的偏移，第二个是垂直方向上的偏移，第三个值是使阴影模糊，第四个是延伸距离，颜色，inset（向内扩散阴影可以省略）色</li>
</ul>
</li>
<li>文字阴影</li>
<li>水平居中的不同方式<ul>
<li>text-align</li>
<li>margin: 0 auto;</li>
</ul>
</li>
</ul>
<h2 id="十-背景的设置"><a href="#十-背景的设置" class="headerlink" title="十. 背景的设置"></a>十. 背景的设置</h2><ul>
<li><p>background-image</p>
<ul>
<li><p>设置背景图片居中显示</p>
<ul>
<li><pre><code class="html">/* 向左移动img的一半 */
           position: relative;
           /* left: -960px; */

           /* 相对于自己移动 */
           transform: translate(-50%);

           /* 向右移动父元素（.box)的一半 */
           margin-left: 50%;
<span class="comment"><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">* background-color</span><br><span class="line"></span><br><span class="line">* background-repeat</span><br><span class="line"></span><br><span class="line">  * repeat:平铺</span><br><span class="line">  * no-repeat:不平铺</span><br><span class="line">  * repeat-x/repeat-y</span><br><span class="line"></span><br><span class="line">* background-size</span><br><span class="line"></span><br><span class="line">  * cover 使图片覆盖整个元素</span><br><span class="line">  * contain：对背景图片进行拉伸，按原来的比例拉伸 </span><br><span class="line">  * 设置百分比 或者具体的大小</span><br><span class="line"></span><br><span class="line">* background-position</span><br><span class="line"></span><br><span class="line">* background-attachment</span><br><span class="line"></span><br><span class="line">  * scroll：背景图片跟随元素一起滚动（默认值）local：背景图片跟随元素以及元素内容一起滚动  fixed：背景图片相对于浏览器窗口固定	</span><br><span class="line"></span><br><span class="line">* background缩写属性:</span><br><span class="line"></span><br><span class="line">* 光标: cursor: pointer</span><br><span class="line"></span><br><span class="line">* 精灵图</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 十一. 定位的使用</span><br><span class="line"></span><br><span class="line">* position:</span><br><span class="line">  * static</span><br><span class="line">    * 非定位元素</span><br><span class="line">  * relative</span><br><span class="line">    * 相对于自己的位置</span><br><span class="line">  * absolute</span><br><span class="line">    * 祖先元素的定位元素</span><br><span class="line">    * 子绝父相</span><br><span class="line">    * 绝对定位---会脱离标准流</span><br><span class="line">  * fixed</span><br><span class="line">    * 相对视口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 十二. 浮动</span><br><span class="line"></span><br><span class="line">* float</span><br><span class="line"></span><br><span class="line">  * left</span><br><span class="line">  * right</span><br><span class="line">  * 脱标 -&gt; block</span><br><span class="line"></span><br><span class="line">* 浮动的六个规则</span><br><span class="line"></span><br><span class="line">  * 定位元素会层叠在浮动元素上面</span><br><span class="line"></span><br><span class="line">  * 浮动元素不能与行内级内容层叠，行内级内容将会被浮动元素推出</span><br><span class="line"></span><br><span class="line">  * 如果元素是向左（右）浮动，浮动元素的左（右）边界不能超出包含块的左（右）边界</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 十三. 补充</span><br><span class="line"></span><br><span class="line">### 13.1. transform</span><br><span class="line"></span><br><span class="line">* translate：平移translate(x, y)</span><br><span class="line"></span><br><span class="line">* scale：缩放：scale(x, y)</span><br><span class="line"></span><br><span class="line">* rotate：旋转：rotate(deg)</span><br><span class="line"></span><br><span class="line">* skew：倾斜：skew(deg, deg)</span><br><span class="line"></span><br><span class="line">* transition：是 transition-property，transition-duration，transition-timing-function 和 transition-delay 的一个简写属性。</span><br><span class="line"></span><br><span class="line">  * 值1 transition-property：要过渡动画的属性名称</span><br><span class="line"></span><br><span class="line">    值2：过渡动画所需的时间</span><br><span class="line"></span><br><span class="line">    值3：动画的变化的曲线</span><br><span class="line"></span><br><span class="line">    值4：动画的延迟等待</span><br><span class="line"></span><br><span class="line">* transform-origin：变形的原点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 13.2. vertical-align</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 13.3. 背景颜色渐变</span><br><span class="line"></span><br><span class="line">* background: linear-gradient</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 13.4. HTML5元素补充</span><br><span class="line"></span><br><span class="line">* 语义化标签:</span><br><span class="line">  * nav：导航元素</span><br><span class="line">  * header：头部元素</span><br><span class="line">  * footer：尾部元素</span><br><span class="line">  * section：定义文档某个区域的元素</span><br><span class="line">  * article：内容元素</span><br><span class="line">  * aside：侧边栏元素</span><br><span class="line">* 多媒体元素</span><br><span class="line">  * video</span><br><span class="line">  * audio</span><br><span class="line">* input补充</span><br><span class="line">  * 属性: autofocus / multiple / size / placeholder</span><br><span class="line">  * type补充</span><br><span class="line">    * email</span><br><span class="line">    * date</span><br><span class="line">    * time</span><br><span class="line"></span><br><span class="line">### 13.5. flex布局</span><br><span class="line"></span><br><span class="line">* flex-container</span><br><span class="line">  * display: flex/inline-flex</span><br><span class="line">  * flex-direction</span><br><span class="line">  * justify-content</span><br><span class="line">  * align-items</span><br><span class="line">  * flex-wrap</span><br><span class="line">  * flex-flow:缩写属性</span><br><span class="line">  * align-content: 多行</span><br><span class="line">* flex-items</span><br><span class="line">  * order</span><br><span class="line">  * align-self</span><br><span class="line">  * flex-grow</span><br><span class="line">  * flex-shrink</span><br><span class="line">  * flex-basis</span><br><span class="line">  * flex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 13.6. 网络字体</span><br><span class="line"></span><br><span class="line">* 使用网络字体</span><br><span class="line">* 字体图标</span><br><span class="line">  * 阿里icon</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 13.7. 动画的补充</span><br><span class="line"></span><br><span class="line">* 关键帧动画</span><br><span class="line">  * @keyframes</span><br><span class="line">  * animation: name duration  function;</span><br><span class="line">* 3D</span><br><span class="line">  * perspective</span><br><span class="line">  * transform-style: preserve-3d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 13.8. 文字的换行</span><br><span class="line"></span><br><span class="line">* white-space: nowrap</span><br><span class="line">* text-overflow: ellipsis;</span><br><span class="line">* overflow: hidden;</span><br><span class="line"></span><br><span class="line">```css</span><br><span class="line">/* 显示两行文本并且显示省略号的方法 */</span><br><span class="line">display: -webkit-box;</span><br><span class="line">-webkit-line-clamp: 2;</span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line">text-overflow: ellipsis;</span><br><span class="line">overflow: hidden;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 显示一行文本并且显示省略号的方法 */</span><br><span class="line">/* 文字超出后是否自动换行 */</span><br><span class="line">white-space: nowrap;</span><br><span class="line">text-overflow: ellipsis;</span><br><span class="line">overflow: hidden;</span><br></pre></td></tr></tbody></table></figure></span>


</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="13-9-移动端适配"><a href="#13-9-移动端适配" class="headerlink" title="13.9. 移动端适配"></a>13.9. 移动端适配</h3><ul>
<li>视口的设置:</li>
</ul>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>rem设置<ul>
<li>相对html字体大小</li>
<li>问题一: 设置不同html的font-size<ul>
<li>媒体查询</li>
<li>js代码</li>
</ul>
</li>
<li>问题二: 动态计算rem值<ul>
<li>vscode插件</li>
<li>webpack postcss-pxtorem</li>
<li>less/sass计算</li>
</ul>
</li>
</ul>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>知识点总结</tag>
      </tags>
  </entry>
</search>
