<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <script type="text/javascript" src="/js/src/dytitle.js"></script>

  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<meta name="google-site-verification" content="DYS4wW8ApxKb0piV2oZl20bMa8kLxtUKxiPM1JT1ZJo" />


  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">
  <script>
    (function(){
        if(''){
            if (prompt('����������') !== ''){
                alert('�������');
                history.back();
            }
        }
    })();
  </script>







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />





  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "03760df2"
    });
  daovoice('update');
  </script>














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="学习笔记,C,考研,807," />





  <link rel="alternate" href="/atom.xml" title="云澈の博客" type="application/atom+xml" />






<meta name="description" content="成都信息工程大学807程序设计基础易错知识点汇总">
<meta property="og:type" content="article">
<meta property="og:title" content="Easy to mix knowledge points of C language">
<meta property="og:url" content="https://liudufu.github.io/knowledge_C_language/index.html">
<meta property="og:site_name" content="云澈の博客">
<meta property="og:description" content="成都信息工程大学807程序设计基础易错知识点汇总">
<meta property="og:image" content="c:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20221101205758024.png">
<meta property="og:image" content="c:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20221101205804892.png">
<meta property="og:image" content="c:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20221103211215842.png">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20180303/4129176_1520062230660_F3CCDD27D2000E3F9255A7E3E2C48800">
<meta property="og:image" content="https://www.nowcoder.com/equation?tex=0%20%5Cle%20e%20%5Cle%20n(n%20-%201)">
<meta property="og:image" content="https://www.nowcoder.com/equation?tex=i(0%20%5Cle%20i%20%5Cle%20n)">
<meta property="article:published_time" content="2023-08-17T09:13:20.000Z">
<meta property="article:modified_time" content="2023-08-17T09:18:25.977Z">
<meta property="article:author" content="云澈">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="C">
<meta property="article:tag" content="考研">
<meta property="article:tag" content="807">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20221101205758024.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://liudufu.github.io/knowledge_C_language/"/>





  <title>Easy to mix knowledge points of C language | 云澈の博客</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '5e442439848b85893d4627c44c1d8971', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	<a href="https://github.com/liudufu" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#FD6C6C; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    
	
	<meta name="google-site-verification" content="DYS4wW8ApxKb0piV2oZl20bMa8kLxtUKxiPM1JT1ZJo" />
	<meta name="baidu-site-verification" content="DPYNeCY4vP" />

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">云澈の博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不经历风雨，怎能见彩虹！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      
        
        <li class="menu-item menu-item-top">
          <a href="/top/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-signal"></i> <br />
            
            TopX
          </a>
        </li>
      
        
        <li class="menu-item menu-item-resources">
          <a href="/resources/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            resources
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liudufu.github.io/knowledge_C_language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="云澈">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://s1.ax1x.com/2020/07/20/UfbOPJ.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="云澈の博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Easy to mix knowledge points of C language</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-08-17T17:13:20+08:00">
                2023-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index">
                    <span itemprop="name">考研</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          
		  
		  

          
            
          

          
          
             <span id="/knowledge_C_language/" class="leancloud_visitors" data-flag-title="Easy to mix knowledge points of C language">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">热度&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
				 <span>℃</span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  23.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  93
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p> 成都信息工程大学807程序设计基础易错知识点汇总</p>
</blockquote>
<a id="more"></a>

<h1 id="🌸易混知识点"><a href="#🌸易混知识点" class="headerlink" title="🌸易混知识点"></a>🌸易混知识点</h1><ol>
<li><p>关于new delete 与malloc free 的联系与区别描述？》</p>
<ul>
<li>用malloc函数需要指定内存分配的字节数并且不能初始化对象，new 会自动调用对象的构造函数</li>
<li>delete 会调用对象的destructor，而free 不会调用对象的destructor</li>
<li>都是在堆上取得内存。</li>
</ul>
</li>
<li><pre><code class="c++"><span class="keyword">char</span> *p1 = <span class="string">"123"</span>, *p2 = <span class="string">"ABC"</span>, str［<span class="number">50</span>］= <span class="string">"xyz"</span>;
<span class="built_in">strcpy</span>(str + <span class="number">2</span>, <span class="built_in">strcat</span>(p1, p2));
<span class="built_in">cout</span> &lt;&lt; str;
&lt;!--￼<span class="number">0</span>--&gt;
 <span class="keyword">char</span> str[<span class="number">20</span>]=<span class="string">"0123456789"</span>; <span class="keyword">int</span> a=<span class="built_in">strlen</span>(str); <span class="comment">//a=10; &gt;&gt;&gt; strlen 计算字符串的长度，以结束符 0x00 为字符串结束。 int b=sizeof(str); //而b=20; &gt;&gt;&gt; sizeof 计算的则是分配的数组 str[20] 所占的内存空间的大小，不受里面存储的内容改变。 上面是对静态数组处理的结果。</span>
 &lt;!--￼<span class="number">1</span>--&gt;</code></pre>
</li>
<li><p><font color="red">return 后面括号的值不一定是函数的值</font>，譬如函数返回值与return 类型不一致需要类型转换，返回值为 int ，retun 3.2 ，那么肯定会进行转换的</p>
</li>
<li><p>实型字面值常量有两种表示方式：小数形式和指数形式</p>
<pre><code>小数形式：由最前面的额正负号，数字0-9和小数点组成，不允许有其他符号；

指数形式；包括指数和尾数两个不可缺少的部分，用符号E(e)分割；E(e)左边是尾数，为十进制整数或小数形式的实数，右边为指数，必须为十进制整数，表示乘以10的多少次方</code></pre></li>
<li><p>BSS（Block Started by Symbol）通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。特点是:可读写的，在程序执行之前BSS段会自动清0。所以，未初始的全局变量在程序执行之前已经成0了。</p>
</li>
<li><p>A.单链表的每个节点都具有唯一的前驱节点和唯一的后继节点，所以当两个单链表存在相交的节点时，这两个链表则同时拥有这个节点，以及这个节点的所有后继节点，当这个公共节点是尾节点时，他们则只含有公共一个节点——-尾节点。</p>
<p>B.快慢指针是判断单链表是否有环的一种方法：两个指针，每次移动的步长为2叫做快指针，每次移动步长为1的指针叫做慢指针。快慢指针同时从头结点出发，当快指针率先到达NULL的时候，则说明此单链表中不存在环，当快指针追上慢指针的时候，说明此单链表中存在环。</p>
<p>C.<font color="red">有环的单向链表和无环的单向链表不能相交</font>，因为当相交的时候，无环的单向链表也会被迫存在一个环，只不过这个环的”起点“可能不是原来单向链表的头结点。</p>
<p>4.两个单向链表之间相交可以存在环。</p>
</li>
<li><p>存在这样的线性表：表中各结点都没有直接前趋和直接后继。–空表</p>
</li>
<li><p>%%d=%%和d</p>
<pre><code>%%在屏幕上显示为%

d还是d

所以是和k没有关系了~</code></pre></li>
<li><p>队列实现方式有链表存储和顺序表存储两种：链表存储可设计为带有尾指针的单链表，即可高效实现入队出队，无需循环链表；顺序表存储为解决存储空间浪费而设计为循环队列。 因此循环队列仅有顺序表存储结构，与循环链表毫无关系。</p>
</li>
<li><p>一个非空的数据结构如果满足以下两个条件：有且只有一个根结点；每一个结点最多有一个前件，也最多有一个后件，则称为线性结构，在数据结构中习惯称为线性表。双向链表结点具有两个指针域，属于线性结构， A 选项错误。循环链表所有结点的指针域都为非空，属于线性结构， B 选项错误。循环链表是链表，循环队列属于队列，队列只能在队尾入队，在排头退队，链表可以在任何位置插入、删除， C 选项错误。双向链表结点具有多个指针域， D 选项正确</p>
</li>
<li><p><font color="red">%X.Ys</font>的格式化输出，X是总长度，<font color="blue">Y是从字符串中从左边取Y位</font>，剩下的位数补空格</p>
</li>
<li><p>对于数据结构课程而言，简单地说，线性结构是n个数据元素的有序（次序）集合。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1．集合中必存在唯一的一个"第一个元素"；</span><br><span class="line"></span><br><span class="line">2．集合中必存在唯一的一个"最后的元素"；</span><br><span class="line"></span><br><span class="line">3．除最后元素之外，其它数据元素均有唯一的"后继"；</span><br><span class="line"></span><br><span class="line">4．除第一元素之外，其它数据元素均有唯一的"前驱"。</span><br><span class="line"></span><br><span class="line">数据结构中线性结构指的是数据元素之间存在着“一对一”的线性关系的数据结构。</span><br><span class="line"></span><br><span class="line">非线性结构：数学用语，其逻辑特征是一个结点元素可能有多个直接前趋和多个直接后继。</span><br><span class="line"></span><br><span class="line">A选项：在链表中，如果每个结点有两个指针域，则该链表一定是非线性结构，错，类似于传统的双链表，一个指向前一个结点，一个指向后一个结点，这种双链表还是一个线性结构。</span><br><span class="line"></span><br><span class="line">B选项：在链表中，如果有两个结点的同一个指针域的值相等，则该链表一定是非线性结构。对，如果有两个结点的同一个指针域的值，那么被指向的这个点，有两个前驱，违背了唯一的特点，所以必须是非线性结构。</span><br><span class="line"></span><br><span class="line">C选项：在链表中，如果每个结点有两个指针域，则该链表一定是线性结构，错。例如变种的双链表，一个指向后继结点，一个指向链表中的任意结点。如果指向同一结点的话，就类似B选项，所以这个选项是错的。</span><br><span class="line"></span><br><span class="line">D选项：在链表中，如果有两个结点的同一个指针域的值相等，则该链表一定是线性结构，错。一个普通的链表中，不同的结点值可以相等，但是这种链表是线性结果。所以这个选项是错的</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>广义表的长度： 若广义表不空，则广义表所包含的元素的个数，叫广义表的长度，数第一层括号内的逗号数目。</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">**广义表的深度： 广义表中括号的最大层数叫广义表的深度。**</span><br><span class="line"></span><br><span class="line">长度：最外层包含元素的个数，即去掉最外层括号后含有的元素个数。</span><br><span class="line"></span><br><span class="line">深度：表中含有括号数最多的括号层数加一。</span><br><span class="line"></span><br><span class="line">head :返回列表的第一个元素，（不带括号）</span><br><span class="line"></span><br><span class="line">tail：返回列表删除第一个元素后剩余的列表（带括号）</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>线性链表中的各元素在存储空间中的位置不一定是连续的，且各元素的存储顺序也是任意的</p>
</li>
<li><p><strong>顺序表中逻辑相邻物理位置必定相邻。单链表中逻辑相邻物理位置不一定相邻。</strong></p>
</li>
<li><p>结构体变量不管其包含有多少个成员，都应当看成是一个整体。在程序运行</p>
<p>   期间，只要在变量的生存期内，所有成员一直驻留在内存中，不可能出现有的成员驻留内 存，有的成员不驻留内存的情况</p>
</li>
<li><p>C 语言中用 <font color="orange">“%%” 打印输出字符 “%”</font>, 所以 %%d, 输出为 %d 两个普通字符 , 而不是格式控制符 “%d” 的含义</p>
</li>
<li><p>ava中只有byte, boolean是一个字节, char是两个字节, 所以对于java来说127不会发生溢出, 输出328</p>
<ul>
<li>但是对于c/c++语言来说, char是一个字节, 会发生溢出, 对127加一发生溢出, <code>0111 1111 --&gt; 1000 0000, 1000 0000</code>为补码-128, 所以结果为<code>200-128=72</code></li>
</ul>
</li>
<li><p>广义表是一个递归的定义，它的元素可以是 (1)单个元素 (2)子表</p>
<pre><code>一对确定的（表头，表尾）可以唯一确定一个广义表：

  1. 表头：广义表的第一个元素(广义) ，可能是一个元素(狭义)，也可能是一个子表(但它作为第一个元素(广义))

  2. 表尾：除表头外其余元素组成的子表，一定是一个表！

举一些特殊的例子：

表A = (e) ，则表头为e，表尾为() 

表B = ( ) ，即空表，长度=0
表C = (( ))，长度=1，表头为( )，表尾为( )   </code></pre></li>
<li><p>拆分二维数组</p>
<pre><code>int a[4][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };

拆分成：

int b[3] = {1, 2, 3 };

int c[3] = {4, 5, 6 };

int d[3] = {7, 8, 9 };

int e[3] = {10, 11, 12 };

\2. 为何拆分？

以“b[3] = {1, 2, 3 }”为例：b是数组第一个元素的地址，这里b相当于整型指针！上述b，c，d，e都是整型指针。

那么就有：a[4] = { b, c, d, e };

这是一个一维数组，其中的**元素都是整型指针**。a是什么？是数组a中第一个元素b的地址！

根据上述这种理解，发现可以很方便的解出这道题。

分析：AC选项先看“int ( * prt)[3]=a”,相当于：int b[3];int *prt = &amp;b;

即定义了一个指向“数组第一个元素的地址”的指针prt；而从1,2分析来看，a表示的正是b的地址。所以，这里等价于：prt = a。

我们看AC选项，先把ptr都换成a。

A：* (( * prt+1)[2])

*a 即a[0]，也就是b；

( b+1) 表示 元素2的地址，也就是a[0][1]的地址；

(b+1)[2] → *( (b+1) + 2 ) = *(b+3) = b[3]，越界了！其实就是c[0]，VS上验证过，输出也是4.

而答案提供的相当于*(b[3])，连数组元素都算不上！

*注：**下标和指针转化公式：***(a+n) = a[n]*

C：( * prt+1)+2( * a+1)+2 等价于(b+1) + 2 = b+3，是4的地址，也就是c[0]的地址；同样错误。不过可以验证*(( * prt+1)+2)，输出为4.

5. B选项分析：* ( * (p+5))

int *p = a[0]，相当于int *p = b，遇到p直接用b替换就行了！* (p+5)等价于b[5]，也就是c[2]，元素6，前面还多个*，所以这个错的也很明显。

6. D选项

**下标和指针转化公式：*****(a+n) = a[n]**，这个正反都可以使用，而且很好用。</code></pre></li>
<li><p>%% 可以输出 %</p>
</li>
<li><p>用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。</p>
</li>
<li><p>不同数据类型之间的差别在于数据的表示范围及精度上，一般情况下，数据的表示范围越大、精度越高，其类型也越“高级”。</p>
<ul>
<li><p>赋值运算中<font color="blue">如果左值精度比右值精度低，将会出现截断</font>，会导致精度丢失。</p>
</li>
<li><p>当函数调用时，所传实参与形参类型不一致时，也会把<font color="red">实参自动转换为形参类型</font>后再赋值（<font color="red">类型以形参为准</font>）</p>
</li>
</ul>
</li>
<li><p>C++</p>
<ol>
<li><p>char、short、int、long、bool 基本类型都可以用于switch语句。</p>
</li>
<li><p>float、double都不能用于switch语句。</p>
<ol start="3">
<li>enum类型，即枚举类型可以用于switch语句。</li>
<li>所有类型的对象都不能用于switch语句。</li>
<li>字符串也不能用于switch语句</li>
</ol>
</li>
</ol>
</li>
<li><p>C语言中的文件的存储方式有（可以<font color="green">顺序存取，也可随机存取</font>）</p>
</li>
<li><p>C语言是一种<font color="cyan">结构化</font>程序设计语言</p>
</li>
<li><p>空指针是一<strong>个特殊的指针值。</strong></p>
<ul>
<li>空指针是指可以确保没有指向任何一个对象的指针。通常使用宏定义NULL来表示空指针常量值。<font color="blue">NULL就代表系统的0地址单元</font></li>
<li><font color="blue">空指针确保它和任何非空指针进行比较都不会相等</font>，因此经常作为函数发生异常时的返回值使用。     </li>
</ul>
</li>
<li><p>在printf中的%作为转义符，两个%才相当于1个%</p>
</li>
<li><p>free掉一个指针后，指针的值是不会自动置为NULL的，当然其指向的内存已经被释放，可以重新分配给其他进行使用，此时该指针被称为<strong>野指针</strong>。</p>
<ul>
<li>对野指针进行操作，可能会破坏内存结构，因为并不知道当前指针指向的内容是什么，所以一般在free操作结束后，由程序猿将指针置为NULL。</li>
</ul>
</li>
<li><p>C语言的指针的数据类型声明的是<font color="red">指针实际指向内容的数据类型</font></p>
</li>
<li><p><font color="red">c = c^32</font> 大小写互换</p>
</li>
<li><p>当顺利执行了文件关闭操作时，<code>fclose</code>函数的<strong>返回值</strong>是：如果<font color="red">正常</font>关闭了文件，则函数返回值为<font color="red">0</font>；否则，返回值为非0</p>
</li>
<li><p>以下函数用法正确的个数是：</p>
<pre><code><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="built_in">array</span>[MAX_CHAR+<span class="number">1</span>],i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;= MAX_CHAR;i++){</span><br><span class="line">        <span class="built_in">array</span>[i] = i;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">char</span>*<span class="title">test2</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">char</span> p[] = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">char</span> *p = test2();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    str++;</span><br><span class="line">    *str = <span class="string">'0'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

&gt; 重点不在于CHAR_MAX的取值是多少，而是在于i的取值范围是多少。
&gt;
&gt; 一般char的取值范围是-128到127，而u char 则是0~255，所以i的取值范围是0~255.
&gt;
&gt; 所以当CHAR_MAX常量大于255时，执行i++后，i不能表示256以上的数字，所以导致无限循环。
&gt;
&gt; 第二个问题：
&gt;
&gt; 重点在于函数中p的身份，他是一个指针，还是数组名；
&gt;
&gt; 如果是指针p，则p指向存放字符串常量的地址，返回p则是返回字符串常量地址值，调用函数结束字符串常量不会消失（是常量）。所以返回常量的地址不会出错。
&gt;
&gt; 如果是数组p，则函数会将字符串常量的字符逐个复制到p数组里面，返回p则是返回数组p，但是调用函数结束后p被销毁，里面的元素不存在了。
&gt;
&gt; 例子中p是数组名，所以会出错，p所指的地址是随机值。
&gt;
&gt; 若是把char p[]="hello";改成char *p="hello";就可以了。
&gt;
&gt; 第三个问题：
&gt;
&gt; 重点在于str++;这实际的语句就是str=str+1;而str是数组名，数组名是常量，所以不能给常量赋值。（可以执行str+1，但是不能str=.）</code></pre></li>
<li><p>feesk中seek_end 的<strong>文件末尾指针</strong>在<font color="red">末尾最后一个字符后面</font>，而非最后一个字符</p>
</li>
<li><p>使用”w”写文件也可以使用fwrite </p>
</li>
<li><p>对于32位系统，定义 <code>int **a[3][4],</code> 则变量a占有的内存空间为</p>
<ul>
<li>此处定义的是指向指针的指针数组，对于32位系统，指针占内存空间4字节，因此总空间为3×4×4＝48。</li>
</ul>
</li>
</ol>
<p>​           用右左法则来看，首先往变量a的右边看，是【3】，再往左看，是<em>，所以它首先是一个指针数组，数组里存放3个指针，然后再往右看是【4】，再往左看，是int *，说明前面3个指针每个指针都指向一个数组，每个数组里存放4个int *类型的指针，所以3</em>4有12个二级指针，每个指针在32位系统占4个字节，所以48个字节<br>​<br>​           可以从简单到难进行理解，<code>int *a[3]</code>是一个指针数组数组中的每个元素就是一个指针，a的大小是<code>3*4 = 12；int *a[3][4]</code>是一个二维的指针数组，数组中的每一个元素是一个指针，a的大小是<code>3*4*4 = 48</code>；<code>int **a[3]</code>也是一个指针数组，只不过该数组的元素是一个二级指针，但是二级指针的本质还是指针，所以a的大小是<code>3*4 = 12</code>；<code>int **a[3][4]</code>是一个二维数组，数组中的每一个元素是一个二级指针，所以a的大小是<code>3*4*4</code> = 48，就这么简单，不需要去分析什么从左到右从右到左看，反而容易搞混;<br>​           因为[]的优先级是大于<em>号的优先级的，所以先从变量名a向右看是<code>a[3][4]</code>是一个二维数组，然后再将该二维数组看作一个整体向左看，int *</em>是一个二级指针，说明该二维数组是一个数据类型为二级指针的指针数组，这种理解方法就跟普通的指针数组理解方式一样，比如：int *a[3]<br>​           我们理解是先向右看是a[3]拥有三个元素的数组，再向左看，int *说明数组的元素类型是整形的指针类型，所以是一个指针数组<br>​          ```</p>
<ol start="92">
<li><p>%3o表示以八进制数形式输出，占3个空格的位置，右对齐，左边多余的位置补</p>
<p>  空格，但实际数据的宽度为4大于规定的宽度，所以此时按实际宽度输出，故第一个y的  输出为│4630│。%8o与%3o的差别就在于输出占8个空格的位置，所以左边要补4个空格， 故第二个y的输出也为│□□□□4630│.<font color="blue">%#8o与%8o的差别只是输出时必须输出八进制前导0</font>，所以第三个y的输出为│□□□04630│.<font color="blue">%08o</font>与%8o的差别只是输出时<font color="blue">左边多余的位置补0</font>，  所以第四个y的输出为│00004630│</p>
</li>
<li><p>2014对应的二进制为：0000 0000 000 0000 0000 0111 1101 1110</p>
<ul>
<li>而<code>x|（x+1）</code>的作用是对一个数中<font color="blue">二进制0的个数进行统计</font></li>
</ul>
</li>
<li><p>1、【编译】是把c源程序翻译成汇编代码：<code>.s</code>； </p>
<p>2、【汇编】是把汇编代码翻译成二进制目标代码：<code>.obj</code></p>
<p>3、【链接】是把多个二进制目标代码文件链接成一个可执行程序；因为一个工程某个文件调用了其他c文件的函数或变量 一个程序需要上面三个步骤才能由源程序变成可执行程序。</p>
</li>
<li><pre><code class="c">      <span class="keyword">union</span> s{
          <span class="keyword">int</span> i;
          <span class="keyword">char</span> c;
          <span class="keyword">float</span> a;
      }temp;
      temp.i = <span class="number">266</span>;
      <span class="built_in">printf</span>(<span class="string">"%d"</span>, temp.c);

      <span class="comment">//输出是10</span>
      因为<span class="number">266</span>&gt;<span class="number">256.</span>也因为temp一共占有四个字节，i和ch共用内存空间，但是ch 只占据最低的一个字节，即最低的<span class="number">8</span>位，所以输出c的值也是只能输出这一字节内存中的二进制数表示的数，如果赋值的i是<span class="number">100</span>,将会正常输出<span class="number">100</span>

&lt;!--￼<span class="number">5</span>--&gt;</code></pre>
</li>
<li><pre><code class="c">      <span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> fromwhere)</span></span>; 

      函数fseek将文件位置指针重定位到fromwhere（SEEK_SET文件头<span class="number">0</span>,SEEK_CUR文件当前位置<span class="number">1</span>,SEEK_END文件末尾<span class="number">2</span>）开始偏移offset个字节的位置；返回成功<span class="number">0</span>，失败<span class="number">-1</span>；

      <span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;

      返回文件位置指针当前位置相对于文件首的偏移字节数；
&lt;!--￼<span class="number">6</span>--&gt;
</code></pre>
</li>
</ol>
<p>对指针变量赋0值和不赋值是不同的。 指针变量未赋值时，值是随机的，是垃圾值，不能使用的，否则将造成意外错误。而指针变量赋0值后，则可以使用，只是它不指向具体的变量而已。</p>
<ol start="102">
<li><p>面试问题</p>
<p>无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。然而面试的时候经常碰见诸如<font color="orange">获取倒数第k个元素</font>，<font color="green">获取中间位置的元素</font>，<font color="cyan">判断链表是否存在环</font>，<font color="blue">判断环的长度</font>等和长度与位置有关的问题。这些问题都可以通过灵活运用双指针来解决。</p>
<blockquote>
<p> Tips：双指针并不是固定的公式，而是一种思维方式~</p>
</blockquote>
<p>  先来看”<font color="orange">倒数第k个元素的问题</font>“。设有两个指针 p 和 q，初始时均指向头结点。首先，先让 p 沿着 next 移动 k 次。此时，p 指向第 k+1个结点，q 指向头节点，两个指针的距离为 k 。然后，同时移动 p 和 q，直到 p 指向空，此时 q 即指向倒数第 k 个结点。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        ListNode *p = head, *q = head; <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">while</span>(k--) {   <span class="comment">//将 p指针移动 k 次</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>) {<span class="comment">//同时移动，直到 p == nullptr</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>  <font color="green">获取中间元素的问题</font>。设有两个指针 fast 和 slow，初始时指向头节点。每次移动时，fast向后走两次，slow向后走一次，直到 fast 无法向后走两次。这使得在每轮移动之后。fast 和 slow 的距离就会增加一。设链表有 n 个元素，那么最多移动 n/2 轮。当 n 为奇数时，slow 恰好指向中间结点，当 n 为 偶数时，slow 恰好指向中间两个结点的靠前一个(可以考虑下如何使其指向后一个结点呢？)。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">下述代码实现了 n 为偶数时慢指针指向靠后结点。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode *p = head, *q = head;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">nullptr</span> &amp;&amp; q-&gt;next != <span class="literal">nullptr</span>) {</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    } </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p> <font color="cyan"> 是否存在环的问题</font>。如果将尾结点的 next 指针指向其他任意一个结点，那么链表就存在了一个环。</p>
<p>  上一部分中，总结快慢指针的特性 —— 每轮移动之后两者的距离会加一。下面会继续用该特性解决环的问题。<br>  当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了追及问题。想象一下在操场跑步的场景，只要一直跑下去，快的总会追上慢的。当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。</p>
<p>  据上述表述得出，如果一个链表存在环，那么快慢指针必然会相遇。实现代码如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>{</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>) {</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast != <span class="literal">nullptr</span>) {</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>  最后一个问题，如果存在环，如何判断环的长度呢？方法是，<font color="blue">快慢指针相遇后继续移动，直到第二次相遇。两次相遇间的移动次数即为环的长度</font>。</p>
</li>
<li><p>由于链表中从高位到低位存放了数字的二进制表示，因此我们可以使用二进制转十进制的方法，在遍历一遍链表的同时得到数字的十进制值。</p>
<p>   以示例 1 中给出的二进制链表为例：</p>
<p>   <img src="C:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20221101205758024.png" alt="image-20221101205758024"></p>
<p>​     表示 n 是二进制整数。<br>   <img src="C:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20221101205804892.png" alt="image-20221101205804892"></p>
<p>   链表的第 1 个节点的值是 1，这个 1 是二进制的最高位，在十进制分解中，1 作为系数对应的 2^2^<br>的指数是 2，这是因为链表的长度为 3。我们是不是有必要一定要先知道链表的长度，才可以确定指数 2 呢？答案是不必要的。</p>
<ul>
<li><p>每读取链表的一个节点值，可以认为读到的节点值是当前二进制数的最低位；</p>
</li>
<li><p>当读到下一个节点值的时候，需要将已经读到的结果乘以 2，再将新读到的节点值当作当前二进制数的最低位；</p>
</li>
<li><p>如此进行下去，直到读到了链表的末尾。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDecimalValue</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) {</span><br><span class="line">            ans = ans * <span class="number">2</span> + cur-&gt;val;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     <span class="number">5</span>÷<span class="number">2</span>=<span class="number">2</span>余<span class="number">1</span> </span><br><span class="line">     <span class="number">2</span>÷<span class="number">2</span>=<span class="number">1</span>余<span class="number">0</span> </span><br><span class="line">     <span class="number">1</span>÷<span class="number">2</span>=<span class="number">0</span>余<span class="number">1</span>  </span><br><span class="line">      ===&gt; 得出二进制 <span class="number">101</span> .</span><br><span class="line">     反推回去 商 x 除数 + 余数 </span><br><span class="line">     =&gt; <span class="number">0</span> x <span class="number">2</span> + <span class="number">1</span> = <span class="number">1</span> </span><br><span class="line">     -&gt; <span class="number">1</span> x <span class="number">2</span> + <span class="number">0</span> = <span class="number">2</span></span><br><span class="line">     -&gt; <span class="number">2</span> x <span class="number">2</span> +<span class="number">1</span> = <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><p>C语言语法规定，字母e或E之前必须要有数字，且e或E后面的指数必须为整数。如e3、5e3.6、<font color="red">.e、e等都是非法</font>的指数形式。</p>
</li>
<li><p><img src="C:%5CUsers%5CASUS%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20221103211215842.png" alt="image-20221103211215842"></p>
</li>
<li><p>在方法体中定义的局部变量在该方法被执行时创建：错</p>
<ul>
<li>不是局部变量再该方法被执行/调用时创建，而是<font color="red">应该为在该变量被声明并赋值时创建，可以理解为当代码执行到该 变量被赋值的代码是才被创建</font>。</li>
</ul>
</li>
<li><p>C语言的源程序加工包括三步：<strong>预处理、编译和链接。</strong></p>
<p>  其中源程序加工的编译阶段又可细分为：预处理，编译，汇编三个阶段。</p>
<p>  即C语言由源代码生成可执行程序的过程为：<strong>C源程序→编译预处理→编译→汇编程序→链接程序→可执行文件</strong>。</p>
  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">①预处理：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、头文件的包含，<span class="meta">#<span class="meta-keyword">include</span>预处理指令。</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、define定义符号的替换</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  预处理指令</span></span><br><span class="line"></span><br><span class="line">注释删除</span><br><span class="line"></span><br><span class="line">②编译：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、把C语言代码翻译成汇编代码。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、语法分析</span><br><span class="line">     </span><br><span class="line"><span class="number">3</span>、词法分析</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、语义分析</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、符号汇总</span><br><span class="line"></span><br><span class="line">③汇编</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、把汇编指令翻译成二进制指令</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、形成符号表</span><br><span class="line"></span><br><span class="line">④链接</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、合并段表</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、符号表的合并和符号表的重定位</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>函数fscanf不能从标准输入流读取数据</strong>   –错</p>
</li>
<li><p><strong>程序员必须明确地用函数fopen打开标准输入流、标准输出流和标准错误流</strong>   –错</p>
</li>
<li><p><strong>程序必须明确地调用函数fclose关闭文件</strong> – 错</p>
</li>
<li><pre><code class="c"> <span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])
 {
     <span class="keyword">char</span> *p1 = <span class="string">"h</span>
<span class="string">        ello"</span>;
     <span class="keyword">char</span> *p2 = <span class="string">"world"</span>;
     <span class="keyword">char</span> *p3 = <span class="string">"a piece of cake"</span>;
     <span class="keyword">char</span> *str[] = { p1, p2, p3 };
     <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(*str[<span class="number">0</span>]) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="keyword">typeid</span>(str[<span class="number">0</span>]).name() &lt;&lt; <span class="string">" "</span> &lt;&lt; *(str[<span class="number">0</span>] + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//typeid是类型</span>
     <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(*&amp;str[<span class="number">0</span>]) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="keyword">typeid</span>(&amp;str[<span class="number">0</span>]).name() &lt;&lt; <span class="string">" "</span> &lt;&lt; *(&amp;str[<span class="number">0</span>] + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;
     <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(*str) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="keyword">typeid</span>(str).name() &lt;&lt; <span class="string">" "</span> &lt;&lt; *(str + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;
     <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(*&amp;str) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="keyword">typeid</span>(&amp;str).name() &lt;&lt; <span class="string">" "</span> &lt;&lt; *(&amp;str + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;
     <span class="keyword">return</span> <span class="number">0</span>;
 }
 运行结果：
 <span class="number">1</span> <span class="keyword">char</span> * e
 <span class="number">4</span> <span class="keyword">char</span> * * world
 <span class="number">4</span> <span class="keyword">char</span> * [<span class="number">3</span>] world
 <span class="number">12</span> <span class="keyword">char</span> * (*)[<span class="number">3</span>] <span class="number">00F</span>7F734
 能看懂这个你就知道了，这个地方+<span class="number">1</span>的时候都是说步长，步长就是说+<span class="number">1</span>前面的这个对象 所指向的 数据类型的长度，比如 &amp;str[<span class="number">0</span>]类型是<span class="keyword">char</span> * * 所指向的是<span class="keyword">char</span> * 长度是指针的长度（不同机器不同）
&lt;!--￼<span class="number">12</span>--&gt;

如果要输出剩余字符串，可用

</code></pre>
</li>
</ol>
<pre><code><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, ``<span class="string">"%s\n"</span>``, s);</span><br></pre></td></tr></tbody></table></figure></code></pre><ol start="127">
<li><p>● itoa()：将整型值转换为<a href="https://so.csdn.net/so/search?q=字符串&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">字符串</a>。<br>● ltoa()：将长整型值转换为字符串。<br>● ultoa()：将无符号长整型值转换为字符串。<br>● gcvt()：将浮点型数转换为字符串，取四舍五入。<br>● ecvt()：将双精度浮点型值转换为字符串，转换结果中不包含十进制小数点。<br>● fcvt()：指定位数为转换精度，其余同ecvt()。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">itoa()函数有<span class="number">3</span>个参数：第一个参数是要转换的数字，第二个参数是要写入转换结果的目标字符串，第三个参数是转移数字时所用 的基数。在上例中，转换基数为<span class="number">10</span>。<span class="number">10</span>：十进制；<span class="number">2</span>：二进制...</span><br><span class="line"></span><br><span class="line">itoa并不是一个标准的C函数，它是Windows特有的，如果要写跨平台的程序，请用<span class="built_in">sprintf</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">25</span>];</span><br><span class="line">itoa(num, str, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The number 'num' is %d and the string 'str' is %s. \n"</span> ,</span><br><span class="line">num, str);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span> <span class="params">(<span class="keyword">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i,n,sign;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;<span class="built_in">isspace</span>(s[i]);i++)<span class="comment">//跳过空白符;</span></span><br><span class="line">sign=(s[i]==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">if(s[i]=='+'||s[i]==' -')//跳过符号</span><br><span class="line">  i++;</span><br><span class="line"><span class="keyword">for</span>(n=<span class="number">0</span>;<span class="built_in">isdigit</span>(s[i]);i++)</span><br><span class="line">       n=<span class="number">10</span>*n+(s[i]-<span class="string">'0'</span>);<span class="comment">//将数字字符转换成整形数字</span></span><br><span class="line"><span class="keyword">return</span> sign *n;</span><br></pre></td></tr></tbody></table></figure>

<p>● atof()：将字符串转换为双精度浮点型值。<br>● atoi()：将字符串转换为整型值。<br>● atol()：将字符串转换为长整型值。<br>● strtod()：将字符串转换为双精度浮点型值，并报告不能被转换的所有剩余数字。<br>● strtol()：将字符串转换为长整值，并报告不能被转换的所有剩余数字。<br>● strtoul()：将字符串转换为无符号长整型值，并报告不能被转换的所有剩余数字。</p>
</li>
<li><p>int f1(float);<br>int f2(char);<br>void f3(float);<br>int (*pf)(float);</p>
<p>函数指针变量：</p>
<p>函数指针变量的声明方法为：</p>
<p><strong>返回值类型 ( * 指针变量名) ([形参列表]);</strong><br>根据定义，</p>
<p><code>int(*pf)(float);
int (*p)(float)=&amp;f1;</code><br>pf,p都是函数指针变量。</p>
<p>函数地址 ：</p>
<p>在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。</p>
<p>函数地址的获取，可以是函数名，也可以在函数名前加取地址符&amp; 。</p>
<p>C错误是因为函数形参类型不匹配。</p>
<p>函数指针所指向的函数，返回值类型，形参列表必须完全匹配，对函数指针赋值可以采用以下方式<font color="red">pf＝&amp;p1或者pf＝p1 </font></p>
</li>
<li><p>按位运算是对字节或字中的实际位进行检测、设置或移位, 它<strong>只适用于字符型和整数型变量以及它们的变体, 对其它数据类型不适用</strong>。无论是float  还是double,在内存中的存储分为三部分：<strong>符号位，指数位，尾数位；</strong>位运算符对它们没有意义</p>
</li>
<li><p><font color="red">float类型的变量</font>赋值后为什么<font color="red">必须在值后加”f”/“F”</font><br><code>float x = 3.4F;</code><br>这里将“3.4”赋值给float类型的变量x，如果不加F，系统会默认把赋值的数字当作double类型处理 1，然后在把这个double类型的值赋给float类型，这样就会出现精度丢失。<br><code>float y = 3F;</code><br>这里将“3”赋值给float类型的变量y，如果将整数类型的“3”赋值给float，系统会自动将其转化为double类型1，然后再赋值给float类型，这样虽然会编译成功，但会导致精度缺失。<br>常量存储在常量缓冲区中，有且只有一份，常量缓冲区中的值默认空间大小，如果是整数，默认空间大小为32bit—-int，如果是小数，默认空间大小为64bit—-double。 </p>
</li>
<li><p>%f用于输入float,%lf用于输入double,%le用于科学计数法输入double型变量</p>
</li>
<li><p>形参与实参的之间的传递分类</p>
</li>
<li><p>1、<strong>按值传递（实形无联系）</strong></p>
<p>按值传递就是平常编程中经常用到的，定义一个基本数据类型的变量，在调用某函数时把该变量作为函数的实参传递给函数。这种传递方式采用的是单向值传递，实形无联系，形参改变不影响实参。</p>
<p>2、<strong>按地址传递（通过操作形参可能会改变实参）</strong></p>
<p>按地址传递主要出现在函数参数是指针变量、数组等的时候。</p>
<p>注意：</p>
<p>实质上用指针做函数参数的情况下，在调用函数时，将实参变量的传递给形参变量，采取的依然是单向值传递。如果<font color="blue">在被调函数中只是单纯改变了形参指针变量的值</font>，在函数调用结束后这些形参被销毁，是<font color="blue">不会影响调用函数时传入实参指针变量值</font>。</p>
<p><font color="red">只有当你在被调函数中通过操作形参指针变量，去改变了指针指向变量的值时，才可以改变实参指针变量所指向变量的值</font>。也只有这种情况下形参改变才可能影响实参。</p>
</li>
<li><p>假设函数原型和变量说明如下： </p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void f3(int(*p)[4]);``int a[4]={1，2，3，4}，``int b[3][4]={{1，2，3，4}，{5，6，7，8}，{9，10，11，12}};</span><br></pre></td></tr></tbody></table></figure>

<p>  下面调用非法的是</p>
<ul>
<li><pre><code>f3(&amp;a);
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
f3(b[1]);
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
f3(&amp;b[1]);
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
f3(b);

<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">       &gt; 选**B**。根据题目结合选项来看考察的是对函数的传参调用，其中参数涉及到**数组指针** 。 </span><br><span class="line">       &gt;</span><br><span class="line">       &gt; void f3(**int(\*p)[4]**);  其参数是**数组指针** ，指向数组p的指针。</span><br><span class="line">       &gt;</span><br><span class="line">       &gt;</span><br><span class="line">       &gt; - ​    选项A：f3(**&amp;a**); 参数为一个地址，符合指针定义。   </span><br><span class="line">       &gt; - ​    选项B：f3(**b[1]**); 参数为一个数组的具体元素，不符合指针定义。**所以B是非法的调用。**   </span><br><span class="line">       &gt; - ​    选项C：f3(**&amp;b[1]**); 参数为一个数组元素的地址，符合指针定义。   </span><br><span class="line">       &gt; - ​    选项D：f3(**b**); 参数为数组名，表示该数组的首地址，符合指针定义。</span><br><span class="line">       &gt;</span><br><span class="line">       &gt; &lt;font color='red'&gt;`b[1]`和`&amp;b[1]`虽然值相等，但是含义不一样，`&amp;b[1]`是行指针，类型是`int (*)[4]`，和`a`的类型相同；而`b[1]`是个`int *`，和`&amp;b[1][0]`等价。&lt;/font&gt;</span><br><span class="line">       &gt;</span><br><span class="line">       &gt; - b[1]作为第二行数组的数组名，如果单独出现，则表示首元素的地址，即元素b[1][0]的地址，类型是int*；如果加取地址&amp;，变成&amp;b[1]，那么就是整个第二行数组的地址，和函数f(3)要求的形参保持一致，即该指针指向一个整型数组，数组共4个整型元素。并不是所谓的指针的&lt;font color='red'&gt;指针。&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">135. C语言中，&lt;font color='red'&gt;未经赋值&lt;/font&gt;的&lt;font color='red'&gt;全局变量&lt;/font&gt;默认初始化为&lt;font color='red'&gt;0&lt;/font&gt;，**auto类型、register类型不确定**</span><br><span class="line"></span><br><span class="line">136. 所有的&lt;font color='red'&gt;静态局部变量&lt;/font&gt;，即定义在函数内部的`static int name`形式的，默认初始化为&lt;font color='red'&gt;0&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">137. 外部变量可以供其所在的程序文件中的任何函数使用   --- 错误</span><br><span class="line"></span><br><span class="line">     - 全局变量也称为外部变量，它是在函数外部定义的变量，其作用域是从定义该变量的位置开始至源文件结束。全局变量不受作用域的影响（也就是说，全局变量的生命期一直到程序的结束）。 </span><br><span class="line">       -    如果在一个文件中使用extern关键字来声明另一个文件中存在的全局变量，那么这个文件可以使用这个数据。    </span><br><span class="line">       -    在全局变量前加一个static，使该变量只在这个源文件中可用，称之为全局静态变量。</span><br><span class="line"></span><br><span class="line">138. 指针就是地址，因此一个变量的指针就是该变量的地址。请问这句话的说法是正确的吗？   &lt;font color='red'&gt;错误&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">     - &lt;font color='blue'&gt;一个变量的指针指向的内容才是这个变量的地址&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">139. - 若已包含标准库头文件及相关命名空间，用户也可以重新定义标准库函数，但是该函数将失去原有含义  -- &lt;font color='red'&gt;错误&lt;/font&gt;</span><br><span class="line">     - 若已包含标准库头文件及相关命名空间，则系统不允许用户重新定义标准库函数      --&lt;font color='red'&gt;正确&lt;/font&gt;</span><br><span class="line">     - 用户调用标准库函数前，不必使用预编译命令将该函数所在文件包括到用户源文件中     &lt;font color='blue'&gt;错误&lt;/font&gt;</span><br><span class="line">     - 用户调用标准库函数前，必须重新定义    --&lt;font color='blue'&gt;错误&lt;/font&gt;</span><br><span class="line">       - A选项，函数不能重新定义，只能重载，除非换作用域（那也不能叫重新定义）； B选项，&lt;font color='red'&gt;函数可以被重载而不能重新定义&lt;/font&gt;，重载后函数具有不同的形参，原有定义并不失效； C选项，正确； D选项，调用库函数果断需要#include（预处理包含）头文件啊……否则找不到函数定义</span><br><span class="line"></span><br><span class="line">140. 在 while 循环中以 EOF（&lt;font color='red'&gt;-1&lt;/font&gt;） 作为文件结束标志，这种以 EOF 作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的 ASCII 代码值的形式存放。我们知道， ASCII 代码值的范围是 0~255 ，不可能出现 -1 ，因此可以用 EOF 作为文件结束标志</span><br><span class="line"></span><br><span class="line">141. A 选项正确，`int a[10]={0, 0, 0, 0, 0}`; 前 5 个元素为 0，后面 5 个元素编译器补为 0</span><br><span class="line">     B 选项正确，&lt;font color='red'&gt;int a[10]={ }&lt;/font&gt;; 编译器&lt;font color='green'&gt;自动将所有元素置零&lt;/font&gt;</span><br><span class="line">     C 选项正确，`int a[] = {0}`; 编译器自动计算元素个数</span><br><span class="line">     D 选项错误，`int a[10] = {10*a}`;a 是整型数组，10*a 操作非法</span><br><span class="line"></span><br><span class="line">142. 排序方法    平均情况    最好情况    最坏情况    辅助空间    稳定性 </span><br><span class="line"></span><br><span class="line">       冒泡排序     O(n^2)      O(n)       O(n^2)        O(1)        稳定 </span><br><span class="line"></span><br><span class="line">       选择排序     O(n^2)     O(n^2)      O(n^2)        O(1)        不稳定 </span><br><span class="line"></span><br><span class="line">       插入排序     O(n^2)      O(n)       O(n^2)        O(1)        稳定 </span><br><span class="line"></span><br><span class="line">       希尔排序O(n*log(n))~O(n^2) O(n^1.3)    O(n^2)        O(1)       不稳定 </span><br><span class="line"></span><br><span class="line">       堆排序     O(n*log(n))   O(n*log(n))   O(n*log(n))      O(1)       不稳定 </span><br><span class="line"></span><br><span class="line">       归并排序    O(n*log(n))   O(n*log(n))   O(n*log(n))    O(n)          稳定 </span><br><span class="line"></span><br><span class="line">       快速排序    O(n*log(n))   O(n*log(n))    O(n^2)         O(1)       不稳定 </span><br><span class="line"></span><br><span class="line">       冒泡排序经过优化以后，最好时间复杂度可以达到O(n)。设置一个标志位，如果有一趟比较中没有发生任何交换，可提前结束，因此在正序情况下，时间复杂度为O(n)。选择排序在最坏和最好情况下，都必须在剩余的序列中选择最小（大）的数，与已排好序的序列后一个位置元素做交换，依次最好和最坏时间复杂度均为O(n^2)。^</span><br><span class="line"></span><br><span class="line">     插入排序是在把已排好序的序列的后一个元素插入到前面已排好序(需要选择合适的位置)的序列中，在正序情况下时间复杂度为O(n)。堆是完全二叉树，因此树的深度一定是log(n)+1，最好和最坏时间复杂度均为O(n*log(n))。归并排序是将大数组分为两个小数组，依次递归，相当于二叉树，深度为log(n)+1，因此最好和最坏时间复杂度都是O(n*log(n))。快速排序在正序或逆序情况下，每次划分只得到比上一次划分少一个记录的子序列，用递归树画出来，是一棵斜树，此时需要n-1次递归，且第i次划分要经过n-i次关键字比较才能找到第i个记录，因此时间复杂度是\sum_{i=1}^{n-1}(n-i)=n(n-1)/2，即O(n^2)。</span><br><span class="line"></span><br><span class="line">143. 算法的5个基本特征：确定性、有穷性、输入、输出、&lt;font color='red'&gt;可行性&lt;/font&gt;。</span><br><span class="line"></span><br><span class="line">144. 顺序查找的平均时间是多少？——&lt;font color='red'&gt;N/2&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">     - 严格意义上确实 应该是(n+1)/2，因为目标数据可以在任意位置，分别查找1，2，3，4，.......，n次，一共为n*(n+1)/2，所以除以n，平均时间为(n+1)/2</span><br><span class="line"></span><br><span class="line">145. `void hello(int a,int b=7,char* pszC="*");`</span><br><span class="line"></span><br><span class="line">     - hello(5)</span><br><span class="line"></span><br><span class="line">     - hello(5,8)</span><br><span class="line"></span><br><span class="line">     - `hello(6,"#")`</span><br><span class="line"></span><br><span class="line">     - hello(0,0,"#")</span><br><span class="line"></span><br><span class="line">     - &lt;font color='red'&gt;参数从右向左匹配&lt;/font&gt;，C项 a没有匹配到，`&amp;quot`;相当于半个引号，`&amp;quot ;#"=“#”`如上面D选项</span><br><span class="line"></span><br><span class="line">       从左到右我们就说参数是  a   b   c     A，函数从右往左匹配。b,c有现有的就不给了，5给a  </span><br><span class="line"></span><br><span class="line">       B,  8给b,5给a</span><br><span class="line"></span><br><span class="line">        C,  那一坨给了c，6给了b,  没东西给a 。不能跳着给。6给a，b用先有的是不对的。</span><br><span class="line"></span><br><span class="line">        D，挨个给就行了。</span><br><span class="line"></span><br><span class="line">146. 声明一个指向含有10个元素的数组的指针，其中每个元素是一个函数指针，该函数的返回值是int，参数是int*，正确的是（）                                        </span><br><span class="line"></span><br><span class="line">     -</span><br></pre></td></tr></tbody></table></figure>
(int *p[10])(int*)
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
int [10]*p(int *)
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
int (*(*p)[10])(int *)
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
int ((int *)[10])*p
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     - 先看未定义标识符p，p的左边是*，*p表示一个指针，跳出括号，由于[]的结合性大于*，所以*p指向一个大小为10的数组，即`(*p)[10]`。左边又有一个*号，修释数组的元素，*`(*p)[10]`表示`*p`指向一个大小为10的数组，且每个数组的元素为一个指针。跳出括号，根据右边`（int  *）`可以判断（*`(*p)[10]）`是一个函数指针，该函数的参数是`int*`,返回值是int。所以选C。</span><br><span class="line"></span><br><span class="line">147. C语言中的一个变量可以被定义为两个或多个不同的类型。请问这句话的说法是正确的吗？</span><br><span class="line"></span><br><span class="line">     - 如果不在一个函数体中，可以的；但是如果在一个函数体中，会出现调用混淆，不允许。</span><br><span class="line"></span><br><span class="line">       而且这是两个变量，只是变量名相同而已，被存在不同的内存单元中。</span><br><span class="line"></span><br><span class="line">     - 如果在同一个函数内，那肯定不行，重复的定义，如果一个是&lt;font color='red'&gt;全局&lt;/font&gt;一个是&lt;font color='red'&gt;局部&lt;/font&gt;那就可以，还有在两个不同的函数内，也是可以的</span><br><span class="line"></span><br><span class="line">148. 双循环链表中，任意一结点的后继指针均指向其逻辑后继。</span><br><span class="line"></span><br><span class="line">     - 逻辑后继:&lt;font color='green'&gt;指在存储时按照需要给定的逻辑顺序在其后的数据块&lt;/font&gt;。循环链表中**尾节点的逻辑后继**应该为&lt;font color='red'&gt;null&lt;/font&gt;而其**后继指针指向了头节点。**</span><br><span class="line"></span><br><span class="line">149. 递归先序遍历一个节点为n，深度为d的二叉树，需要栈空间的大小为_</span><br><span class="line"></span><br><span class="line">     - **因为二叉树并不一定是平衡的，也就是深度d！=logn，有可能d &gt; &gt; logn(远大于)，所以栈大小应该是O（d）**</span><br><span class="line"></span><br><span class="line">150. 缓存策略中基于 LRU 的淘汰策略，在缓存满时，会把最近进入缓存的数据先淘汰，以保持高的命中率</span><br><span class="line"></span><br><span class="line">     - 刚好说反了，LRU的过程如下（其实很好理解，访问的频率越高越不该丢弃）： </span><br><span class="line"></span><br><span class="line">       ​      1. 新数据插入到链表头部； </span><br><span class="line"></span><br><span class="line">       ​      2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部； </span><br><span class="line"></span><br><span class="line">             3. 当链表满的时候，将链表尾部的数据丢弃。</span><br><span class="line"></span><br><span class="line">151. 顺序表删除需要移动元素，而链表删除不需要移动元素</span><br><span class="line"></span><br><span class="line">152. &lt;font color='red'&gt;有环的单向链表跟无环的单向链表不可能相交&lt;/font&gt; -正确</span><br><span class="line"></span><br><span class="line">     - 有环的单向链表和无环的单向链表不能相交，因为当相交的时候，无环的单向链表也会被迫存在一个环，只不过这个环的”起点“可能不是原来单向链表的头结点</span><br><span class="line"></span><br><span class="line">153. 如果两个单向链表&lt;font color='red'&gt;相交&lt;/font&gt;，那这两个链表都一定不存在环 -错误</span><br><span class="line"></span><br><span class="line">     - 单向链表相交&lt;font color='red'&gt;可以存在环&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">     ![img](https://uploadfiles.nowcoder.com/images/20180717/4256577_1531815312082_BA893B14C7935C1B5F8296D83D999DDA)</span><br><span class="line"></span><br><span class="line">     - 意思就是&lt;font color='red'&gt;链表相交，要么都有环，要么都无环&lt;/font&gt;，不可能出现其他情况，出现其他情况就不是线性结构就不符合链表的定义</span><br><span class="line"></span><br><span class="line">154. 执行"int x=1;int y=~x;"语句后,y的值为？ ——-2</span><br><span class="line"></span><br><span class="line">     - 假设int占2个字节，那么1的二进制表示是 0000 0001 ，~表示按位取反，则 0000 0001变为 1111 1110，在计算机中整数用补码形式表示，正数的补码是它本身，负数的补码是原数值除符号位按位取反再加一，由补码求原数值也是按位取反再加一，那么 1111 1110 除符号位按位取反再加一变成 1000 0010，即 -2。</span><br><span class="line"></span><br><span class="line">155. 若函数的定义出现在主函数之前且仅被主函数使用，则可以不必再说明</span><br><span class="line"></span><br><span class="line">     - 正确（如果不是仅被主函数调用，就是错的）</span><br><span class="line"></span><br><span class="line">156. 若一个函数（非主函数）没有return语句，返回类型是void</span><br><span class="line"></span><br><span class="line">     - 错误（构造函数和析构函数都没有返回类型，也没有return语句）</span><br><span class="line"></span><br><span class="line">157. &lt;font color='red'&gt;++、--不算做赋值运算&lt;/font&gt;，只能说是一个表达式</span><br><span class="line"></span><br><span class="line">158. 有char a[10]=”abc”;，则strlen(a)的值为3，&lt;font color='red'&gt;strlen&lt;/font&gt;函数返回字符串的&lt;font color='blue'&gt;长度&lt;/font&gt;，不包括末尾的’\0，sizeof(a)才是10</span><br><span class="line"></span><br><span class="line">159. \#include命令的功能是（）</span><br><span class="line"></span><br><span class="line">     - 在&lt;font color='red'&gt;命令处&lt;/font&gt;插入一个文本文件（注意&lt;font color='red'&gt;不是&lt;/font&gt;在&lt;font color='blue'&gt;文件首部&lt;/font&gt;插入一个头文件）</span><br><span class="line"></span><br><span class="line">160. 当顺利执行了文件关闭操作时，&lt;font color='blue'&gt;fclose函数的返回值&lt;/font&gt;是（）</span><br><span class="line"></span><br><span class="line">     - 如果&lt;font color='red'&gt;正常关&lt;/font&gt;例了文件，则函数返回值为&lt;font color='red'&gt;0&lt;/font&gt;；否则，返回值为&lt;font color='red'&gt;非0&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">161. 定义类型并不会分配空间，只有在&lt;font color='blue'&gt;定义变量&lt;/font&gt;时才会分配内存空间</span><br><span class="line"></span><br><span class="line">162. `int  a[10];`</span><br><span class="line"></span><br><span class="line">     - 问下面不可以表示a[1]地址的是（）</span><br><span class="line"></span><br><span class="line">       - &amp;a[0] + 1</span><br><span class="line">       - &lt;font color='blue'&gt;a + sizeof(int)&nbsp;&nbsp;&lt;/font&gt;</span><br><span class="line">       - (int*)&amp;a + 1</span><br><span class="line">       - `(int*)((char*)&amp;a + sizeof(int))`</span><br><span class="line"></span><br><span class="line">     - a为数组的时候 </span><br><span class="line">       &lt;font color='red'&gt;&amp;a + 1&lt;/font&gt; 移动sizeof(数组)字节 </span><br><span class="line"></span><br><span class="line">        &lt;font color='red'&gt; a + 1 &lt;/font&gt;或者 &lt;font color='red'&gt;&amp;a[0] + 1&lt;/font&gt; 移动sizeof(int) ,即移动到&lt;font color='red'&gt;下一个数组元素 &lt;/font&gt;</span><br><span class="line"></span><br><span class="line">       B是指向a[4]</span><br><span class="line"></span><br><span class="line">       C将a变成了指针 int *类型，指针+1 都是移动sizeof(int) ，移动到下一个元素的 </span><br><span class="line"></span><br><span class="line">        D指针绕来绕去的，变成char* 后 +4 ，移动 4* (sizeof(char))，移动四个字节，然后又重新强转成了int*,依然指向下一个元素</span><br><span class="line"></span><br><span class="line">163. 已知ii，j都是整型变量，下列表达式中，与下标引用`X[ii][j]`不等效的是（）</span><br><span class="line"></span><br><span class="line">     - *（X[ii]+j）</span><br><span class="line"></span><br><span class="line">     - &lt;font color='red'&gt;*(X+ii)[j]&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">     - &lt;font color='red'&gt;*(X+ii+j)&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">     - *(*(X+ii)+j)</span><br><span class="line"></span><br><span class="line">       - &lt;font color='red'&gt;a[m]相当于*（a+m)&lt;/font&gt;就是说 [] 符号如果要去掉的话，相加，括号，再取地址。。。反过来也一样</span><br><span class="line"></span><br><span class="line">       - B应该也是错误的，由于&lt;font color='red'&gt;[]的优先级高于*&lt;/font&gt;,因此，相当于对地址`（X+ii）[j]`取值，如果B改为`（*（X+ii））[j]`就对了</span><br><span class="line">       - `a[i][j] =*(a[i]+j) = *(*(a+i)+j) =(*(a+i))[j]`</span><br><span class="line"></span><br><span class="line">164. print函数声明为void print(int a,char b='b',int c=1); 下面函数调用正确的是（）</span><br><span class="line"></span><br><span class="line">     - print('a');</span><br><span class="line"></span><br><span class="line">       print(5,8);</span><br><span class="line"></span><br><span class="line">       print(5,'#');</span><br><span class="line"></span><br><span class="line">       print(5,'#',2);</span><br><span class="line"></span><br><span class="line">     - C++在调用函数时，当实参和形参的数据类型不一致时，会发生数据类型转换！将低精度转换为高精度时，由编译器隐式完成；将高精度转换为低精度时，必须用强制类型转换运算符：static_cast&lt;&gt;()来转换才不会造成数据丢失。精度由低到高: char-&gt;int-&gt;double-&gt;long double。CD肯定对， A的话字符转为整数即为97, B 选项在将整数类型 8 复制给 char 时，会发生截断赋值。把整数的前3*8位去掉  直接后8位赋值给char </span><br><span class="line"></span><br><span class="line">165. fprintf函数只能以&lt;font color='red'&gt;字符串&lt;/font&gt;的形式写入到文件中</span><br><span class="line"></span><br><span class="line">166.</span><br></pre></td></tr></tbody></table></figure>
int` `s[4][5],(*ps)[5];
ps = s;
</code></pre></li>
</ul>
<p>ps是一指向二维数组s的指针，ps+1表示指向数组s第2行首地址的指针；<br><em>(ps+3)表示数组s第4行的首地址；</em>(ps+1)+3表示数组s第2行第4列元素的地址，</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">167. 浮点类型在内存中分布为：&lt;font color='blue'&gt;符号位+指数位（-127~128）+尾数部分 (有效数字 1&lt;= M &lt;2)&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">168. ```c</span><br><span class="line">     #include "stdio.h"</span><br><span class="line">     #include "string.h"</span><br><span class="line">     void fun(char *s){ </span><br><span class="line">         char t[7];</span><br><span class="line">         s=t;</span><br><span class="line">         strcpy(s, "example");</span><br><span class="line">     }</span><br><span class="line">     </span><br><span class="line">     int  main(){ </span><br><span class="line">         char *s;    </span><br><span class="line">         fun(s);    </span><br><span class="line">         printf("%s",s);</span><br><span class="line">         return 0;</span><br><span class="line">     }</span><br></pre></td></tr></tbody></table></figure>

<p>对于栈中内存如果没有初始化，则会出现“烫烫烫烫烫烫”。对于堆中内存如果没有初始化，则会出现“屯屯屯屯屯”</p>
<ul>
<li><p>需要解释的就是编译错误和运行错误，编译错误可以理解成编译器能检查出来的错误，运行错误理解成逻辑错误，需要用户自己纠错</p>
</li>
<li><p>1.main函数里的s没有初始化就在fun函数里使用s，编译器会报警告，运行时会报错（局部变量未初始化）。答案选D。 </p>
<p>2.就算s初始化了，在fun函数里，局部变量t的大小为7，而strcpy函数会复制example末尾的\0 </p>
<p>所以example+’\0’一共8个字节空间，会溢出，程序会崩溃。 </p>
<p>3.就算局部变量t的大小足够大，在fun函数运行结束后，局部变量t的内存空间会被释放掉，此时s成为野指针；返回main函数后，也不会输出example。</p>
</li>
</ul>
</li>
<li><p>定义二维数组时，若第一维不确定第二维确定，则数组必须初始化;初始化后数组中元素个数除以第二维大小<font color="red">，若能整除，则商即第一维大小，若不能整除，则商加上1得到第一维大小</font>;若第一二维全部确定，可以不初始化，默认元素全部为0;不允许第二维不定</p>
<ul>
<li>二维数组的真实含义是，它的第一维就是一组数据的起始地址，第二维就是某组数据中的某个值，a[][3]表达的意思就是二维数组a的每一维都是由3个元素组成的一维数组</li>
</ul>
</li>
<li><p>下面程序段的运行结果是 ( ) 。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *s = <span class="string">"abcde"</span>;</span><br><span class="line">s += <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, s);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>指针s保存的是字符串的首地址，s+=2后，指向了字符‘c’，格式化输出s就是字符‘c’的地址（十进制形式的地址，%p是十六进制的地址）</li>
</ul>
</li>
<li><p>下面代码的执行结果是（）</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> *p[] = {<span class="string">"TENCENT"</span>, <span class="string">"CAMPUS"</span>, <span class="string">"RECRUITING"</span>};</span><br><span class="line">    <span class="keyword">char</span> **pp[] = {p + <span class="number">2</span>, p + <span class="number">1</span>, p};</span><br><span class="line">    <span class="keyword">char</span> ***ppp = pp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s "</span>, **++ppp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, *++*++ppp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p><img src="https://uploadfiles.nowcoder.com/images/20180303/4129176_1520062230660_F3CCDD27D2000E3F9255A7E3E2C48800" alt="img"></p>
</li>
<li><p>从题干当中，我们可以画出这样的一个图，这样就比较直观的看出了p,pp,ppp都指向哪里了，关键是最后两个printf语句。<br>（1）printf(“%s”,**++ppp);即，ppp当前所指向的位置，再往下移一个位置，即pp的位置2，而pp的位置2指向的是p的位置2，p的位置2指向的是CAMPUS，所以先输出CAMPUS  </p>
<p>  （2）<code>printf(“%s”,*++*++ppp);</code>这个语句等价于 <code>printf(“%s”,*++（*++ppp)）;</code>所以我们首先看,++ppp，第一个printf语句中ppp已经指向了pp的位置2，所以再往下移一个，指向了pp的位置3，而（*++ppp）则代表pp位置3所指向的内容，即p的位置1（pp的位置3指向的是p的位置1），在此基础上前面再加上一个++，则代表指针p在位置1的基础上再往下移动，即指针p的位置2，而p的位置2所指向的内容是CAMPUS，所以第二行输出的也是CAMPUS。<br>所以正确答案是：CAMPUS CAMPUS</p>
</li>
</ul>
</li>
<li><p>scanf()函数是格式化输入函数，它从标准输入设备(键盘）读取输入的信息</p>
<ul>
<li>输入== 读取、打印到屏幕==写</li>
</ul>
</li>
<li><p>关于C语言中的float，下面哪种说法正确的是 （）</p>
<ul>
<li><font color="blue">x的二次方大于等于0,对于float变量x总成立</font><br>float 变量加法满足交换律<br>条件0.9f == 0.9 的值为真<br>条件9 == 0.9*10 的值为真</li>
<li>C/C++中浮点数由符号位、阶码和尾数构成，其二进制表示并不直接对应浮点数的大小，因此<strong>浮点数类型不能进行位运算</strong>，否则编译器报错；所以<strong>如果A选项正确，其指的应该是x的二次幂；而不是x与2进行逐位异或</strong>……</li>
<li>B不一定正确。<strong>虽然**</strong>浮点数标准<strong>**IEEE 754</strong>满足加法和乘法的交换律，不满足加法结合律，<strong>但是**</strong>C++标准不保证<strong>**IEEE 754标准的实现</strong>，于是C++编译器也不保证浮点数a+b的结果等于b+a</li>
<li>C、D错误。浮点数存在误差，直接比较大小往往不是预期的结果；通常引入一个比要求精度还要小几个数量级的实数epsilon来帮助比较大小。在我的机器上，精度取1e-8，0.9f == 0.9为假（0.9f是单精度浮点，精度比0.9低）：</li>
</ul>
</li>
<li><p>extern、register、static、auto分别是定义外部变量、寄存器变量、静态变量、自动变量<br> 其中，自动变量(<font color="red">auto</font>)和寄存器变量(<font color="red">register</font>)属于动态存储，<font color="red">调用时临时分配单元</font>；而静态变量(static)和外部变量(extern)属于静态存储，在整个程时都存在.</p>
<ul>
<li>故，以下只有在使用时才为该类型变量分配内存的存储类型的是（）<ul>
<li>auto和register</li>
</ul>
</li>
</ul>
</li>
<li><p>函数原型：指明函数的名字，返回的类型，有几个参数，这几个参数是什么类型，<strong>不需要函数体</strong>，也<strong><font color="red">不需要形式参数的名字</font></strong>，其中用分号作为原型的结束符。</p>
<p>例如：void fun( int );</p>
</li>
<li><p>C语言程序能够在不同的操作系统下运行，这说明C语言具有很好的</p>
<ul>
<li>移植性<ul>
<li>所谓移植性就是在某操作系统下编写的程序能够在其他操作系统下编译运行，而程序几乎不需要进行任何修改。所以选择B。</li>
</ul>
</li>
</ul>
</li>
<li><p>对于下面的代码，说法正确的是____</p>
<p>char* s1 = “Hello world”;<br>char s2[] = “Hello world”;<br>s1[2] = ‘E’;     // 1<br>s2[2] = ‘E’;     // 2<br>*(s1 + 2) = ‘E’;  // 3<br>*(s2 + 2) = ‘E’;  // 4</p>
<ul>
<li>“Hello World”在常量区，但s1存储在栈，并且可以做++运算，但*p不可更改，相当于const char *p</li>
<li><strong>指针指向字符串时，字符串是常量，存储在常量区，而指针存储在栈区，不能对其操作修改。</strong></li>
<li>而对于s2,”Hello world”存储在数组里，在栈区，是可以修改的</li>
</ul>
</li>
<li><p>strlen和str.length()都是求字符串的长度，但strlen( )的参数必须是char*，而 str.length( )是string类对象str调用的成员函数。</p>
</li>
<li><p>%3d：<font color="red">输出</font>时表示输出位数少于三位数时前面补0，<font color="red">多于三位数时按实际位数输出</font>。<font color="red">输入</font>时表示<font color="red">只输入三位数</font>，少于三位数以空格补齐。</p>
</li>
<li><p>二路归并排序的时间复杂度为（）。</p>
<ul>
<li>假设数据区域为[1:n]，归的过程，第一次将区间分为[1:n/2]和[n/2+1，n]，第二次将两个区间分为四个，总共会进行log2(n)次，总共分为了log2(n）层，每次分区间的时间复杂度为1，则总共归的过程时间复杂度为log2(n)，而并的过程会的归的过程分的区间进行排序，是两个有序数组合并的过程，每一层合并的时间复杂度为n，有log2(n)层，所以并的总共复杂度为nlog2(n)，而归并的复杂度为nlog2(n)+log2(n)，用大O表示法就是<font color="red">nlogn</font></li>
</ul>
</li>
<li><p>用邻接矩阵存储有n个结点(0,1,…,n)和e条边的有向图<img src="https://www.nowcoder.com/equation?tex=0%20%5Cle%20e%20%5Cle%20n(n%20-%201)" alt="img">)。在邻接矩阵中删除结点<img src="https://www.nowcoder.com/equation?tex=i(0%20%5Cle%20i%20%5Cle%20n)" alt="img">的时间复杂度是（）</p>
<ul>
<li><p>删除节点B时，在邻接矩阵中需要把指向B的边全部删除，B指向的边也全部删除。 </p>
<p>而邻接矩阵表示法由一个顶点表（一维数组），一个边集（邻接矩阵，二维数组）组成。由顶点表查找i，复杂度为O(1)，然后查找二维数组i行i列，置i行i列均为0（即删除i节点），复杂度为2*O（n）。 </p>
<p>结果为O(n)，选择 B。</p>
</li>
</ul>
</li>
<li><p><strong>回溯法</strong><br> 1）（求解目标）回溯法的求解目标是找出解空间中满足约束条件的一个解或所有解。<br> 2）（搜索方式：深度优先）回溯*<em>\</em>搜索整个解空间，当不满条件时，丢弃，继续搜索下一个儿子结点，如果所有儿子结点都不满足，向上回溯到它的父节点。</p>
<p>   <strong>分支限界法</strong><br> 1）（求解目标）分支限界法的目标一般是在满足约束条件的解中找出在某种意义下的最优解，也有找出满足约束条件的一个解。<br> 2）（搜索方式：广度优先）分支限界法以广度优先或以最小损耗优先的方式搜索解空间。</p>
<ul>
<li><p>回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。 </p>
<p>回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。</p>
</li>
</ul>
</li>
<li><p>共用体变量可以作结构体的成员<font color="blue">,结构体变量也可以作共用体的成员</font>。</p>
<ul>
<li>正确</li>
</ul>
</li>
<li><p><font color="blue">文件指针和位置指针都是随着文件的读写操作在不断改变</font></p>
<ul>
<li>错，文件指针位置不变</li>
</ul>
</li>
<li><p>任何表达式语句都是表达式加分号结尾</p>
<ul>
<li>正确</li>
</ul>
</li>
<li><p>数组名不能与其他变量名相同</p>
<ul>
<li>正确</li>
</ul>
</li>
<li><p>函数形参的<a href="https://so.csdn.net/so/search?q=存储单元&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">存储单元</a>是<font color="red">动态分配</font>的</p>
<ul>
<li>错误，函数的变量一般是栈区，只要退出函数，系统就会自动回收栈区，而动态分配分配时分配堆区，堆区只能手动回收（free函数）</li>
</ul>
</li>
<li><p>C语言 随机操作<font color="red">只</font>适用于文本文件</p>
<ul>
<li><font color="red">错误</font>，随机操作文本指的是用seek函数重新定位文件指针进行读写操作，访问数组中的元素也是随机的，知道下标就可以，所以说随机操作不只是针对于文件来讲。</li>
</ul>
</li>
<li><p>全局变量放在static静态区，不是在栈区；stack由编译器自动分配和释放,存放函数的参数值，局部变量</p>
</li>
<li><p><a href="http://www.cnblogs.com/perfy/archive/2012/09/06/2672946.html" target="_blank" rel="noopener">heap&amp;stack 区别</a></p>
<p>​    1.heap是堆，stack是栈。   </p>
<p>​        2.stack的空间由操作系统（不是编译器）自动静态分配和释放（进站和出栈可控）；heap的空间是手动申请和释放的，heap常用new关键字来动态分配（—“内存泄露”——                            Memory Leak                     ）。   </p>
<p>​    3.stack空间有限（经常有栈溢出，而不是堆溢出），heap的空间是很大的自由区。   </p>
<p>  在Java中， </p>
<p>  若只是声明一个对象，则先在栈内存中为其分配地址空间， </p>
<p>  若再new一下，实例化它，则在堆内存中为其分配地址。 </p>
<p>   4.举例：  </p>
<p>   数据类型 变量名；这样定义的东西在栈区。  </p>
<p>   如：Object a =null; 只在栈内存中分配空间  </p>
<p>   new 数据类型();或者malloc(长度);    这样定义的东西就在堆区  </p>
<p>   如：Object b =new Object();    则在堆内存中分配空间</p>
</li>
<li><p>若fp已正确定义并指向某个文件，当未遇到该文件结束标志时函数feof(fp)的值为0.</p>
<ul>
<li>此时并未到文件尾部，否则返回非0，因为<font color="red">有数据时返回0</font></li>
</ul>
</li>
<li><p>文件指针用于指向文件，文件<font color="red">只有被打开后</font>才有对应的文件指针。</p>
</li>
<li><p>如果函数定义出现在函数调用之前,可以不必加函数原型声明</p>
<ul>
<li>正确</li>
</ul>
</li>
<li><p>输入操作称为写操作,将输入流中的信息存到内存时,使用写函数。</p>
<ul>
<li><font color="red">输入</font>是指计算机将数据读取存入内存的过程，即这个过程是<font color="red">读入</font>过程，即读操作，使用读函数<ul>
<li>类比scanf，计算将用户输入的数据从缓冲区读取出来存入内存；printf，计算机将内存中的数据写到输出设备上即屏幕</li>
</ul>
</li>
</ul>
</li>
<li><p>函数返回值的类型是由在<font color="red">定义函数</font>时所指定的函数类型</p>
</li>
<li><p>指向数组的指针变量称为数组指针变量。</p>
<ul>
<li><p>一个数组是由<font color="red">连续</font>的一块内存单元组成的。</p>
</li>
<li><p><font color="red">数组名</font>就是这块连续内存单元的<font color="red">首地址</font>。</p>
</li>
<li><p>一个数组<font color="blue">也是由各个数组元素（下标变量）组成</font>的。</p>
</li>
<li><p>每个数组元素按其类型不同占用几个连续的内存单元。</p>
</li>
<li><p>一个指针变量<font color="blue">既可以指向一个数组，也可以指向一个数组元素。</font></p>
<p>一般形式：<br>类型说明符 *指针变量名。</p>
<p>有了指针可以用两种方法访问数组元素:<br>第一种方法为下标法。<br>第二种方法为指针法。</p>
</li>
</ul>
</li>
<li><p>指针变量可以存放指针(地址)、数值和字符</p>
<ul>
<li><font color="red">只能存储地址</font></li>
</ul>
</li>
<li><p>内存中每个存储单元都有一个唯一的地址</p>
<ul>
<li>正确</li>
</ul>
</li>
<li><pre><code class="c"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>
<span class="function"></span>{
    <span class="keyword">char</span> arr[<span class="number">2</span>][<span class="number">4</span>];
    <span class="built_in">strcpy</span> (arr[<span class="number">0</span>],<span class="string">"you"</span>);
    <span class="built_in">strcpy</span> (arr[<span class="number">1</span>],<span class="string">"me"</span>);
    arr[<span class="number">0</span>][<span class="number">3</span>]=<span class="string">'&amp;'</span>;
    <span class="built_in">printf</span>(<span class="string">"%s \n"</span>,arr);
    <span class="keyword">return</span> <span class="number">0</span>;
}
&lt;!--￼<span class="number">27</span>--&gt;

- ```C
  ioctl
  &lt;!--￼<span class="number">28</span>--&gt;

- ```C
  <span class="built_in">write</span>
  &lt;!--￼<span class="number">29</span>--&gt;</code></pre>
</li>
<li><p>malloc函数进行动态、静态内存分配是在什么阶段?</p>
<ul>
<li><p>程序占用三种类型的内存：静态内存、栈内存、堆内存；<br><strong>静态内存：</strong><br>用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量<br> <strong>栈内存：</strong> </p>
<p>  用来保存定义在函数内的非static对象。  </p>
<p> 分配在静态内存或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。  </p>
<p> <strong>堆内存：</strong>  </p>
<p>  在程序<strong>运行时</strong>分配。动态对象的生存周期由<strong>程序（用户）</strong>来控制。</p>
</li>
<li><p>装载阶段、执行阶段</p>
</li>
</ul>
</li>
<li><p>“-6.2e”的意思：</p>
<p><strong>6</strong> 表示输出的位宽，如果结果小于6位，则不足的部分以空格补充，如果超于6位则没影响； </p>
<p>  <strong>.2</strong> 保留两位小数 </p>
<p>  e 以指数形式输出，即10的n次幂，e+02即表示10^2 </p>
<p>  - 负号，表示左对齐还是右对齐，2.19e+02 占9位（代码执行测试得到，通过不断修改6的结果，直到改到10，才出现了%6.2e输出时，左侧添加空格占位）。所以 - 表示左对齐，结尾右侧补空格，而+情况是右对齐，即左侧开头补空格 </p>
<p>  所以对于218.82631输出结果应为2.19*10^2，转换成计算机的代码输出格式即2.19e+02</p>
</li>
<li><p>共用体：</p>
<ul>
<li>共用体变量的地址和它的各成员的地址都是同 一地址。</li>
<li><font color="red">不能对共用体变量名赋值。</font></li>
<li>不能企图引用变量 名来得到一个值。</li>
<li>不能<font color="red">在定义共用体变量时对它初始化。</font></li>
<li><font color="red">不能</font>用共用体变量名作为<font color="red">函数参数</font>。 </li>
<li><font color="green">不能用函数返回共用体变量</font></li>
<li>可以定义共用体数组，<font color="green">共用体成员可以是数组</font></li>
<li><font color="blue">共用体类型定义和结构体类型定义可以互相嵌套</font></li>
<li>任何时间<font color="blue">起作用的是最后一个成员</font>（且只能任意时间只有一个成员起作用）</li>
</ul>
</li>
<li><p>C 语言分隔符：逗号(变量和表达式之间)、分号(for语句内)、空白符(字符串之间)、冒号（case:)</p>
</li>
<li><p>变量的类型分为两种：储存和数据</p>
<ul>
<li><p>所有的数据都有两种类型，一种是数据类型，一种是存储类型。<br><strong>数据类型</strong>：如int，float等<br><strong>存储类型</strong>：四种存储类型的变量，自动变量（auto）、<a href="https://so.csdn.net/so/search?q=静态变量&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">静态变量</a>（static）、外部变量（extern）、以及寄存器变量（register）。</p>
</li>
<li><table>
<thead>
<tr>
<th>存储类别</th>
<th>存储期</th>
<th>作用域</th>
<th>声明方式</th>
</tr>
</thead>
<tbody><tr>
<td>auto</td>
<td>自动</td>
<td>块</td>
<td>块内</td>
</tr>
<tr>
<td>register</td>
<td>自动</td>
<td>块</td>
<td>块内,使用关键字register</td>
</tr>
<tr>
<td>static(局部)</td>
<td>静态</td>
<td>块</td>
<td>块内,使用关键字static</td>
</tr>
<tr>
<td>static(全局)</td>
<td>静态</td>
<td>文件内部</td>
<td>所有函数外,使用关键字static</td>
</tr>
<tr>
<td>extern</td>
<td>静态</td>
<td>文件外部</td>
<td>所有函数外</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>return后面括号里的表达式的值即是此函数的值。请问这句话的说法是正确的吗？</p>
<ul>
<li>错误</li>
<li>return 后面括号的值不一定是函数的值，譬如函数返回值与return 类型不一致需要类型转换，返回值为 int ，retun 3.2 ，那么肯定会进行转换的</li>
</ul>
</li>
<li><p><code>!(x + y) + z-1 &amp;&amp; y + z/2;</code></p>
<ul>
<li>表达式的值是</li>
<li><code>!(x + y) + z-1 &amp;&amp; y + z/2即为(( !(x + y) )+ z-1) &amp;&amp; (y + z/2)=(!7+5-1)&amp;&amp;(4+2)=(0+5-1)&amp;&amp;6=4&amp;&amp;6=1</code></li>
</ul>
</li>
<li><p>用C语言编写的代码程序（）</p>
<ul>
<li><pre><code>可立即执行
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
是一个源程序
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
经过编译即可执行
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
经过编译解释才能执行
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     - 1、【&lt;font color='red'&gt;编译&lt;/font&gt;】是把c源程序翻译成汇编代码：*.s； 2、【&lt;font color='red'&gt;汇编&lt;/font&gt;】是把汇编代码翻译成二进制目标代码：*.obj； 3、【&lt;font color='red'&gt;链接&lt;/font&gt;】是把多个二进制目标代码文件链接成一个可执行程序；因为一个工程某个文件调用了其他c文件的函数或变量 一个程序需要上面三个步骤才能由源程序变成可执行程序。</span><br><span class="line"></span><br><span class="line">     - C语言写的代码程序&lt;font color='red'&gt;肯定是源程序&lt;/font&gt; 它&lt;font color='blue'&gt;不能立即执行，必须经过编译成可执行代码&lt;/font&gt;</span><br><span class="line">       如果这个源程序中不含有main函数，编译后的代码也是不可执行的 C语言不是解释执行的</span><br><span class="line"></span><br><span class="line">209. 在32位机上，下面C程序的输出结果是</span><br><span class="line"></span><br><span class="line">     ```C</span><br><span class="line">     struct MyStruct</span><br><span class="line">     {</span><br><span class="line">         int i;</span><br><span class="line">         char c;</span><br><span class="line">         struct InnerStruct</span><br><span class="line">         {</span><br><span class="line">             int i;</span><br><span class="line">             long l;</span><br><span class="line">             double d;</span><br><span class="line">             char c;</span><br><span class="line">         } innerStruct;</span><br><span class="line">     };</span><br><span class="line">     union MyUnion</span><br><span class="line">     {</span><br><span class="line">         int i;</span><br><span class="line">         char c;</span><br><span class="line">     };</span><br><span class="line">     int main()</span><br><span class="line">     {</span><br><span class="line">        printf("%d, %d", sizeof(MyStruct), sizeof(MyUnion));</span><br><span class="line">     }</span><br></pre></td></tr></tbody></table></figure></code></pre></li>
<li><p>做选择题就要有做选择题的方法，除了掌握基本的知识。 </p>
<p>对于struct来说，大小虽然要慢慢累加，但是最后必然为struct里最长类型的整数倍，即double为8字节，则肯定是8的整数倍，排除A,B（不用慢慢累加计算） </p>
<p>对于Union来说，就简单了，大小为最长类型的整数倍，即int为4字节，则为4，选C</p>
</li>
<li><p>结构体长度并不一定是double的长度8的整数倍，而是min(字节对齐长度,8)的倍数</p>
<p>如果默认编译器4字节对齐，这题就是28，如果是8字节，就是32 </p>
<p>设对齐字节数为n(n = 4或8，区别于32位或者64位操作系统),每个成员内存长度为Li, Max(Li)为最大的成员内存长度,字节对齐规则是: </p>
<p>\1.    结构体对象的起始地址能够被Max(Li)所整除; </p>
<p>\2.    结构体中每个成员相对于起始地址的偏移量,即对齐值应是min(n,Li)的倍数.若不满足对齐值的要求,编译器会在成员之间填充若干个字节; </p>
<p>\3.    结构体的总长度值应是min(n,Max(Li))的倍数,若不满足总长度值的要求,编译器在为最后一个成员分配空间后,会在其后填充若干个字节.</p>
</li>
</ul>
</li>
<li><p><strong>两指针变量相减所得之差是两个指针所指数组元素之间相差的元素个数</strong></p>
</li>
<li><p>fseek函数<font color="red">一般</font>用于二进制文件。注意也可用于文本文件</p>
</li>
<li><p>一个变量的数据类型被强制转换后,它将保持被强制转换后的数据类型</p>
<ul>
<li>错误</li>
</ul>
</li>
<li><p>使用printf函数打印一个double类型的数据，要求：输出为10进制，输出左对齐30个字符，4位精度。以下哪个选项是正确的？</p>
<ul>
<li><pre><code>%-30.4e
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
%4.30e
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
%-30.4f
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
%-4.30f
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     - -： 左对齐</span><br><span class="line"></span><br><span class="line">       30： 最小字段宽度</span><br><span class="line"></span><br><span class="line">       .4： 精确度保留小数4位</span><br><span class="line"></span><br><span class="line">       f： double精度浮点数</span><br><span class="line"></span><br><span class="line">       e： 科学计数法</span><br><span class="line"></span><br><span class="line">     - printf中，&lt;font color='red'&gt;%f通杀单精度和双精度&lt;/font&gt;</span><br><span class="line">       在&lt;font color='red'&gt;scanf&lt;/font&gt;中，%f和%lf才&lt;font color='red'&gt;有区别&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">214. 下面关于C语言中sizeof(int)说法正确的是（）</span><br><span class="line"></span><br><span class="line">     - &lt;font color='red'&gt;编译时&lt;/font&gt;</span><br><span class="line">     - 运行时</span><br><span class="line"></span><br><span class="line">215. C语言中的一个变量可以被定义为两个或多个不同的类型。请问这句话的说法是正确的吗</span><br><span class="line"></span><br><span class="line">     - 如果同一个变量，分别作为全局变量和局部变量，根据局部优先原则，是可以定义为不同类型的。</span><br><span class="line"></span><br><span class="line">216. ```C</span><br><span class="line">     struct student {</span><br><span class="line">         int num, age;</span><br><span class="line">     };</span><br><span class="line">     struct student stu[3] = {{6001, 20}, {6003, 21}, {6005, 19}};</span><br><span class="line">     struct student *p = stu;</span><br></pre></td></tr></tbody></table></figure>
</code></pre></li>
</ul>
<p>则下面的C语言表达式中,值为6003的是（） 。</p>
<ul>
<li><p>对于A选项：++(p-&gt;num)。表示取数组第一个元素的值(6001)，然后+1； </p>
<p>对于B选项：(p++)-&gt;num。后缀自增运算符(++)与成员选择运算符(-&gt;)处于同一优先级，从左到右结合，但是指针偏移的操作直到表达式结束才会进行， </p>
<p>这个表达式相当于(p)-&gt;num;p=p+1; </p>
<p>对于C选项：<code>(*p++).num。</code>后缀自增运算符(++)优先级高于取值运算符(<em>)，但是++直到表达式结束才会进行，这个表达式相当于`(</em>p).num;p=p+1;` </p>
<p>对于D选项：<code>(*++P).num。</code>前缀自增运算符(++)优先级和取值运算符(<em>)一样，先执行p=p+1操作，相当于`(</em>(p+1)).num`;</p>
</li>
</ul>
</li>
<li><p>下列函数正确的是</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="built_in">array</span>[MAX_CHAR+<span class="number">1</span>],i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;= MAX_CHAR;i++){</span><br><span class="line">        <span class="built_in">array</span>[i] = i;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">char</span>*<span class="title">test2</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">char</span> p[] = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">char</span> *p = test2();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    str++;</span><br><span class="line">    *str = <span class="string">'0'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



</li>
</ol>
<pre><code>- 重点不在于CHAR_MAX的取值是多少，而是在于i的取值范围是多少。 一般char的取值范围是-128到127，而u char 则是0~255，所以i的取值范围是0~255. 所以当CHAR_MAX常量大于255时，执行i++后，i不能表示256以上的数字，所以导致无限循环。 第二个问题： 重点在于函数中p的身份，他是一个指针，还是数组名；  如果是指针p，则p指向存放字符串常量的地址，返回p则是返回字符串常量地址值，调用函数结束字符串常量不会消失（是常量）。所以返回常量的地址不会出错。 如果是数组p，则函数会将字符串常量的字符逐个复制到p数组里面，返回p则是返回数组p，但是调用函数结束后p被销毁，里面的元素不存在了。 例子中p是数组名，所以会出错，p所指的地址是随机值。 若是把char p[]="hello";改成char *p="hello";就可以了。第三个问题：  重点在于str++;这实际的语句就是str=str+1;而str是数组名，数组名是常量，所以不能给常量赋值。（可以执行str+1，但是不能str=.）</code></pre><ol start="218">
<li><p>输出正确的是：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> *a = <span class="string">"Trend"</span>;</span><br><span class="line">    <span class="keyword">char</span> **b = &amp;a;</span><br><span class="line">    *b = <span class="string">"commercial"</span>;</span><br><span class="line">    <span class="keyword">char</span> *c = ++a;</span><br><span class="line">    a = <span class="string">"talents."</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\n"</span>,*++c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>一开始a指向Trend，b指向指针a，后面commercial的内容赋给了指针b，然后就改变了指针a的内容，a就指向了commercial，指针c指向a所指的第二个字符，也就是o，虽然后面a又指向了talents，但是c已经指向了commercial，所以++c，c就指向了m，*++c就输出m字符</li>
</ul>
</li>
<li><p><font color="red">在C中使用malloc时不需要强制类型转换，因为在C中从void*到其他类型的指针是自动隐式转换的；</font> </p>
<p>  在C++中使用malloc时必须要强制类型转换，否则会报错，但在c++中一般用new而不用malloc；</p>
</li>
<li><p>int a[10]={ }; 编译器自动将所有元素置零</p>
</li>
<li><p>对于以下结构定义，(*p)-&gt;str++中的++加在（）</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> {</span> <span class="keyword">int</span> len; <span class="keyword">char</span> *str; } *p;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>p是指针，可以写p-&gt;str,但是<code>（*p）</code>只能写<code>(*p).str;</code></li>
</ul>
</li>
<li><p>结构体和共用体变量都不能进行比较操作，因为类型不一样，无法比较，除非强制转换或重载比较运算符</p>
</li>
<li><p>如果想在一个地方定义结构体，而在其他地方定义实际的结构体变量那么就必须使用标记名；如果定义结构体的同时就创建该结构体变量，则可以省略结构体的标记名，此时该结构体是一次性的、</p>
</li>
<li><p>typedef不是用来定义新的数据类型，而是创建易于记忆的类型名，给类型取别名</p>
</li>
<li><p>结构总是以传值的方式传递给函数</p>
</li>
<li><p>不管b_val为多少，while(b_val)等价于while(b_val！=0)，while(!b_val)等价于while(b_val==0)</p>
</li>
<li><p>在行尾放一个 \ ，编译器会忽略行尾的换行符，起到续行的作用。</p>
</li>
<li><p>include <code>&lt;file&gt;</code> //在标准库及默认搜索目录中寻找将要 include 的文件</p>
<p>include “file” //先在当前目录中搜索文件，然后再到默认搜索目录中搜寻。</p>
<ul>
<li>因此标准库头文件应该用&lt;&gt;更快</li>
</ul>
</li>
<li><p>%要求两边都是整数，如果你非要一个整数%另外一个非整数的可以用强制类型转换把它转换成整形</p>
<p>即使分母为0，编译器也不会编译出错，输出结果为inf,表示无穷大</p>
</li>
<li><p>所谓声明，就是告诉编译器变量的类型，编译器并不为其分配内存，此变量已经定义过，故声明可以多次进行。例如，声明外部变量 a。 </p>
<p>  extern int a; </p>
<p>   （1）定义创建了变量，并为其分配内存；声明没有分配内存。  </p>
<p>   （2）一个变量在一定的区域内只能被定义一次，却可以被多次声明。</p>
</li>
<li><p>若有以下的定义:<code>int t[3][2];</code></p>
<p>t[2] 能正确表示 t 数组某元素的地址 。表述是否正确？</p>
<ul>
<li>正确</li>
</ul>
</li>
<li><p>程序行、语句、函数都是由字符构成的，字符是C语言的最小单位，最小执行单元是函数。</p>
</li>
<li><p>以下定义错误的是：                                        </p>
<ul>
<li><pre><code>struct A{A  _a;};
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
struct A{A* _a;};
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
struct A{A&amp; _a;};
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></tbody></table></figure>
struct B;
struct A{B&amp; _b;};
struct B{A&amp; _a;};
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">答案：A </span><br><span class="line"></span><br><span class="line">  解释：struct成员类型不可以是它自己。</span><br></pre></td></tr></tbody></table></figure>
因为会递归定义。
理论上这样导致结构体的大小不能被计算（无限大小）。所以不能在结构体里的成员类型是结构体本身。
但是成员可以定义为该结构体的指针。就像你上面这段代码。因为指针的大小是已知的（随编译器和操作系统而定）。
所以可以定义为该结构体的指针，但不是该结构体。
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">234. 表头可以是原子或子表，表尾一定是子表</span><br><span class="line"></span><br><span class="line">235. 数组静态分配内存，链表动态分配内存；</span><br><span class="line">      数组在内存中连续，链表不连续；（对于数组，对象是放在堆内存中的，对象的引用是放在栈内存中的）</span><br><span class="line">      数组元素在栈区，链表元素在堆区；</span><br><span class="line">      数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；</span><br><span class="line">      数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。</span><br><span class="line"></span><br><span class="line">236. 一般情况下,算法中基本操作重复执行的次数是问题规模n的某个函数,用T(n)表示,若有某个辅助函数f(n),使得当n趋近于无穷大时,T（n)/f(n)的极限值为不等于零的常数,则称f(n)是T(n)的同数量级函数.记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度,简称时间复杂度.数学语言表达就是：存在足够大的正整数M，使得T（n）≤M×f（n）。</span><br><span class="line"></span><br><span class="line">237. 一个C源程序不是必须包含一个main()函数，而是必须包含一个**程序的入口函数**，**程序的入口函数不一定是main()函数**</span><br><span class="line"></span><br><span class="line">238. **1.default顾名思义是缺省情况，所有case条件不符合时才会执行；**</span><br><span class="line"></span><br><span class="line">     2.case语句若不加break，则当一条满足条件的case语句执行后，其下面的case语句都会执行。</span><br><span class="line"></span><br><span class="line">239. 必须在声明中对常量初始化，否则该常量值不确定且无法修改</span><br><span class="line"></span><br><span class="line">240. 注意本题的索引下标是从1开始 所以循环队列中最多有n个元素</span><br><span class="line">      在循环队列中,头指针指向队列当中的第一个元素,而尾指针指向最后一个元素的下一位</span><br><span class="line"></span><br><span class="line">     ​    假设循环队列的队尾指针是rear，队头是front，其中QueueSize为循环队列的最大长度。  </span><br><span class="line"></span><br><span class="line">        (1)    入队时队尾指针前进1：(rear+1)%QueueSize  </span><br><span class="line"></span><br><span class="line">        (2)    出队时队头指针前进1：(front+1)%QueueSize  </span><br><span class="line"></span><br><span class="line">        (3)    队列长度：(rear-front+QueueSize)%QueueSize  </span><br><span class="line"></span><br><span class="line">     ​    现有一循环队列，其队头指针为front，队尾指针为rear；循环队列长度为N。其队内有效长度为？(假设队头不存放数据)  </span><br><span class="line"></span><br><span class="line">     ​    答案：(rear-front+N)%N  </span><br><span class="line"></span><br><span class="line">        (4) 队空和队满的条件  </span><br><span class="line"></span><br><span class="line">     ​    为了区分队空还是堆满的情况，有多种处理方式：  </span><br><span class="line"></span><br><span class="line">        方式1：    牺牲一个单元来区分队空和队满，入队时少用一个队列单元，即约定以"队头指针在队尾指针的下一位置作为队满的标志"。  </span><br><span class="line"></span><br><span class="line">     ​    队满条件为：(rear+1)%QueueSize==front  </span><br><span class="line"></span><br><span class="line">     ​    队空条件为：front==rear  </span><br><span class="line"></span><br><span class="line">     ​    队列长度为：(rear-front++QueueSize)%QueueSize  </span><br><span class="line"></span><br><span class="line">        方式2：    增设表示队列元素个数的数据成员size，此时，队空和队满时都有front==rear。  </span><br><span class="line"></span><br><span class="line">     ​    队满条件为：size==QueueSize  </span><br><span class="line"></span><br><span class="line">     ​    队空条件为：size==0  </span><br><span class="line"></span><br><span class="line">        方式3：    增设tag数据成员以区分队满还是队空  </span><br><span class="line"></span><br><span class="line">     ​    tag表示0的情况下，若因删除导致front==rear，则队空；  </span><br><span class="line"></span><br><span class="line">     ​    tag等于1的情况，若因插入导致front==rear则队满</span><br><span class="line"></span><br><span class="line">241. 一个结构体指针变量虽然可以用来访问结构体变量或结构体数组元素的成员，但是，**结构体指针变量不能指向一个成员**。也就是说不允许取一个成员的地址来赋予它。</span><br><span class="line"></span><br><span class="line">     ```c</span><br><span class="line">     错误：</span><br><span class="line">     pdate = &amp;Date[1].year;		//错误的</span><br></pre></td></tr></tbody></table></figure></code></pre></li>
</ul>
</li>
<li><h2 id="链表练习"><a href="#链表练习" class="headerlink" title="链表练习"></a>链表练习</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>{</span></span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">char</span> sex[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">int</span> score[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">float</span> ave;</span><br><span class="line">}student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stuNode</span>{</span></span><br><span class="line">	student stu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stuNode</span> *<span class="title">next</span>;</span></span><br><span class="line">}stuNode, *stuList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入一个学生信息</span></span><br><span class="line"><span class="function">student <span class="title">inputAStu</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//输入n 个学生信息， 返回学生数组 </span></span><br><span class="line"><span class="function">student* <span class="title">inputStu</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//输出学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStu</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//为学生数据进行按照平均分大小进行降序排序（分别使用冒泡排序、选择排序、插入排序、快速排序实现）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSortStu</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSortStu</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSortStu</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">patition</span><span class="params">(student *stu, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(student *stu,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"><span class="comment">//创建带有头结点的链表(头插法)</span></span><br><span class="line"><span class="function">stuList <span class="title">creat1</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//创建带有头结点的链表(尾插法)</span></span><br><span class="line"><span class="function">stuList <span class="title">creat1_2</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//创建不带头结点的链表 (相当于尾插法)(可以写头插法，但是没必要，简单来说就是创建带有头结点的链表【同上】，最后返回的是head-&gt;next)</span></span><br><span class="line"><span class="function">stuList <span class="title">creat2</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//统一使用使用不带头结点的遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(stuList head)</span></span>;</span><br><span class="line"><span class="comment">//为链表添加一个学生信息(按平均分有序插入(带头结点))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addStuNode</span><span class="params">(stuList *head, student stu)</span></span>;</span><br><span class="line"><span class="comment">//链表中删除姓名为delname的全部学生信息,删除成功返回1，否则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delStuNode</span><span class="params">(stuList *head, <span class="keyword">char</span> *delname)</span></span>;</span><br><span class="line"><span class="comment">//将链表中的学生信息逆置(带头结点)【头插法实现逆置】</span></span><br><span class="line"><span class="function">stuList <span class="title">reverseStuList</span><span class="params">(stuList head)</span></span>;</span><br><span class="line"><span class="comment">//将两个学生有序的链表合并，并保证合并后链表仍然有序(带头结点)</span></span><br><span class="line"><span class="function">stuList <span class="title">mergeList</span><span class="params">(stuList L1, stuList L2)</span></span>;</span><br><span class="line"><span class="comment">//链表中删除平均分最小的节点</span></span><br><span class="line"><span class="function">stuList <span class="title">delStuMinAve</span><span class="params">(stuList head)</span></span>;</span><br><span class="line"><span class="comment">//找到两个链表的公共学生信息（以姓名为基准）合并成一个新的链表</span></span><br><span class="line"><span class="function">stuList <span class="title">getCommonStu</span><span class="params">(stuList L1, stuList L2)</span></span>;</span><br><span class="line"><span class="comment">//判断两个学生学生链表是否相交</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judgeInterSect</span><span class="params">(stuList L1, stuList L2)</span></span>;</span><br><span class="line"><span class="comment">//判断学生链表是否存在环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judgeLoop</span><span class="params">(stuList head)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"please input students number: "</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	student *stu;</span><br><span class="line">	stu = inputStu(n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"----输出学生数组----\n"</span>);</span><br><span class="line">	printStu(stu, n);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"----输出排序后学生数组----\n"</span>);</span><br><span class="line">	<span class="comment">//bubbleSortStu(stu, n);</span></span><br><span class="line">	<span class="comment">//insertSortStu(stu, n);</span></span><br><span class="line">	<span class="comment">//selectSortStu(stu, n);</span></span><br><span class="line">	quickSort(stu, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	printStu(stu, n);</span><br><span class="line"></span><br><span class="line">	stuList head;</span><br><span class="line">	<span class="comment">//head = creat1(stu, n); //头结点头插法测试</span></span><br><span class="line">	head = creat1_2(stu, n); <span class="comment">//头结点尾插法测试</span></span><br><span class="line"><span class="comment">//	head = creat2(stu, n); //不带头结点尾插法测试</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"----输出学生链表----\n"</span>);</span><br><span class="line">	printList(head-&gt;next);</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	printf("----Input插入学生信息---");</span></span><br><span class="line"><span class="comment">//	student e = inputAStu();</span></span><br><span class="line"><span class="comment">//	addStuNode(&amp;head, e);</span></span><br><span class="line"><span class="comment">//	printf("----输出学生链表----\n");</span></span><br><span class="line"><span class="comment">//	printList(head);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	printf("\n----Input待删除学生姓名---\n");</span></span><br><span class="line"><span class="comment">//	char delname[10];</span></span><br><span class="line"><span class="comment">//	getchar();</span></span><br><span class="line"><span class="comment">//	gets(delname);</span></span><br><span class="line"><span class="comment">//	if(delStuNode(&amp;head, delname)){</span></span><br><span class="line"><span class="comment">//		printf("delete successful!\n");</span></span><br><span class="line"><span class="comment">//	}else{</span></span><br><span class="line"><span class="comment">//		printf("no find this student!\n");</span></span><br><span class="line"><span class="comment">//	}</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//	printf("----逆置学生链表----\n");</span></span><br><span class="line"><span class="comment">//	head = reverseStuList(head);</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	int n2;</span></span><br><span class="line"><span class="comment">//	printf("please input students number: ");</span></span><br><span class="line"><span class="comment">//	scanf("%d", &amp;n2);</span></span><br><span class="line"><span class="comment">//	student *stu2;</span></span><br><span class="line"><span class="comment">//	stu2 = inputStu(n2);</span></span><br><span class="line"><span class="comment">//	printf("----输出学生数组----\n");</span></span><br><span class="line"><span class="comment">//	printStu(stu2, n2);</span></span><br><span class="line"><span class="comment">//	printf("----输出排序后学生数组----\n");</span></span><br><span class="line"><span class="comment">//	quickSort(stu2, 0, n2 - 1);</span></span><br><span class="line"><span class="comment">//	printStu(stu2, n2);</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	stuList head2;</span></span><br><span class="line"><span class="comment">//	head2 = creat1_2(stu2, n2); //头结点尾插法测试</span></span><br><span class="line"><span class="comment">//	printf("----输出学生链表----\n");</span></span><br><span class="line"><span class="comment">//	printList(head2-&gt;next);</span></span><br><span class="line"><span class="comment">//	printf("----合并两个链表---\n");</span></span><br><span class="line"><span class="comment">//	stuList head3 =  mergeList(head, head2);</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	printf("----输出合并后学生链表----\n");</span></span><br><span class="line"><span class="comment">//	printList(head3-&gt;next);</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	printf("----删除平均分最小的节点---\n");</span></span><br><span class="line"><span class="comment">//	head = delStuMinAve(head);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	int n2;</span></span><br><span class="line"><span class="comment">//	printf("please input students number: ");</span></span><br><span class="line"><span class="comment">//	scanf("%d", &amp;n2);</span></span><br><span class="line"><span class="comment">//	student *stu2;</span></span><br><span class="line"><span class="comment">//	stu2 = inputStu(n2);</span></span><br><span class="line"><span class="comment">//	printf("----输出学生数组----\n");</span></span><br><span class="line"><span class="comment">//	printStu(stu2, n2);</span></span><br><span class="line"><span class="comment">//	printf("----输出排序后学生数组----\n");</span></span><br><span class="line"><span class="comment">//	quickSort(stu2, 0, n2 - 1);</span></span><br><span class="line"><span class="comment">//	printStu(stu2, n2);</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	stuList head2;</span></span><br><span class="line"><span class="comment">//	head2 = creat1_2(stu2, n2); //头结点尾插法测试</span></span><br><span class="line"><span class="comment">//	printf("----输出学生链表----\n");</span></span><br><span class="line"><span class="comment">//	printList(head2-&gt;next);</span></span><br><span class="line"><span class="comment">//	printf("----找到公共学生信息链表---\n");</span></span><br><span class="line"><span class="comment">//	stuList head3 =  getCommonStu(head, head2);</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"----输出删除的后学生链表----\n"</span>);</span><br><span class="line">	printList(head-&gt;next);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入一个学生信息</span></span><br><span class="line"><span class="function">student <span class="title">inputAStu</span><span class="params">()</span></span>{</span><br><span class="line">	student stu;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"该学生(依次输入学号、姓名、性别、三门课成绩 ）："</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%s%s"</span>, &amp;stu.num, stu.name, stu.sex);</span><br><span class="line">	<span class="keyword">int</span> j, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++){</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;stu.score[j]);</span><br><span class="line">		sum += stu.score[j];</span><br><span class="line">	}</span><br><span class="line">	stu.ave = (<span class="keyword">float</span>)sum / <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">return</span> stu;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输入n 个学生信息， 返回学生数组 </span></span><br><span class="line"><span class="function">student* <span class="title">inputStu</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	student *stu = (student *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(student) * n);</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Input n students:\n"</span>); </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"No.%d (依次输入学号、姓名、性别、三门课成绩 ）："</span>, ++count);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%s%s"</span>, &amp;stu[i].num, stu[i].name, stu[i].sex);</span><br><span class="line">		<span class="keyword">int</span> j, sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++){</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;stu[i].score[j]);</span><br><span class="line">			sum += stu[i].score[j];</span><br><span class="line">		}</span><br><span class="line">		stu[i].ave = (<span class="keyword">float</span>)sum / <span class="number">3</span>;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> stu; </span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStu</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"第%d个学生：%d  %s  %s  %d  %d  %d  %.2f\n"</span>,i + <span class="number">1</span>, stu[i].num, stu[i].name, stu[i].sex, stu[i].score[<span class="number">0</span>], stu[i].score[<span class="number">1</span>], stu[i].score[<span class="number">2</span>], stu[i].ave);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//为学生数据进行按照平均分大小进行降序排序（分别使用冒泡排序、选择排序、插入排序、快速排序实现）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSortStu</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	student temp;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++){</span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(j = n - <span class="number">1</span>; j &gt; i; j--){</span><br><span class="line">			<span class="keyword">if</span>(stu[j - <span class="number">1</span>].ave-stu[j].ave &lt; <span class="number">1e-6</span>){</span><br><span class="line">				temp = stu[j];</span><br><span class="line">				stu[j] = stu[j - <span class="number">1</span>];</span><br><span class="line">				stu[j - <span class="number">1</span>] = temp;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(flag == <span class="number">0</span>){<span class="comment">//此汤未发生交换则提前结束排序没因为已经有序</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSortStu</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	student temp;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++){</span><br><span class="line">		<span class="keyword">if</span>(stu[i - <span class="number">1</span>].ave-stu[i].ave &lt; <span class="number">1e-6</span>){</span><br><span class="line">			temp = stu[i];</span><br><span class="line">			<span class="keyword">for</span>(j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; stu[j].ave-temp.ave &lt; <span class="number">1e-6</span>; j--){</span><br><span class="line">				stu[j + <span class="number">1</span>] = stu[j];</span><br><span class="line">			}</span><br><span class="line">			stu[j + <span class="number">1</span>] = temp;	</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSortStu</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	student temp; </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++){</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">max</span> = i;</span><br><span class="line">		<span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; n; j++){</span><br><span class="line">			<span class="keyword">if</span>(stu[<span class="built_in">max</span>].ave-stu[j].ave &lt; <span class="number">1e-6</span>){</span><br><span class="line">				<span class="built_in">max</span> = j;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">max</span> != i){</span><br><span class="line">			temp = stu[i];</span><br><span class="line">			stu[i] = stu[<span class="built_in">max</span>];</span><br><span class="line">			stu[<span class="built_in">max</span>] = temp;</span><br><span class="line">		}</span><br><span class="line">	}	</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">patition</span><span class="params">(student *stu, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">	student pivot = stu[left];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(left &lt; right){</span><br><span class="line">		<span class="keyword">while</span>(left &lt; right &amp;&amp; stu[right].ave-pivot.ave &lt;= <span class="number">1e-6</span>) right--;</span><br><span class="line">		stu[left] = stu[right];</span><br><span class="line">		<span class="keyword">while</span>(left &lt; right &amp;&amp; stu[left].ave-pivot.ave &gt;= <span class="number">1e-6</span>) left++;</span><br><span class="line">		stu[right] = stu[left];</span><br><span class="line">	}</span><br><span class="line">	stu[left] = pivot;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(student *stu,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(left &lt; right){</span><br><span class="line">		<span class="keyword">int</span> pation = patition(stu, left, right);</span><br><span class="line">		quickSort(stu, left, pation - <span class="number">1</span>);</span><br><span class="line">		quickSort(stu, pation + <span class="number">1</span>, right);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//创建带有头结点的链表(头插法)</span></span><br><span class="line"><span class="function">stuList <span class="title">creat1</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	stuList head = (stuNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode));</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	stuList p;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">		p = (stuNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode));</span><br><span class="line">		p-&gt;stu = stu[i];</span><br><span class="line">		p-&gt;next = head-&gt;next;</span><br><span class="line">		head-&gt;next = p;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//创建带有头结点的链表(尾插法)</span></span><br><span class="line"><span class="function">stuList <span class="title">creat1_2</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	stuList head = (stuNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode));</span><br><span class="line">	stuList p, r = head;<span class="comment">//定义r为尾指针</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">		p = (stuNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode));</span><br><span class="line">		p-&gt;stu = stu[i];</span><br><span class="line">		r-&gt;next = p;</span><br><span class="line">		r = p;</span><br><span class="line">	}</span><br><span class="line">	r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建不带头结点的链表 (相当于尾插法)(可以写头插法，但是没必要，简单来说就是创建带有头结点的链表【同上】，最后返回的是head-&gt;next)</span></span><br><span class="line"><span class="function">stuList <span class="title">creat2</span><span class="params">(student *stu, <span class="keyword">int</span> n)</span></span>{</span><br><span class="line">	stuList head = (stuNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode));</span><br><span class="line">	stuList p, q;</span><br><span class="line">	head = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">		p = (stuNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode));</span><br><span class="line">		p-&gt;stu = stu[i];</span><br><span class="line">		<span class="keyword">if</span>(head == <span class="literal">NULL</span>){</span><br><span class="line">			head = p;</span><br><span class="line">			q = head;</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			q-&gt;next = p;</span><br><span class="line">			q = p;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一使用使用不带头结点的遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(stuList head)</span></span>{</span><br><span class="line">	stuList p = head;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>){</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"第%d个节点："</span>, ++i);</span><br><span class="line">		student stu = p-&gt;stu;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d  %s   %s  %d  %d  %d  %.2f\n"</span>, stu.num, stu.name, stu.sex, stu.score[<span class="number">0</span>], stu.score[<span class="number">1</span>], stu.score[<span class="number">2</span>], stu.ave);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//为链表添加一个学生信息(按平均分有序插入(带头结点))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addStuNode</span><span class="params">(stuList *head, student stu)</span></span>{</span><br><span class="line">	stuList p = *head, s = (stuList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode));</span><br><span class="line">	s-&gt;stu = stu;</span><br><span class="line">	s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>){</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;next-&gt;stu.ave - stu.ave &lt;= <span class="number">1e-6</span>){</span><br><span class="line">			s-&gt;next = p-&gt;next;</span><br><span class="line">			p-&gt;next = s;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(flag == <span class="number">0</span>){<span class="comment">//如果当前学生的成绩最小，即需要插入到链表末尾</span></span><br><span class="line">		p-&gt;next = s;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//链表中删除姓名为delname的全部学生信息,删除成功返回1，否则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delStuNode</span><span class="params">(stuList *head, <span class="keyword">char</span> *delname)</span></span>{</span><br><span class="line">	stuList p = *head, q;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>){</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strcmp</span>(p-&gt;next-&gt;stu.name, delname) == <span class="number">0</span>){</span><br><span class="line">			q = p-&gt;next;</span><br><span class="line">			p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">			q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">free</span>(q); </span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//将链表中的学生信息逆置(带头结点)【头插法实现逆置】</span></span><br><span class="line"><span class="function">stuList <span class="title">reverseStuList</span><span class="params">(stuList head)</span></span>{</span><br><span class="line">	stuList p = head-&gt;next, q;</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>){</span><br><span class="line">		q = p-&gt;next; <span class="comment">//q节点暂存p的后继</span></span><br><span class="line">		p-&gt;next = head-&gt;next; <span class="comment">//头插遍历</span></span><br><span class="line">		head-&gt;next = p;</span><br><span class="line">		p = q;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//将两个学生有序的链表合并，并保证合并后链表仍然有序(带头结点)</span></span><br><span class="line"><span class="function">stuList <span class="title">mergeList</span><span class="params">(stuList L1, stuList L2)</span></span>{</span><br><span class="line">	stuList head = (stuList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode)), p1 = L1-&gt;next, p2 = L2-&gt;next, r = head;</span><br><span class="line">	stuNode *s;</span><br><span class="line">	<span class="keyword">while</span>(p1 != <span class="literal">NULL</span> &amp;&amp; p2 != <span class="literal">NULL</span>){</span><br><span class="line">		s = (stuNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode));</span><br><span class="line">		<span class="keyword">if</span>(p1-&gt;stu.ave - p2-&gt;stu.ave &lt; <span class="number">1e-6</span>){<span class="comment">//归并思想 大的先插（尾插法）</span></span><br><span class="line">			s-&gt;stu = p2-&gt;stu;</span><br><span class="line">			r-&gt;next = s;</span><br><span class="line">			r = s;</span><br><span class="line">			p2 = p2-&gt;next;</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			s-&gt;stu = p1-&gt;stu;</span><br><span class="line">			r-&gt;next = s;</span><br><span class="line">			r = s;</span><br><span class="line">			p1 = p1-&gt;next;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(p1){</span><br><span class="line">		r-&gt;next = p1;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(p2){</span><br><span class="line">		r-&gt;next = p2;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//链表中删除平均分最小的节点</span></span><br><span class="line"><span class="function">stuList <span class="title">delStuMinAve</span><span class="params">(stuList head)</span></span>{</span><br><span class="line">	stuList L = head, p = head-&gt;next;</span><br><span class="line">	<span class="keyword">char</span> delname[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">float</span> <span class="built_in">min</span> = p-&gt;stu.ave;</span><br><span class="line">	<span class="built_in">strcpy</span>(delname, p-&gt;stu.name);</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>){</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;stu.ave - <span class="built_in">min</span> &lt; <span class="number">1e-6</span>){</span><br><span class="line">			<span class="built_in">min</span> = p-&gt;stu.ave;</span><br><span class="line">			<span class="built_in">strcpy</span>(delname, p-&gt;stu.name);</span><br><span class="line">		}</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//直接调用前面写好的接口</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, delname);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(delStuNode(&amp;L, delname)){</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"成功\n"</span>);</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"失败\n"</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//找到两个链表的公共学生信息（以姓名为基准）合并成一个新的链表</span></span><br><span class="line"><span class="function">stuList <span class="title">getCommonStu</span><span class="params">(stuList L1, stuList L2)</span></span>{</span><br><span class="line">	stuList head = (stuList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode)), p1 = L1-&gt;next, p2 = L2-&gt;next, r = head;</span><br><span class="line">	stuNode *s;</span><br><span class="line">	<span class="keyword">while</span>(p1 != <span class="literal">NULL</span>){</span><br><span class="line">		<span class="keyword">while</span>(p2 != <span class="literal">NULL</span>){</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(p1-&gt;stu.name, p2-&gt;stu.name) == <span class="number">0</span>){</span><br><span class="line">				s = (stuNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuNode));</span><br><span class="line">				s-&gt;stu = p1-&gt;stu;</span><br><span class="line">				r-&gt;next = s;</span><br><span class="line">				r = s;</span><br><span class="line">			}</span><br><span class="line">			p2 = p2-&gt;next;</span><br><span class="line">		}</span><br><span class="line">		p2 = L2-&gt;next;</span><br><span class="line">		p1 = p1-&gt;next;</span><br><span class="line">	}</span><br><span class="line">	r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//判断两个学生学生链表是否相交</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judgeInterSect</span><span class="params">(stuList L1, stuList L2)</span></span>{</span><br><span class="line">	stuList p1 = L1, p2 = L2;</span><br><span class="line">	<span class="keyword">while</span>(p1-&gt;next != <span class="literal">NULL</span>){</span><br><span class="line">		p1 = p1-&gt;next;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span>(p2-&gt;next != <span class="literal">NULL</span>){</span><br><span class="line">		p2 = p2-&gt;next;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//如果两个链表相交，那么他们的最后一个节点一定相同</span></span><br><span class="line">	<span class="keyword">return</span> p1 == p2;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//判断学生链表是否存在环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judgeLoop</span><span class="params">(stuList head)</span></span>{</span><br><span class="line">	stuList p1 = head-&gt;next, p2 = head-&gt;next;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断有环的问题，一般使用快慢指针，快指针一次走两步，慢指针一次走一步，那么最终</span></span><br><span class="line">	<span class="comment">//如果有环，那么快指针和慢指针一定会相遇，如果无环，快指针一定能先走到NULL节点，此时退出</span></span><br><span class="line">	<span class="keyword">while</span>(p2 != <span class="literal">NULL</span>){</span><br><span class="line">		p2 = p2-&gt;next;</span><br><span class="line">		<span class="keyword">if</span>(p2 != <span class="literal">NULL</span>){</span><br><span class="line">			p2 = p2-&gt;next;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(p1 == p2){</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			p1 = p1-&gt;next;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



</li>
</ol>
<ol start="243">
<li><h3 id="栈队列"><a href="#栈队列" class="headerlink" title="栈队列"></a>栈队列</h3><p>1、堆栈与队列的基本概念与操作</p>
<p>1）、堆栈的基本概念与操作</p>
<pre><code>堆栈：只能在表的一端进行操作的线性表，一般的操作就是插入和删除，允许操作的一端称为栈顶，栈顶元素由栈顶指针给出，没有元素时为空栈
后进先出，先进后出
插入（入栈，进栈）
删除（出栈，退栈）
判空
判满
检索当前栈顶元素
特殊性：1、操作时一般线性表的子集；2、插入和删除的位置受到限制</code></pre></li>
</ol>
<pre><code>​    
2)、队列的基本概念与操作

    队列：队列简称队，是一种只能由一端进行插入，另一端进行删除的线性表。进行插入的一端称为队尾，用rear表示，删除的一端称为队头，用front指针表示
    先进先出，后进后出
    插入（进队，入队）
    删除（出队，退队）
    判空
    检索当前队头元素
    创建空队
    特殊性：1、操作时一般线性表的子集；2、插入和删除的位置受到限制


​    
​    
2、堆栈与队列的顺序存储结构与链式存储结构的构造原理

1）、堆栈的顺序存储结构

    一维数组SCACK[0..n-1],定义一个整型变量给出栈顶元素，但是不同于数组，数组时静态结构，堆栈是动态结构

   溢出：上溢：栈满时进行插入操作 top = n-1；下溢：栈空时进行删除操作  top = -1
   定义：

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1000</span></span><br><span class="line"><span class="keyword">int</span> STACK[M];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">-1</span>;  <span class="comment">//初始的时候top为-1，表示栈空</span></span><br></pre></td></tr></tbody></table></figure>

2)、堆栈的链式存储结构

    用线性链表表示，栈顶指针为NULL是为空

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>{</span></span><br><span class="line">     <span class="keyword">int</span> data;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line">}STNode, *STLink;</span><br></pre></td></tr></tbody></table></figure>

3）、队列的顺序存储结构

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一维数组QUEUE[<span class="number">0.</span>.n<span class="number">-1</span>],两个变量front和rear指出队头和队尾元素的位置。</span><br><span class="line">约定：rear指出实际队尾元素的位置</span><br><span class="line">      front指出队头元素的前一个位置</span><br><span class="line">      初始队列为空front = <span class="number">-1</span> ； rear = <span class="number">-1</span>； </span><br><span class="line">      判断队列为空的条件：front = rear；</span><br><span class="line">      </span><br><span class="line">#define M <span class="number">1000</span></span><br><span class="line"><span class="keyword">int</span> QUEUE[M];</span><br><span class="line"><span class="keyword">int</span> front, rear;</span><br></pre></td></tr></tbody></table></figure>

4）、队列的链式存储结构

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用线性链表表示，rear指出队尾，front指出队头</span><br><span class="line">空队列 front = <span class="literal">NULL</span>；</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> struct node{ </span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line">}QNode, *QLink;</span><br></pre></td></tr></tbody></table></figure>


3、在不同存储结构上对堆栈和队列进行插入和删除操作的算法设计

1）、顺序存储结构上对堆栈进行操作</code></pre><p>​       </p>
<pre><code><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">初始化</span><br><span class="line">     </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> &amp;top)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">       top = <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">     </span><br><span class="line">  判空</span><br><span class="line">     </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Empty</span><span class="params">(<span class="keyword">int</span> top)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">       <span class="keyword">return</span> top == <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">     </span><br><span class="line">  判满</span><br><span class="line">     </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">FULL</span><span class="params">(<span class="keyword">int</span> top)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">       <span class="keyword">return</span> top == M<span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">     </span><br><span class="line">  插入（进栈）</span><br><span class="line">     </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> Stack[], <span class="keyword">int</span> &amp;top, <span class="keyword">int</span> element)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">       <span class="keyword">if</span>(FULL(top)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">else</span>{</span><br><span class="line">           Stack[++top] = element;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       }</span><br><span class="line">  }</span><br><span class="line">     </span><br><span class="line">  删除（出栈）</span><br><span class="line">  <span class="keyword">int</span> Pop(<span class="keyword">int</span> Stack[], <span class="keyword">int</span> &amp;top, <span class="keyword">int</span> element)</span><br><span class="line">  {</span><br><span class="line">       <span class="keyword">if</span>(Empty(top))</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">else</span>{</span><br><span class="line">           element = Stack[top--];</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

2）、链式存储上对堆栈进行操作

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">初始化</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(STLink &amp;top)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    top = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">判空</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Empty</span><span class="params">(STLink top)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> top == <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">插入（进栈）不用判满</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(STLink &amp;top, <span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    STLink p;</span><br><span class="line">    <span class="keyword">if</span>(!(p = (STLink)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STNode))))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        p-&gt;data = item;</span><br><span class="line">        p-&gt;link = top;</span><br><span class="line">        top = p;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">删除（出栈）</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(STLink &amp;top, <span class="keyword">int</span> &amp;item)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    STLink p;</span><br><span class="line">    <span class="keyword">if</span>(Empty(top))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        p = top;</span><br><span class="line">        item = p-&gt;data;</span><br><span class="line">        top = top-&gt;link;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


​    
3）、在顺序存储结构上对队列进行操作

    初始化

    void Init(int &amp;front, int &amp;rear)
    {
        front = -1;
        rear = -1;
    }

    判空

    int Empty(int front, int rear)
    {
        return rear == front;
    }

    插入 
    int ADDQ(int Queue[], int &amp;rear, int item)
    {
        if(rear == M-1)    //假溢出
            return 0;
        else{
            Queue[++rear] = item;
            return 1;
        }
    }

    删除 
    int DELQ(int Queue[], int &amp;front, int rear, int &amp;item)
    {
        if(Empty(front, rear))
            return 0;
        else{
            item = Queue[--front];
            return 1;
        }
    }

    循环队列：将队列想象成头尾相连的表，使得队头删除的元素的空间能够尽可能被利用

    算法1：删除之后将每个元素前移一位。
            缺点：浪费空间

    算法2：求余

    添加：

    int ADDQ(int Q[], int &amp;rear, int &amp;front, int item)
    {
        if((rear+1)%M == front)
            return 0;
        else{
            Q[++rear%M] = item;
            return 1;
        }
    }

    删除：

    int DELQ(int Q[], int &amp;front, int &amp;rear, int &amp;item)
    {
        if(front == rear)
            return 0;
        else{
            front = (front + 1)%M;
            item = Q[front];
            return 1;
        }
    }

4）、在链式存储结构上对队列进行操作

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">初始化</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(QLink front, QLink rear)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    front = <span class="literal">NULL</span>;</span><br><span class="line">    rear = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">判空</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Empty</span><span class="params">(QLink front)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> fron == <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">插入</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ADDQ</span><span class="params">(QLink &amp;front, QLink &amp;rear, <span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QLink p;</span><br><span class="line">    <span class="keyword">if</span>(!(p = (QLink)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode))))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        p-&gt;data = item;</span><br><span class="line">        p-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(front == <span class="literal">NULL</span>)</span><br><span class="line">            front = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rear-&gt;link = p;</span><br><span class="line">        </span><br><span class="line">        rear = p;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">删除 </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DELQ</span><span class="params">(QLink &amp;front, QLink &amp;rear, <span class="keyword">int</span> &amp;item)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QLink p;</span><br><span class="line">    <span class="keyword">if</span>(Empty(front, rear))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        p = front;</span><br><span class="line">        front = front-&gt;link;</span><br><span class="line">        item = p-&gt;data;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></code></pre><p>​     </p>
<ol start="244">
<li></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>
    
    
    
	
	<div>
		
			<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
		
	</div>
	  
		<div>
		  <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/images/bolg_mask.png" alt="云澈 wechat" style="width: 200px; max-width: 100%;"/>
    <div>扫一扫，用手机访问哦</div>
</div>

		</div>
	  

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="https://i.loli.net/2020/06/10/PNbxe7H5KXJgcoh.jpg" alt="云澈 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="https://i.loli.net/2020/06/10/FQkTKeyYndB5WhP.jpg" alt="云澈 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    云澈
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://liudufu.github.io/knowledge_C_language/" title="Easy to mix knowledge points of C language">https://liudufu.github.io/knowledge_C_language/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 学习笔记</a>
          
            <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C</a>
          
            <a href="/tags/%E8%80%83%E7%A0%94/" rel="tag"><i class="fa fa-tag"></i> 考研</a>
          
            <a href="/tags/807/" rel="tag"><i class="fa fa-tag"></i> 807</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div id="needsharebutton-postbottom">
            <span class="btn">
              <i class="fa fa-share-alt" aria-hidden="true"></i>
            </span>
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/Servlet_Basics/" rel="next" title="servlet基础">
                servlet基础 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC81MDQzNi8yNjkyMw"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
			  <a href="/">
                <img class="site-author-image" itemprop="image"
                  src="https://s1.ax1x.com/2020/07/20/UfbOPJ.jpg"
                  alt="云澈" />
			  </a>
            
              <p class="site-author-name" itemprop="name">云澈</p>
              <p class="site-description motion-element" itemprop="description">Time would heal almost all wounds,if your wounds have not been healed up.please wait for a short while</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">106</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/liudufu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:2649176532@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/liudufu" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://me.csdn.net/weixin_45333934" target="_blank" title="csdn">
                      
                        <i class="fa fa-fw fa-heartbeat"></i>csdn</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/yourname" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.cnblogs.com/dufu-csdn/" target="_blank" title="博客园">
                      
                        <i class="fa fa-fw fa-instagram"></i>博客园</a>
                  </span>
                
            </div>
          
		  
		  
		  
		    <div class="links-of-blogroll motion-element links-of-blogroll-block">
			  <div class="links-of-blogroll-title">
			    <!-- modify icon to fire by szw -->
			    <i class="fa fa-history fa-" aria-hidden="true"></i>
			    近期文章
			  </div>
			  <ul class="links-of-blogroll-list">
			    
			    
				  <li class="recent_posts_li">
				    <a href="/knowledge_C_language/" title="Easy to mix knowledge points of C language" target="_blank">Easy to mix knowledge points of C language</a>
				  </li>
			    
				  <li class="recent_posts_li">
				    <a href="/Servlet_Basics/" title="servlet基础" target="_blank">servlet基础</a>
				  </li>
			    
				  <li class="recent_posts_li">
				    <a href="/The_difference_and_basic_usage_of_JPA_and_JDBC/" title="JPA与JDBC的区别和基本用法" target="_blank">JPA与JDBC的区别和基本用法</a>
				  </li>
			    
				  <li class="recent_posts_li">
				    <a href="/Mapper_relation_of_mybatis/" title="关于数据库和mybatis的mapper关系" target="_blank">关于数据库和mybatis的mapper关系</a>
				  </li>
			    
				  <li class="recent_posts_li">
				    <a href="/How_to_install_redis_under_Windows/" title="windows下如何安装redis" target="_blank">windows下如何安装redis</a>
				  </li>
			    
			  </ul>
		    </div>
		  
		  
		  <div id="music163player">
			<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1428784488&auto=1&height=66"></iframe>
		  </div>
		  
          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
        
			  
                <span class="links-of-author-item" style="text-align: left">
                  <a href="https://leetcode-cn.com/" title="leetcode" target="_blank" rel="external nofollow">leetcode</a>
                </span>
              
                <span class="links-of-author-item" style="text-align: left">
                  <a href="https://gitee.com/dufu-03-13/" title="码云" target="_blank" rel="external nofollow">码云</a>
                </span>
              
                <span class="links-of-author-item" style="text-align: left">
                  <a href="http://www.alloyteam.com/nav/" title="Web前端导航" target="_blank" rel="external nofollow">Web前端导航</a>
                </span>
              
                <span class="links-of-author-item" style="text-align: left">
                  <a href="http://www.36zhen.com/t?id=3448" title="前端书籍资料" target="_blank" rel="external nofollow">前端书籍资料</a>
                </span>
              
                <span class="links-of-author-item" style="text-align: left">
                  <a href="http://ife.baidu.com/" title="百度前端技术学院" target="_blank" rel="external nofollow">百度前端技术学院</a>
                </span>
              
                <span class="links-of-author-item" style="text-align: left">
                  <a href="http://wf.uisdc.com/cn/" title="google前端开发基础" target="_blank" rel="external nofollow">google前端开发基础</a>
                </span>
              
		  <div id="days"></div>
<script>
function show_date_time(){
window.setTimeout("show_date_time()",1000);
BirthDay=new Date("06/01/2020 15:13:14");
today=new Date();
timeold=(today.getTime()-BirthDay.getTime());
sectimeold=timeold/1000
secondsold=Math.floor(sectimeold);
msPerDay=24*60*60*1000
e_daysold=timeold/msPerDay
daysold=Math.floor(e_daysold);
e_hrsold=(e_daysold-daysold)*24;
hrsold=setzero(Math.floor(e_hrsold));
e_minsold=(e_hrsold-hrsold)*60;
minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
seconds=setzero(Math.floor((e_minsold-minsold)*60));
document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";
}
function setzero(i){
if (i<10)
{i="0" + i};
return i;
}
show_date_time();
</script>


            </div>
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#🌸易混知识点"><span class="nav-number">1.</span> <span class="nav-text">🌸易混知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#链表练习"><span class="nav-number">1.1.</span> <span class="nav-text">链表练习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#栈队列"><span class="nav-number">1.1.1.</span> <span class="nav-text">栈队列</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2020 &mdash; <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="heart">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">云澈</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">212.4k</span>
  
  
   <span style="margin-left:8px;">
   <script src="http://s6.cnzz.com/stat.php?id=1278978367&web_id=1278978367" type="text/javascript"></script>
   </span>

</div>










<div class="weixin-box">
  <div class="weixin-menu">
    <div class="weixin-hover">
      <div class="weixin-description">微信扫一扫，订阅本博客</div>
    </div>
  </div>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共212.4k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1278978367&web_id=1278978367" language="JavaScript"></script>
  </div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("ToKAq6EqsKrh3oh1kL7AwHkb-9Nh9j0Va", "Jjb4SKFne0eAr0pwOARr8X21");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "default";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "default";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "topRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  

  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1278978367&web_id=1278978367" language="JavaScript"></script>
  </div>



  
  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>
  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":300,"left":120},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body>
</html>
<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/src/love.js"></script>
